import { Component, EventEmitter, Input, OnChanges, OnInit, Output, SimpleChanges } from '@angular/core';
import { FormArray, FormBuilder, FormControl, FormGroup, Validators } from '@angular/forms';
import { MAT_MOMENT_DATE_ADAPTER_OPTIONS, MAT_MOMENT_DATE_FORMATS } from '@angular/material-moment-adapter';
import { DateAdapter, MAT_DATE_FORMATS, MAT_DATE_LOCALE } from '@angular/material/core';
import { ActivatedRoute } from '@angular/router';
import { CookieService } from 'ngx-cookie-service';
import { ToastrService } from 'ngx-toastr';
import { BehaviorSubject, Observable, of, Subscription } from 'rxjs';
import { CleaningPluginBasedOnConfigurationData, CleaningPluginBasedOnData, CleaningPluginDetailsPeriodicalInterval, CleaningPluginDetailsBasedOnData, CleaningPluginDetailsData, CleaningPluginDisplayStyleData, CleaningPluginGridData, CleaningPluginsClient, CleaningPluginsConfigurationData, CleaningPluginTypeData, GetCleaningPluginDetailsQuery, GetHotelHierarchyQuery, GetHotelRoomCategoriesQuery, GetHotelRoomsQuery, HotelClient, HotelHierarchyData, HotelRoomCategoryData, HotelRoomCreditsData, HotelRoomData, InsertCleaningPluginCommand, InsertCleaningPluginData, KeyValue, ProcessResponse, ProcessResponseOfGuid, SavePeriodicalIntervalData, SaveBasedOnData, SaveBasedOnRoomCategory, UpdateCleaningPluginCommand, UpdateCleaningPluginData, CleaningPluginDetailsBasedOnProdutsTagsExtendedData, SaveBasedOnProductsTags, SaveBasedOnOtherProperties, CleaningPluginDetailsBasedOnOtherPropertiesExtendedData, ProductClient, GetListOfProductsQuery, ProductListItem } from '../../core/autogenerated-clients/api-client';
import { CustomDateAdapter } from '../../core/custom-date-adapter';
import { LoadingService } from '../../core/services/loading.service';
import { HotelRoomCreditsItem } from '../../shared/components/room-credits-multiselect/room-credits-multiselect.component';

@Component({
  selector: 'app-plugin-details',
  templateUrl: './plugin-details.component.html',
  styleUrls: ['./plugin-details.component.scss'],
  providers: [
    // `MomentDateAdapter` and `MAT_MOMENT_DATE_FORMATS` can be automatically provided by importing
    // `MatMomentDateModule` in your applications root module. We provide it at the component level
    // here, due to limitations of our example generation script.
    { provide: DateAdapter, useClass: CustomDateAdapter, deps: [MAT_DATE_LOCALE] },
    { provide: MAT_DATE_FORMATS, useValue: MAT_MOMENT_DATE_FORMATS },
    { provide: MAT_MOMENT_DATE_ADAPTER_OPTIONS, useValue: { useUtc: true } },
  ],
})
export class PluginDetailsComponent implements OnInit, OnChanges {

  @Input() hotelId: string;
  //@Input() nextOrdinalNumber: number = 1;
  @Input() plugin: CleaningPluginGridData;
  //@Input() plugin: CleaningPluginGridData;
  @Input() configuration: CleaningPluginsConfigurationData;

  @Output() inserted: EventEmitter<{ id: string, name: string, isActive: boolean, isTopRule: boolean, ordinalNumber: number }> = new EventEmitter<{ id: string, name: string, isActive: boolean, isTopRule: boolean, ordinalNumber: number }>();
  @Output() updated: EventEmitter<{ id: string, name: string, isActive: boolean, isTopRule: boolean, ordinalNumber: number }> = new EventEmitter<{ id: string, name: string, isActive: boolean, isTopRule: boolean, ordinalNumber: number }>();

  private _newPluginDetailsData: CleaningPluginDetailsData = new CleaningPluginDetailsData({
    id: null,
    isActive: true,
    name: null,
    changeSheets: false,
    isNightlyCleaningPlugin: false,
    cleanOnHolidays: false,
    cleanOnSaturday: false,
    cleanOnSunday: false,
    isTopRule: false,
    postponeUntilVacant: false,
    basedOns: [],
    color: null,
    dailyCleaningTimeTypeKey: "ANY_TIME",
    dailyCleaningTypeTimes: [],
    displayStyleKey: null,
    hotelId: null,
    instructions: null,
    monthlyCleaningTypeTimeOfMonthKey: null,
    startsCleaningAfter: null,
    typeKey: null,
    ordinalNumber: 0,
    //balancingIntervals: [],
    //balancingPeriodicalEveryNumberOfDays: 7,
    //balancingPeriodicalNumberOfCleanings: 1,

    periodicalIntervals: [],
    periodicalPostponeSundayCleaningsToMonday: false,

    weekBasedCleaningTypeWeeks: [],
    weeklyCleaningTypeFridayTimes: [],
    weeklyCleaningTypeMondayTimes: [],
    weeklyCleaningTypeSaturdayTimes: [],
    weeklyCleaningTypeSundayTimes: [],
    weeklyCleaningTypeThursdayTimes: [],
    weeklyCleaningTypeTuesdayTimes: [],
    weeklyCleaningTypeWednesdayTimes: [],
    weeklyCleanOnFriday: true,
    weeklyCleanOnMonday: true,
    weeklyCleanOnSaturday: true,
    weeklyCleanOnSunday: true,
    weeklyCleanOnThursday: true,
    weeklyCleanOnTuesday: true,
    weeklyCleanOnWednesday: true,
    weeklyTimeFridayTypeKey: "ANY_TIME",
    weeklyTimeMondayTypeKey: "ANY_TIME",
    weeklyTimeSaturdayTypeKey: "ANY_TIME",
    weeklyTimeSundayTypeKey: "ANY_TIME",
    weeklyTimeThursdayTypeKey: "ANY_TIME",
    weeklyTimeTuesdayTypeKey: "ANY_TIME",
    weeklyTimeWednesdayTypeKey: "ANY_TIME",

    weekBasedCleaningDayOfTheWeekKey: "MONDAY",
    //balancingPostponeSundayCleaningsToMonday: false
  });
  private _savedPluginId: string = null;

  pluginDetailsForm: FormGroup;
  pluginDetails$: BehaviorSubject<CleaningPluginDetailsData> = new BehaviorSubject<CleaningPluginDetailsData>(new CleaningPluginDetailsData(this._newPluginDetailsData));
  selectedBasedOnFormGroup$: BehaviorSubject<FormGroup> = new BehaviorSubject<FormGroup>(null);

  cleaningPluginTypes: CleaningPluginTypeData[] = [];
  cleaningPluginBasedOns: CleaningPluginBasedOnConfigurationData[] = [];
  displayStyles: CleaningPluginDisplayStyleData[] = [];

  loading: LoadingService;

  isCreateNew$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(true);
  isLoadingPluginDetails$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(true);

  areRoomCategoriesInitialized$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(false);
  isLoadingRoomCategories$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(true);
  roomCategories$: BehaviorSubject<HotelRoomCategoryData[]> = new BehaviorSubject<HotelRoomCategoryData[]>([]);
  
  areProductsInitialized$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(false);
  isLoadingProducts$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(true);
  products$: BehaviorSubject<ProductListItem[]> = new BehaviorSubject<ProductListItem[]>([]);

  isHotelHierarchyInitialized$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(false);
  isLoadingHotelHierarchy$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(true);
  hotelHierarchy$: BehaviorSubject<HotelHierarchyData> = new BehaviorSubject<HotelHierarchyData>(new HotelHierarchyData({ buildings: [] }));

  areHotelRoomsInitialized$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(false);
  isLoadingHotelRooms$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(true);
  hotelRooms$: BehaviorSubject<HotelRoomData[]> = new BehaviorSubject<HotelRoomData[]>([]);

  isDataInitialized$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(false);

  private _basedOnIdGenerator: number = 1;

  get weekBasedCleaningTypeWeeksArray(): FormArray {
    return this.pluginDetailsForm.controls.weekBasedCleaningTypeWeeks as FormArray;
  }

  get periodicalIntervalsArray(): FormArray {
    return this.pluginDetailsForm.controls.periodicalIntervalsFormArray as FormArray;
  }

  get basedOnsFormArray(): FormArray {
    return this.pluginDetailsForm.controls.basedOnsFormArray as FormArray;
  }

  constructor(
    private _formBuilder: FormBuilder,
    private _toastr: ToastrService,
    private _cookieService: CookieService,
    private _hotelClient: HotelClient,
    private _route: ActivatedRoute,
    private _productClient: ProductClient,
    private _cleaningPluginsClient: CleaningPluginsClient
  ) {
    this.loading = new LoadingService();
  }

  ngOnInit() {
    console.log("PLUGIN DETAILS ON INIT");
    this._initializeConfiguration(this.configuration);
    this._loadPlugin();
    this._loadHotelSpecificData();

    this.areRoomCategoriesInitialized$.subscribe((initialized: boolean) => {
      this.isDataInitialized$.next(this.areRoomCategoriesInitialized$.value && this.areHotelRoomsInitialized$.value && this.isHotelHierarchyInitialized$.value);
    });
    this.isHotelHierarchyInitialized$.subscribe((initialized: boolean) => {
      this.isDataInitialized$.next(this.areRoomCategoriesInitialized$.value && this.areHotelRoomsInitialized$.value && this.isHotelHierarchyInitialized$.value);
    });
    this.areHotelRoomsInitialized$.subscribe((initialized: boolean) => {
      this.isDataInitialized$.next(this.areRoomCategoriesInitialized$.value && this.areHotelRoomsInitialized$.value && this.isHotelHierarchyInitialized$.value);
    });
  }

  ngOnChanges(changes: SimpleChanges): void {
    if (changes.plugin && !changes.plugin.firstChange && this._savedPluginId !== null && this._savedPluginId === changes.plugin.currentValue.id) {
      this._savedPluginId = null;
      return;
    }

    if (changes.hotelId && !changes.hotelId.firstChange) {
      this.areRoomCategoriesInitialized$.next(false);
      this.areHotelRoomsInitialized$.next(false);
      this.isHotelHierarchyInitialized$.next(false);
      this._loadHotelSpecificData();
    }

    if (changes.plugin && !changes.plugin.firstChange) {
      this._loadPlugin();
      this.selectedBasedOnFormGroup$.next(null);
    }
  }

  deletePeriodicalInterval(intervalIndex: number) {

  }

  addNewPeriodicalInterval() {
    this.periodicalIntervalsArray.push(this._createPeriodicalIntervalFormGroup(new CleaningPluginDetailsPeriodicalInterval({
      numberOfCleanings: 1,
      fromDayKey: "CHECK_IN",
      periodTypeKey: "BALANCE_OVER_RESERVATION",
      everyNumberOfDays: 7,
      fromNights: 1,
      toNights: 1,
      intervalTypeKey: "FROM",
    })));
  }

  save() {
    if (!this.pluginDetailsForm.valid) {
      this._toastr.error("You have to fix form errors before you can save the plugin.");
      this.pluginDetailsForm.markAllAsTouched();
      this.pluginDetailsForm.markAsDirty({ onlySelf: false });
      return;
    }

    this.loading.start();

    let formValues = this.pluginDetailsForm.getRawValue();
    console.log("TRYING TO SAVE: ", formValues);

    let insertRequest: InsertCleaningPluginCommand = new InsertCleaningPluginCommand({
      data: new InsertCleaningPluginData({
        isActive: formValues.isActive,
        ordinalNumber: +(formValues.ordinalNumber),
        changeSheets: formValues.changeSheets,
        isNightlyCleaningPlugin: formValues.isNightlyCleaningPlugin,
        cleanOnHolidays: formValues.cleanOnHolidays,
        cleanOnSaturday: formValues.cleanOnSaturday,
        cleanOnSunday: formValues.cleanOnSunday,
        isTopRule: formValues.isTopRule,
        postponeUntilVacant: formValues.postponeUntilVacant,
        color: formValues.color,
        dailyCleaningTimeTypeKey: formValues.dailyCleaningTimeTypeKey,
        hotelId: this.hotelId,
        instructions: formValues.instructions,
        monthlyCleaningTypeTimeOfMonthKey: formValues.monthlyCleaningTypeTimeOfMonthKey,
        name: formValues.name,
        startsCleaningAfter: +(formValues.startsCleaningAfter ?? 0),
        displayStyleKey: formValues.displayStyle?.name,
        typeKey: formValues.type?.key,

        periodicalIntervals: formValues.periodicalIntervalsFormArray.map(bi => new SavePeriodicalIntervalData({
          numberOfCleanings: +(bi.numberOfCleanings ?? 0),
          everyNumberOfDays: +(bi.everyNumberOfDays ?? 0),
          fromNights: +(bi.fromNights ?? 0),
          toNights: +(bi.toNights ?? 0),
          fromDayKey: bi.fromDayKey,
          periodTypeKey: bi.periodTypeKey,
          intervalTypeKey: bi.intervalTypeKey
        })),
        periodicalPostponeSundayCleaningsToMonday: formValues.periodicalPostponeSundayCleaningsToMonday,

        weeklyCleanOnFriday: formValues.weeklyCleanOnFriday,
        weeklyCleanOnMonday: formValues.weeklyCleanOnMonday,
        weeklyCleanOnSaturday: formValues.weeklyCleanOnSaturday,
        weeklyCleanOnSunday: formValues.weeklyCleanOnSunday,
        weeklyCleanOnThursday: formValues.weeklyCleanOnThursday,
        weeklyCleanOnTuesday: formValues.weeklyCleanOnTuesday,
        weeklyCleanOnWednesday: formValues.weeklyCleanOnWednesday,

        weeklyTimeFridayTypeKey: formValues.weeklyTimeFridayTypeKey,
        weeklyTimeMondayTypeKey: formValues.weeklyTimeMondayTypeKey,
        weeklyTimeSaturdayTypeKey: formValues.weeklyTimeSaturdayTypeKey,
        weeklyTimeSundayTypeKey: formValues.weeklyTimeSundayTypeKey,
        weeklyTimeThursdayTypeKey: formValues.weeklyTimeThursdayTypeKey,
        weeklyTimeTuesdayTypeKey: formValues.weeklyTimeTuesdayTypeKey,
        weeklyTimeWednesdayTypeKey: formValues.weeklyTimeWednesdayTypeKey,

        weeklyCleaningTypeFridayTimes: formValues.weeklyCleaningTypeFridayTimes.map(wt => wt.time),
        weeklyCleaningTypeMondayTimes: formValues.weeklyCleaningTypeMondayTimes.map(wt => wt.time),
        weeklyCleaningTypeSaturdayTimes: formValues.weeklyCleaningTypeSaturdayTimes.map(wt => wt.time),
        weeklyCleaningTypeSundayTimes: formValues.weeklyCleaningTypeSundayTimes.map(wt => wt.time),
        weeklyCleaningTypeThursdayTimes: formValues.weeklyCleaningTypeThursdayTimes.map(wt => wt.time),
        weeklyCleaningTypeTuesdayTimes: formValues.weeklyCleaningTypeTuesdayTimes.map(wt => wt.time),
        weeklyCleaningTypeWednesdayTimes: formValues.weeklyCleaningTypeWednesdayTimes.map(wt => wt.time),

        weekBasedCleaningTypeWeeks: formValues.weekBasedCleaningTypeWeeks.filter(ww => ww.isSelected).map(ww => ww.name),
        weekBasedCleaningDayOfTheWeekKey: formValues.weekBasedCleaningDayOfTheWeekKey,
        dailyCleaningTypeTimes: formValues.dailyCleaningTypeTimes.map(dt => dt.time),

        basedOns: formValues.basedOnsFormArray.map(bos => {
          let basedOn = new SaveBasedOnData({
            id: bos.id.toString(),
            name: bos.name,
            description: bos.description,
            key: bos.key,
            cleanDeparture: bos.cleanDeparture === undefined ? null : bos.cleanDeparture,
            cleanOutOfService: bos.cleanOutOfService === undefined ? null : bos.cleanOutOfService,
            cleanStay: bos.cleanStay === undefined ? null : bos.cleanStay,
            cleanVacant: bos.cleanVacant === undefined ? null : bos.cleanVacant,
            cleanVacantEveryNumberOfDays: +(bos.cleanVacantEveryNumberOfDays ?? 0),
            categories: bos.categoriesArray?.map(rc => new SaveBasedOnRoomCategory({ categoryId: rc.categoryId, credits: +rc.credits, isSelected: rc.isSelected })) || [],
            nights: bos.nightsArray?.map(n => n.value) || [],
            reservationSpaceCategories: bos.reservationSpaceCategoriesArray?.map(n => n.value) || [],
            productsTags: [],
            foorIds: [],
            sections: [],
            subSections: [],
            nightsEveryNumberOfDays: +(bos.nightsEveryNumberOfDays ?? 0),
            nightsFromKey: bos.nightsFromKey,
            nightsTypeKey: bos.nightsTypeKey,
            cleanlinessKey: bos.cleanlinessKey,
            rooms: bos.roomsArray?.map(r => new HotelRoomCreditsData({ roomId: r.id, credits: +(r.credits ?? 0) })),
            otherProperties: [],
            productsTagsMustBeConsumedOnTime: bos.productsTagsMustBeConsumedOnTime,
            productsTagsConsumationIntervalFrom: bos.productsTagsConsumationIntervalFrom,
            productsTagsConsumationIntervalTo: bos.productsTagsConsumationIntervalTo,
            productsTagsExtended: bos.productOrTagArray?.map(n => new SaveBasedOnProductsTags({ isCaseSensitive: n.isCaseSensitive, productId: n.productId, comparisonValue: n.comparisonValue, basedOnProductsTagsTypeKey: n.basedOnProductsTagsTypeKey })) || [],
            otherPropertiesExtended: bos.otherPropertiesArray?.map(op => new SaveBasedOnOtherProperties({ key: op.key, value: op.value, basedOnOtherPropertiesTypeKey: op.basedOnOtherPropertiesTypeKey })) || []
          });

          if (basedOn.key === "FLOOR") {
            let floorIds = [];
            for (let b of bos.buildingsArray) {
              for (let f of b.floorsArray) {
                if (f.isSelected) {
                  floorIds.push(f.floorId);
                }
              }
            }
            basedOn.foorIds = floorIds;
          }
          if (basedOn.key === "SECTION") {
            let sections = [];
            for (let b of bos.buildingsArray) {
              for (let f of b.floorsArray) {
                for (let s of f.sectionsArray) {
                  if (s.isSelected) {
                    sections.push(s.sectionName);
                  }
                }
              }
            }
            basedOn.sections = sections;
          }
          if (basedOn.key === "SUB_SECTION") {
            let subSections = [];
            for (let b of bos.buildingsArray) {
              for (let f of b.floorsArray) {
                for (let s of f.sectionsArray) {
                  for (let ss of s.subSectionsArray) {
                    if (ss.isSelected) {
                      subSections.push(ss.subSectionName);
                    }
                  }
                }
              }
            }
            basedOn.subSections = subSections;
          }

          return basedOn;
        }),
      })
    });

    if (this.isCreateNew$.value) {

      this._cleaningPluginsClient.insertCleaningPlugin(insertRequest).subscribe(
        (response: ProcessResponseOfGuid) => {
          if (response.hasError) {
            this._toastr.error(response.message);
            return;
          }

          this.pluginDetails$.next(new CleaningPluginDetailsData({ ...this.pluginDetails$.value, ...insertRequest.data, id: response.data }));
          this.isCreateNew$.next(false);
          this._savedPluginId = response.data;
          this._toastr.success(response.message);

          this.inserted.next({ id: response.data, name: insertRequest.data.name, isActive: insertRequest.data.isActive, isTopRule: insertRequest.data.isTopRule, ordinalNumber: insertRequest.data.ordinalNumber });
        },
        () => { },
        () => { this.loading.stop(); });
    }
    else {
      let updateRequest = new UpdateCleaningPluginCommand();
      updateRequest.init(insertRequest);
      updateRequest.data.id = this.pluginDetails$.value.id;

      console.log("UPDATING: ", updateRequest);

      this._cleaningPluginsClient.updateCleaningPlugin(updateRequest).subscribe(
        (response: ProcessResponse) => {
          if (response.hasError) {
            this._toastr.error(response.message);
            return;
          }

          this._toastr.success(response.message);
          this.updated.next({ id: updateRequest.data.id, name: updateRequest.data.name, isActive: updateRequest.data.isActive, isTopRule: updateRequest.data.isTopRule, ordinalNumber: updateRequest.data.ordinalNumber });
        },
        (error: Error) => {
          this._toastr.error(error.message);
        },
        () => {
          this.loading.stop();
        }
      );
    }
  }

  private _loadHotelSpecificData() {
    if (!this.areHotelRoomsInitialized$.value) {
      this.isLoadingHotelRooms$.next(true);
      this._hotelClient.getHotelRooms(new GetHotelRoomsQuery({ hotelId: this.hotelId })).subscribe(
        (rooms: HotelRoomData[]) => {
          this.hotelRooms$.next(rooms);
          this.areHotelRoomsInitialized$.next(true);
        },
        (error: Error) => {
          this._toastr.error(error.message);
        },
        () => {
          this.isLoadingHotelRooms$.next(false);
        },
      );
    }
    if (!this.areRoomCategoriesInitialized$.value) {
      this.isLoadingRoomCategories$.next(true);
      this._hotelClient.getHotelRoomCategories(new GetHotelRoomCategoriesQuery({})).subscribe(
        (categories: HotelRoomCategoryData[]) => {
          this.roomCategories$.next(categories);
          this.areRoomCategoriesInitialized$.next(true);
        },
        (error: Error) => {
          this._toastr.error(error.message);
        },
        () => {
          this.isLoadingRoomCategories$.next(false);
        },
      );
    }
    if (!this.isHotelHierarchyInitialized$.value) {
      this.isLoadingHotelHierarchy$.next(true);
      this._hotelClient.getHotelHierarchy(new GetHotelHierarchyQuery({ hotelId: this.hotelId })).subscribe(
        (hierarchy: HotelHierarchyData) => {
          this.hotelHierarchy$.next(hierarchy);
          this.isHotelHierarchyInitialized$.next(true);
        },
        (error: Error) => {
          this._toastr.error(error.message);
        },
        () => {
          this.isLoadingHotelHierarchy$.next(false);
        },
      );
    }

    if (!this.areProductsInitialized$.value) {
      this.isLoadingProducts$.next(true);
      this._productClient.getListOfProducts(new GetListOfProductsQuery({})).subscribe(
        (products: ProductListItem[]) => {
          this.products$.next(products);
          this.areProductsInitialized$.next(true);
        },
        (error: Error) => {
          this._toastr.error(error.message);
        },
        () => {
          this.isLoadingProducts$.next(false);
        },
      );
    }
  }

  toggleIsSelected(formGroup: FormGroup) {
    formGroup.controls.isSelected.setValue(!formGroup.controls.isSelected.value);

  }

  private _resetCachedHotelData(): void {
    this.isLoadingHotelHierarchy$.next(true);
    this.isLoadingRoomCategories$.next(true);
    this.hotelHierarchy$.next(new HotelHierarchyData({ buildings: [] }));
    this.roomCategories$.next([]);
  }

  private _loadPlugin(): void {
    this.isLoadingPluginDetails$.next(true);
    this._loadPluginDetails().subscribe(
      (pluginDetails: CleaningPluginDetailsData) => {
        console.log("LOADED PLUGIN DETAILS: ", pluginDetails);

        // This is a hack for old data. Old cleaning plugins don't have this key set.
        if (!pluginDetails.weekBasedCleaningDayOfTheWeekKey) {
          pluginDetails.weekBasedCleaningDayOfTheWeekKey = "MODAY";
        }

        this.pluginDetails$.next(pluginDetails);
        this._initializeCleaningPluginDetailsForm(pluginDetails);
      },
      (error: Error) => { this._toastr.error(error.message); },
      () => {
        this.isCreateNew$.next(this.plugin === null || !this.plugin.id);
        this.isLoadingPluginDetails$.next(false);
      }
    );
  }

  private _loadPluginDetails(): Observable<CleaningPluginDetailsData> {
    if (this.plugin && this.plugin.id) {
      return this._cleaningPluginsClient.getCleaningPluginDetails(new GetCleaningPluginDetailsQuery({ id: this.plugin.id }));
    }
    else {
      let pluginDetails = new CleaningPluginDetailsData(this._newPluginDetailsData);
      pluginDetails.ordinalNumber = this.plugin.ordinalNumber;
      return of(pluginDetails);
    }
  }

  private _initializeConfiguration(configuration: CleaningPluginsConfigurationData): void {
    this.cleaningPluginTypes = configuration.cleaningPluginTypes;
    this.displayStyles = configuration.displayStyles;
    this.cleaningPluginBasedOns = configuration.cleaningPluginBasedOns;
  }

  private _initializeCleaningPluginDetailsForm(pluginDetails: CleaningPluginDetailsData) {
    var weekNumbers: { isSelected: boolean, name: number }[] = [];

    for (let i = 1; i <= 53; i++) { weekNumbers.push({ isSelected: pluginDetails.weekBasedCleaningTypeWeeks.indexOf(i) >= 0, name: i }); }

    console.log("SETTING ORDINAL NUMBER: ", this.plugin.ordinalNumber);

    this.pluginDetailsForm = this._formBuilder.group({
      ordinalNumber: [{ value: this.plugin.ordinalNumber, disabled: true }],
      isActive: [pluginDetails.isActive],
      name: [pluginDetails.name, [Validators.required]],
      type: [this.cleaningPluginTypes.find(pt => pt.key === pluginDetails.typeKey), [Validators.required]],
      instructions: [pluginDetails.instructions],
      isTopRule: [pluginDetails.isTopRule, [Validators.required]],
      color: [pluginDetails.color],
      displayStyle: [this.displayStyles.find(s => s.name == pluginDetails.displayStyleKey)],
      startsCleaningAfter: [pluginDetails.startsCleaningAfter],
      postponeUntilVacant: [pluginDetails.postponeUntilVacant],
      cleanOnSaturday: [pluginDetails.cleanOnSaturday],
      cleanOnSunday: [pluginDetails.cleanOnSunday],
      cleanOnHolidays: [pluginDetails.cleanOnHolidays],
      changeSheets: [pluginDetails.changeSheets],
      isNightlyCleaningPlugin: [pluginDetails.isNightlyCleaningPlugin],

      basedOn: [null],

      // Daily cleaning type - a list of time spans
      dailyCleaningTimeTypeKey: [pluginDetails.dailyCleaningTimeTypeKey, [Validators.required]],
      dailyCleaningTypeTimes: this._formBuilder.array(
        pluginDetails.dailyCleaningTypeTimes.map(ft => this._formBuilder.group({ time: [ft] }))
      ),

      // Weekly cleaning type - a list of days, each with a list of time spans
      weeklyCleanOnMonday: [pluginDetails.weeklyCleanOnMonday, [Validators.required]],
      weeklyTimeMondayTypeKey: [pluginDetails.weeklyTimeMondayTypeKey, [Validators.required]],
      weeklyCleaningTypeMondayTimes: this._formBuilder.array(
        pluginDetails.weeklyCleaningTypeMondayTimes.map(ft => this._formBuilder.group({ time: [ft] }))
      ),
      weeklyCleanOnTuesday: [pluginDetails.weeklyCleanOnTuesday, [Validators.required]],
      weeklyTimeTuesdayTypeKey: [pluginDetails.weeklyTimeTuesdayTypeKey, [Validators.required]],
      weeklyCleaningTypeTuesdayTimes: this._formBuilder.array(
        pluginDetails.weeklyCleaningTypeTuesdayTimes.map(ft => this._formBuilder.group({ time: [ft] }))
      ),
      weeklyCleanOnWednesday: [pluginDetails.weeklyCleanOnWednesday, [Validators.required]],
      weeklyTimeWednesdayTypeKey: [pluginDetails.weeklyTimeWednesdayTypeKey, [Validators.required]],
      weeklyCleaningTypeWednesdayTimes: this._formBuilder.array(
        pluginDetails.weeklyCleaningTypeWednesdayTimes.map(ft => this._formBuilder.group({ time: [ft] }))
      ),
      weeklyCleanOnThursday: [pluginDetails.weeklyCleanOnThursday, [Validators.required]],
      weeklyTimeThursdayTypeKey: [pluginDetails.weeklyTimeThursdayTypeKey, [Validators.required]],
      weeklyCleaningTypeThursdayTimes: this._formBuilder.array(
        pluginDetails.weeklyCleaningTypeThursdayTimes.map(ft => this._formBuilder.group({ time: [ft] }))
      ),
      weeklyCleanOnFriday: [pluginDetails.weeklyCleanOnFriday, [Validators.required]],
      weeklyTimeFridayTypeKey: [pluginDetails.weeklyTimeFridayTypeKey, [Validators.required]],
      weeklyCleaningTypeFridayTimes: this._formBuilder.array(
        pluginDetails.weeklyCleaningTypeFridayTimes.map(ft => this._formBuilder.group({ time: [ft] }))
      ),
      weeklyCleanOnSaturday: [pluginDetails.weeklyCleanOnSaturday, [Validators.required]],
      weeklyTimeSaturdayTypeKey: [pluginDetails.weeklyTimeSaturdayTypeKey, [Validators.required]],
      weeklyCleaningTypeSaturdayTimes: this._formBuilder.array(
        pluginDetails.weeklyCleaningTypeSaturdayTimes.map(ft => this._formBuilder.group({ time: [ft] }))
      ),
      weeklyCleanOnSunday: [pluginDetails.weeklyCleanOnSunday, [Validators.required]],
      weeklyTimeSundayTypeKey: [pluginDetails.weeklyTimeSundayTypeKey, [Validators.required]],
      weeklyCleaningTypeSundayTimes: this._formBuilder.array(
        pluginDetails.weeklyCleaningTypeSundayTimes.map(ft => this._formBuilder.group({ time: [ft] }))
      ),

      periodicalIntervalsFormArray: this._createPeriodicalIntervalsFormArray(pluginDetails.periodicalIntervals),
      periodicalPostponeSundayCleaningsToMonday: [pluginDetails.periodicalPostponeSundayCleaningsToMonday],

      // Week based cleaning type - a list of numbers (weeks)
      weekBasedCleaningTypeWeeks: this._formBuilder.array(weekNumbers.map(week => this._formBuilder.group({ isSelected: [week.isSelected], name: [week.name] }))),

      weekBasedCleaningDayOfTheWeekKey: [pluginDetails.weekBasedCleaningDayOfTheWeekKey, [Validators.required]],

      // No cleaning
      // Monthly cleaning - start, middle, end, slice
      monthlyCleaningTypeTimeOfMonthKey: [pluginDetails.monthlyCleaningTypeTimeOfMonthKey],

      basedOnsFormArray: this._createBasedOnFormArray(pluginDetails.basedOns)
    });

    // On basedOn changed, add the basedOn to the selected ones
    this.pluginDetailsForm.controls.basedOn.valueChanges.subscribe((basedOnConfig: CleaningPluginBasedOnConfigurationData) => {
      if (basedOnConfig === null) {
        return;
      }

      this._basedOnIdGenerator++;
      let basedOn: CleaningPluginBasedOnData = new CleaningPluginBasedOnData({ ...basedOnConfig, id: this._basedOnIdGenerator.toString() })
      this.pluginDetailsForm.controls.basedOn.setValue(null);

      this._addNewBasedOnFormGroup(basedOn);
    });

    this.pluginDetailsForm.controls.type.valueChanges.subscribe((pluginType) => {
      console.log("PLUGIN TYPE CHANGED: ", pluginType);
      if (pluginType.key === "PERIODICAL" && this.pluginDetailsForm.controls.periodicalIntervalsFormArray.value.length === 0) {
        this.addNewPeriodicalInterval();
      }
    });
  }

  private _addNewBasedOnFormGroup(basedOn: CleaningPluginBasedOnData) {
    console.log("ADDING BASED ON: ");
    let basedOnFormGroup: FormGroup = this._createBasedOnFormGroup(basedOn);
    let basedOnsFormArray: FormArray = this.pluginDetailsForm.controls.basedOnsFormArray as FormArray;
    basedOnsFormArray.push(basedOnFormGroup);
    this.selectedBasedOnFormGroup$.next(basedOnFormGroup);
  }

  private _createPeriodicalIntervalsFormArray(intervals: CleaningPluginDetailsPeriodicalInterval[]): FormArray {
    return new FormArray(intervals.map(bi => this._createPeriodicalIntervalFormGroup(bi)));
  }

  private _createPeriodicalIntervalFormGroup(interval: CleaningPluginDetailsPeriodicalInterval): FormGroup {
    let form = this._formBuilder.group({
      intervalTypeKey: [interval.intervalTypeKey], // FROM, MORE_THAN
      fromNights: [interval.fromNights],
      toNights: [interval.toNights],
      periodTypeKey: [interval.periodTypeKey], // BALANCE_OVER_RESERVATION, BALANCE_OVER_PERIOD, ONCE_EVERY_N_DAYS
      numberOfCleanings: [interval.numberOfCleanings],
      everyNumberOfDays: [interval.everyNumberOfDays],
      fromDayKey: [interval.fromDayKey], // CHECK_IN, FIRST_MONDAY, FIRST_TUESDAY, FIRST_WEDNESDAY, FIRST_THURSDAY, FIRST_FRIDAY, FIRST_SATURDAY, FIRST_SUNDAY
    });

    return form;
  }

  private _createBasedOnFormArray(basedOns: CleaningPluginDetailsBasedOnData[]): FormArray {
    return new FormArray(basedOns.map(bo => this._createBasedOnFormGroup(bo)));
  }

  private _createBasedOnFormGroup(basedOn: CleaningPluginDetailsBasedOnData): FormGroup {
    this._basedOnIdGenerator++;
    switch (basedOn.key) {
      case "OTHER_PROPERTIES":
        return this._createBasedOnOtherPropertiesFormGroup(basedOn);
      case "OCCUPATION":
        return this._createBasedOnOccupancyFormGroup(basedOn);
      case "ROOM":
        return this._createBasedOnRoomFormGroup(basedOn);
      case "ROOM_CATEGORY":
        return this._createBasedOnRoomCategoryFormGroup(basedOn);
      case "NIGHTS":
        return this._createBasedOnNightsFormGroup(basedOn);
      case "RESERVATION_SPACE_CATEGORY":
        return this._createBasedOnReservationiSpaceCategoryFormGroup(basedOn);
      case "PRODUCT_TAG":
        return this._createBasedOnProductOrTagExtendedFormGroup(basedOn);
      case "FLOOR":
        return this._createBasedOnFloorFormGroup(basedOn);
      case "SECTION":
        return this._createBasedOnSectionFormGroup(basedOn);
      case "SUB_SECTION":
        return this._createBasedOnSubSectionFormGroup(basedOn);
      case "CLEANLINESS":
        return this._createBasedOnCleanlinessFormGroup(basedOn);
      case "ALL":
      default:
        return this._formBuilder.group({
          id: [this._basedOnIdGenerator],
          name: ["All"],
          description: ["Everything"],
          key: ["ALL"],
        });
    }
  }

  private _createBasedOnOccupancyFormGroup(basedOn: CleaningPluginDetailsBasedOnData): FormGroup {
    this._basedOnIdGenerator++;
    let formGroup = this._formBuilder.group({
      id: [this._basedOnIdGenerator],
      name: ["Occupancies"],
      description: [null],
      key: ["OCCUPATION"],
      cleanStay: [basedOn.cleanStay ? true : false, [Validators.required]],
      cleanVacant: [basedOn.cleanVacant ? true : false, [Validators.required]],
      cleanVacantEveryNumberOfDays: [basedOn.cleanVacantEveryNumberOfDays ? basedOn.cleanVacantEveryNumberOfDays : 7, [Validators.required]],
      cleanDeparture: [basedOn.cleanDeparture ? true : false, [Validators.required]],
      cleanOutOfService: [basedOn.cleanOutOfService ? true : false, [Validators.required]],
    });

    formGroup.controls.description.setValue(this._generateBasedOnOccupancyDescription(formGroup));

    formGroup.controls.cleanStay.valueChanges.subscribe(() => {
      formGroup.controls.description.setValue(this._generateBasedOnOccupancyDescription(formGroup));
    });
    formGroup.controls.cleanVacant.valueChanges.subscribe(() => {
      formGroup.controls.description.setValue(this._generateBasedOnOccupancyDescription(formGroup));
    });
    formGroup.controls.cleanDeparture.valueChanges.subscribe(() => {
      formGroup.controls.description.setValue(this._generateBasedOnOccupancyDescription(formGroup));
    });
    formGroup.controls.cleanOutOfService.valueChanges.subscribe(() => {
      formGroup.controls.description.setValue(this._generateBasedOnOccupancyDescription(formGroup));
    });

    return formGroup;
  }

  private _generateBasedOnOccupancyDescription(form: FormGroup) {
    let descriptions = [];

    if (form.get("cleanStay").value) {
      descriptions.push("Stay");
    }
    if (form.get("cleanDeparture").value) {
      descriptions.push("Departure");
    }
    if (form.get("cleanVacant").value) {
      descriptions.push("Vacant");
    }
    if (form.get("cleanOutOfService").value) {
      descriptions.push("Out of service");
    }

    if (descriptions.length > 0) {
      return descriptions.join(", ");
    }

    return "No statuses selected";
  }

  private _createBasedOnRoomFormGroup(basedOn: CleaningPluginDetailsBasedOnData): FormGroup {
    let roomIds = basedOn.rooms ? basedOn.rooms.map(r => r.roomId) : [];
    let rooms = roomIds.length === 0 ? [] : this.hotelRooms$.value.filter(hr => roomIds.indexOf(hr.id) >= 0);

    let roomCredits: HotelRoomCreditsItem[] = [];
    if (basedOn.rooms) {
      for (let r of basedOn.rooms) {
        roomCredits.push({
          credits: r.credits,
          room: rooms.find(ri => ri.id === r.roomId)
        });
      }
    }

    let description: string = rooms.length + " rooms";

    let formGroup = this._formBuilder.group({
      id: [this._basedOnIdGenerator],
      name: ["Rooms"],
      description: [description],
      key: ["ROOM"],
      roomsArray: new FormArray(roomCredits.map(rc => {
        let fg = this._formBuilder.group({
          id: [{ value: rc.room.id, disabled: true }],
          name: [{ value: rc.room.name, disabled: true }],
          building: [{ value: rc.room.building, disabled: true }],
          floor: [{ value: rc.room.floor, disabled: true }],
          section: [{ value: rc.room.section, disabled: true }],
          subSection: [{ value: rc.room.subSection, disabled: true }],
          credits: [rc.credits]
        });

        return fg;
      }))
    });

    formGroup.controls.roomsArray.valueChanges.subscribe(newValue => { formGroup.controls.description.setValue(newValue.length + " rooms"); });

    return formGroup;
  }

  private _createBasedOnRoomCategoryFormGroup(basedOn: CleaningPluginDetailsBasedOnData): FormGroup {
    let description: string = "All categories";
    if (basedOn.categories && basedOn.categories.filter(c => !c.isSelected).length) {
      let selectedCategoryIds: string[] = basedOn.categories.filter(c => c.isSelected).map(c => c.categoryId);
      description = this.roomCategories$.value.filter(c => selectedCategoryIds.indexOf(c.id) >= 0).map(c => c.name).join(", ");
    }

    let formGroup = this._formBuilder.group({
      id: [this._basedOnIdGenerator],
      name: ["Room categories"],
      description: [description],
      key: ["ROOM_CATEGORY"],
      categoriesArray: new FormArray(this.roomCategories$.value.map(category => {
        let categoryMatch = basedOn.categories ? basedOn.categories.find(c => c.categoryId === category.id) : null;

        let fg = this._formBuilder.group({
          categoryId: [{ value: category.id, disabled: true }, [Validators.required]],
          categoryName: [{ value: category.name, disabled: true }, [Validators.required]],
          isSelected: [categoryMatch ? categoryMatch.isSelected : true, [Validators.required]],
          credits: [categoryMatch ? +categoryMatch.credits : 0/*+category.defaultCredits*/, [Validators.required]]
        });

        return fg;
      }
      ))
    });

    let categoriesFormArray: FormArray = formGroup.controls.categoriesArray as FormArray;

    for (let formGroupValue of categoriesFormArray.controls) {
      let fg: FormGroup = formGroupValue as FormGroup;
      fg.controls.isSelected.valueChanges.subscribe((isSelected: boolean) => {
        let description: string = (categoriesFormArray.controls as FormGroup[]).filter(fgi => fgi.controls.isSelected.value).map(fgi => fgi.controls.categoryName.value).join(", ");
        formGroup.controls.description.setValue(description);
      });
    }

    return formGroup;
  }

  private _createBasedOnNightsFormGroup(basedOn: CleaningPluginDetailsBasedOnData): FormGroup {
    let description = "0 nights";
    if (basedOn.nightsTypeKey === "SPECIFIC_NIGHTS") {
      if (basedOn.nights && basedOn.nights.length > 0) {
        description = "Nights: " + basedOn.nights.join(", ");
      }
    }
    else {
      description = "Every " + basedOn.nightsEveryNumberOfDays + " days from " + basedOn.nightsFromKey;
    }


    let fg: FormGroup = this._formBuilder.group({
      id: [this._basedOnIdGenerator],
      name: ["Nights"],
      description: [description],
      key: ["NIGHTS"],
      nightsTypeKey: [basedOn.nightsTypeKey ?? "SPECIFIC_NIGHTS"],
      nightsEveryNumberOfDays: [basedOn.nightsEveryNumberOfDays === null || basedOn.nightsEveryNumberOfDays === undefined ? 7 : basedOn.nightsEveryNumberOfDays],
      nightsFromKey: [basedOn.nightsFromKey ?? "CHECK_IN"],
      nightsArray: new FormArray(
        basedOn.nights ? basedOn.nights.map(n => this._formBuilder.group({ id: [null], value: [n] })) : []
      )
    });

    fg.controls.nightsTypeKey.valueChanges.subscribe((nightsTypeKey: string) => {
      if (nightsTypeKey === "SPECIFIC_NIGHTS") {
        let description = (fg.controls.nightsArray as FormArray).controls.map((fg: FormGroup) => { return fg.controls.value.value; }).join(", ");
        if (description === "") {
          fg.controls.description.setValue("0 nights");
        }
        else {
          fg.controls.description.setValue("Nights: " + description);
        }
      }
      else {
        let description = "Every " + fg.controls.nightsEveryNumberOfDays.value + " days from " + fg.controls.nightsFromKey.value;
        fg.controls.description.setValue(description);
      }
    });
    fg.controls.nightsEveryNumberOfDays.valueChanges.subscribe((nightsTypeKey: string) => {
      if (fg.controls.nightsTypeKey.value === "PERIODICAL") {
        let description = "Every " + fg.controls.nightsEveryNumberOfDays.value + " days from " + fg.controls.nightsFromKey.value;
        fg.controls.description.setValue(description);
      }
    });
    fg.controls.nightsFromKey.valueChanges.subscribe((nightsTypeKey: string) => {
      if (fg.controls.nightsTypeKey.value === "PERIODICAL") {
        let description = "Every " + fg.controls.nightsEveryNumberOfDays.value + " days from " + fg.controls.nightsFromKey.value;
        fg.controls.description.setValue(description);
      }
    });

    fg.controls.nightsArray.valueChanges.subscribe((newValue) => {
      let description = (fg.controls.nightsArray as FormArray).controls.map((fg: FormGroup) => { return fg.controls.value.value; }).join(", ");
      if (description === "") {
        fg.controls.description.setValue("0 nights");
      }
      else {
        fg.controls.description.setValue("Nights: " + description);
      }
    });

    return fg;
  }

  private _createOtherPropertiesExtendedFormGroup(baseOnOtherProperties: CleaningPluginDetailsBasedOnOtherPropertiesExtendedData) {
    return this._formBuilder.group({
      basedOnOtherPropertiesTypeKey: [baseOnOtherProperties.basedOnOtherPropertiesTypeKey],
      key: [baseOnOtherProperties.key],
      value: [baseOnOtherProperties.value],
    });
  }

  private _createBasedOnOtherPropertiesFormGroup(basedOn: CleaningPluginDetailsBasedOnData): FormGroup {
    let description = (basedOn.otherPropertiesExtended?.length ?? 0) + " properties";

    let fg: FormGroup = this._formBuilder.group({
      id: [this._basedOnIdGenerator],
      name: ["Other properties"],
      description: [description],
      key: ["OTHER_PROPERTIES"],
      otherPropertiesArray: new FormArray(
        basedOn.otherPropertiesExtended ? basedOn.otherPropertiesExtended.map(op => this._createOtherPropertiesExtendedFormGroup(op)) : []
      )
    });

    fg.controls.otherPropertiesArray.valueChanges.subscribe((newValue) => {
      fg.controls.description.setValue((fg.controls.otherPropertiesArray as FormArray).length + " properties");
    });

    return fg;
  }

  private _createBasedOnReservationiSpaceCategoryFormGroup(basedOn: CleaningPluginDetailsBasedOnData): FormGroup {
    let description = "0 categories";
    if (basedOn.reservationSpaceCategories && basedOn.reservationSpaceCategories.length > 0) {
      description = basedOn.reservationSpaceCategories.join(", ");
    }

    let fg: FormGroup = this._formBuilder.group({
      id: [this._basedOnIdGenerator],
      name: ["Reservation space categories"],
      description: [description],
      key: ["RESERVATION_SPACE_CATEGORY"],
      reservationSpaceCategoriesArray: new FormArray(
        basedOn.reservationSpaceCategories ? basedOn.reservationSpaceCategories.map(rsc => this._formBuilder.group({ id: [null], value: [rsc] })) : []
      )
    });

    fg.controls.reservationSpaceCategoriesArray.valueChanges.subscribe((newValue) => {
      let description = (fg.controls.reservationSpaceCategoriesArray as FormArray).controls.map((fg: FormGroup) => { return fg.controls.value.value; }).join(", ");
      if (description === "") {
        fg.controls.description.setValue("0 categories");
      }
      else {
        fg.controls.description.setValue(description);
      }
    });

    return fg;
  }

  private _createBasedOnCleanlinessFormGroup(basedOn: CleaningPluginDetailsBasedOnData): FormGroup {
    let description = "Only dirty rooms";
    let cleanlinessKey = "ONLY_DIRTY";
    if (basedOn.cleanlinessKey === "ONLY_CLEAN") {
      description = "Only clean rooms";
      cleanlinessKey = basedOn.cleanlinessKey;
    }

    let fg: FormGroup = this._formBuilder.group({
      id: [this._basedOnIdGenerator],
      name: ["Cleanliness"],
      description: [description],
      key: ["CLEANLINESS"],
      cleanlinessKey: [cleanlinessKey],
    });

    fg.controls.cleanlinessKey.valueChanges.subscribe(key => {
      fg.controls.description.setValue(key == "ONLY_CLEAN" ? "Only clean rooms" : "Only dirty rooms");
    });

    return fg;
  }

  //private _createBasedOnProductOrTagFormGroup(basedOn: CleaningPluginDetailsBasedOnData): FormGroup {
  //  console.log("BASED ON: ", basedOn);

  //  let description = "0 products/tags";
  //  if (basedOn.productsTags && basedOn.productsTags.length > 0) {
  //    description = basedOn.productsTags.join(", ");
  //  }

  //  let fg: FormGroup = this._formBuilder.group({
  //    id: [this._basedOnIdGenerator],
  //    name: ["Products and tags"],
  //    description: [description],
  //    key: ["PRODUCT_TAG"],

  //    productsTagsMustBeConsumedOnTime: [basedOn.productsTagsMustBeConsumedOnTime ? basedOn.productsTagsMustBeConsumedOnTime : false],
  //    productsTagsConsumationIntervalFrom: [basedOn.productsTagsConsumationIntervalFrom ? basedOn.productsTagsConsumationIntervalFrom : null],
  //    productsTagsConsumationIntervalTo: [basedOn.productsTagsConsumationIntervalTo ? basedOn.productsTagsConsumationIntervalTo : null],
  //    productOrTagArray: new FormArray(
  //      basedOn.productsTags ? basedOn.productsTags.map(pt => this._formBuilder.group({ id: [null], value: [pt] })) : []
  //    )
  //  });

  //  fg.controls.productOrTagArray.valueChanges.subscribe((newValue) => {
  //    let description = (fg.controls.productOrTagArray as FormArray).controls.map((fg: FormGroup) => { return fg.controls.value.value; }).join(", ");
  //    if (description === "") {
  //      fg.controls.description.setValue("0 products/tags");
  //    }
  //    else {
  //      fg.controls.description.setValue(description);
  //    }
  //  });

  //  return fg;
  //}
  private _createBasedOnProductOrTagExtendedFormGroup(basedOn: CleaningPluginDetailsBasedOnData): FormGroup {
    console.log("BASED ON PRODUCTS TAGS EXTENDED: ", basedOn);

    let description = (basedOn.productsTagsExtended ? basedOn.productsTagsExtended.length : 0) + " products/tags";
    //if (basedOn.productsTagsExtended && basedOn.productsTagsExtended.length > 0) {
    //  description = basedOn.productsTagsExtended.map(pte => pte.comparisonValue).join(", ");
    //}

    let fg: FormGroup = this._formBuilder.group({
      id: [this._basedOnIdGenerator],
      name: ["Products and tags"],
      description: [description],
      key: ["PRODUCT_TAG"],

      productsTagsMustBeConsumedOnTime: [basedOn.productsTagsMustBeConsumedOnTime ? basedOn.productsTagsMustBeConsumedOnTime : false],
      productsTagsConsumationIntervalFrom: [basedOn.productsTagsConsumationIntervalFrom ? basedOn.productsTagsConsumationIntervalFrom : null],
      productsTagsConsumationIntervalTo: [basedOn.productsTagsConsumationIntervalTo ? basedOn.productsTagsConsumationIntervalTo : null],
      productOrTagArray: new FormArray(
        basedOn.productsTagsExtended ? basedOn.productsTagsExtended.map(pte => this._createProductOrTagExtendedFormGroup(pte)) : []
      )
    });

    fg.controls.productOrTagArray.valueChanges.subscribe((newValue) => {
      //let description = (fg.controls.productOrTagArray as FormArray).controls.map((fg: FormGroup) => { return fg.controls.value.value; }).join(", ");
      let numberOfProducts = (fg.controls.productOrTagArray as FormArray).length;
      fg.controls.description.setValue(numberOfProducts + " products/tags");
    });

    return fg;
  }

  private _createProductOrTagExtendedFormGroup(productTag: CleaningPluginDetailsBasedOnProdutsTagsExtendedData) {
    return this._formBuilder.group({
      basedOnProductsTagsTypeKey: [productTag.basedOnProductsTagsTypeKey],
      comparisonValue: [productTag.comparisonValue],
      isCaseSensitive: [productTag.isCaseSensitive],
      productId: [productTag.productId],
    });
  }



  private _createBasedOnFloorFormGroup(basedOn: CleaningPluginDetailsBasedOnData): FormGroup {
    let description: string = "0 floors";
    if (basedOn.foorIds) {
      description = basedOn.foorIds.length + " floors";
    }

    let formGroup: FormGroup = this._formBuilder.group({
      id: [this._basedOnIdGenerator],
      name: ["Floors"],
      description: [description],
      numberOfSelectedFloors: [0],
      key: ["FLOOR"],
      buildingsArray: new FormArray(this.hotelHierarchy$.value.buildings.map(b => this._formBuilder.group({
        buildingId: [{ value: b.id, disabled: true }, [Validators.required]],
        buildingName: [{ value: b.name, disabled: true }, [Validators.required]],
        numberOfFloors: [b.floors.length, [Validators.required]],
        floorsArray: new FormArray(b.floors.map(f => {
          let isSelected: boolean = false;
          if (basedOn.foorIds) {
            isSelected = basedOn.foorIds.indexOf(f.id) >= 0;
          }
          let fg: FormGroup = this._formBuilder.group({
            floorId: [{ value: f.id, disabled: true }, [Validators.required]],
            floorName: [{ value: f.name, disabled: true }, [Validators.required]],
            isSelected: [isSelected, [Validators.required]],
          });

          fg.controls.isSelected.valueChanges.subscribe((isSelected: boolean) => {
            if (isSelected) {
              formGroup.controls.numberOfSelectedFloors.setValue(formGroup.controls.numberOfSelectedFloors.value + 1);
              formGroup.controls.description.setValue(formGroup.controls.numberOfSelectedFloors.value + " floors");
            }
            else {
              formGroup.controls.numberOfSelectedFloors.setValue(formGroup.controls.numberOfSelectedFloors.value - 1);
              formGroup.controls.description.setValue(formGroup.controls.numberOfSelectedFloors.value + " floors");
            }
          });

          return fg;
        }

        )),
      })))
    });

    return formGroup;
  }

  private _createBasedOnSectionFormGroup(basedOn: CleaningPluginDetailsBasedOnData): FormGroup {
    let description: string = "0 sections";
    if (basedOn.sections) {
      description = basedOn.sections.length + " sections";
    }

    let formGroup: FormGroup = this._formBuilder.group({
      id: [this._basedOnIdGenerator],
      name: ["Sections"],
      description: [description],
      numberOfSelectedSections: [0],
      key: ["SECTION"],
      buildingsArray: new FormArray(this.hotelHierarchy$.value.buildings.map(b => this._formBuilder.group({
        buildingId: [{ value: b.id, disabled: true }, [Validators.required]],
        buildingName: [{ value: b.name, disabled: true }, [Validators.required]],
        numberOfFloors: [b.floors.length, [Validators.required]],
        floorsArray: new FormArray(b.floors.map(f => this._formBuilder.group({
          floorId: [{ value: f.id, disabled: true }, [Validators.required]],
          floorName: [{ value: f.name, disabled: true }, [Validators.required]],
          numberOfSections: [f.sections.length, [Validators.required]],
          sectionsArray: new FormArray(f.sections.map(s => {
            let isSelected: boolean = false;
            if (basedOn.sections) {
              isSelected = basedOn.sections.indexOf(s.name) >= 0;
            }
            let fg: FormGroup = this._formBuilder.group({
              sectionName: [{ value: s.name, disabled: true }, [Validators.required]],
              isSelected: [isSelected, [Validators.required]],
            });

            fg.controls.isSelected.valueChanges.subscribe((isSelected: boolean) => {
              if (isSelected) {
                formGroup.controls.numberOfSelectedSections.setValue(formGroup.controls.numberOfSelectedSections.value + 1);
                formGroup.controls.description.setValue(formGroup.controls.numberOfSelectedSections.value + " sections");
              }
              else {
                formGroup.controls.numberOfSelectedSections.setValue(formGroup.controls.numberOfSelectedSections.value - 1);
                formGroup.controls.description.setValue(formGroup.controls.numberOfSelectedSections.value + " sections");
              }
            });

            return fg;
          }))
        }))),
      })))
    });

    return formGroup;
  }

  private _createBasedOnSubSectionFormGroup(basedOn: CleaningPluginDetailsBasedOnData): FormGroup {
    let description: string = "0 sub sections";
    if (basedOn.subSections) {
      description = basedOn.subSections.length + " sub sections";
    }

    let formGroup: FormGroup = this._formBuilder.group({
      id: [this._basedOnIdGenerator],
      name: ["Sub sections"],
      description: [description],
      numberOfSelectedSubSections: [0],
      key: ["SUB_SECTION"],
      buildingsArray: new FormArray(this.hotelHierarchy$.value.buildings.map(b => this._formBuilder.group({
        buildingId: [{ value: b.id, disabled: true }, [Validators.required]],
        buildingName: [{ value: b.name, disabled: true }, [Validators.required]],
        numberOfFloors: [b.floors.length, [Validators.required]],
        floorsArray: new FormArray(b.floors.map(f => this._formBuilder.group({
          floorId: [{ value: f.id, disabled: true }, [Validators.required]],
          floorName: [{ value: f.name, disabled: true }, [Validators.required]],
          numberOfSections: [f.sections.length, [Validators.required]],
          sectionsArray: new FormArray(f.sections.map(s => this._formBuilder.group({
            sectionName: [{ value: s.name, disabled: true }, [Validators.required]],
            numberOfSubSections: [s.subSections.length, [Validators.required]],
            subSectionsArray: new FormArray(s.subSections.map(ss => {
              let isSelected: boolean = false;
              if (basedOn.subSections) {
                isSelected = basedOn.subSections.indexOf(ss.name) >= 0;
              }
              let fg: FormGroup = this._formBuilder.group({
                subSectionName: [{ value: ss.name, disabled: true }, [Validators.required]],
                isSelected: [isSelected, [Validators.required]],
              });

              fg.controls.isSelected.valueChanges.subscribe((isSelected: boolean) => {
                if (isSelected) {
                  formGroup.controls.numberOfSelectedSubSections.setValue(formGroup.controls.numberOfSelectedSubSections.value + 1);
                  formGroup.controls.description.setValue(formGroup.controls.numberOfSelectedSubSections.value + " sub sections");
                }
                else {
                  formGroup.controls.numberOfSelectedSubSections.setValue(formGroup.controls.numberOfSelectedSubSections.value - 1);
                  formGroup.controls.description.setValue(formGroup.controls.numberOfSelectedSubSections.value + " sub sections");
                }
              });

              return fg;
            }
            ))
          })))
        }))),
      })))
    });

    return formGroup;
  }



  ngOnDestroy(): void {
  }

  selectBasedOn(basedOnFormGroup: FormGroup) {
    console.log("SELECTED BASED ON: ", basedOnFormGroup);

    //this.selectedBasedOn$.next(basedOn);
    this.selectedBasedOnFormGroup$.next(basedOnFormGroup);
  }

  deleteSelectedBasedOn(event, basedOnIndex) {
    event.stopPropagation();

    let basedOnsFormArray: FormArray = this.pluginDetailsForm.controls.basedOnsFormArray as FormArray;
    basedOnsFormArray.removeAt(basedOnIndex);
  }

  toggleWeekBasedCleaningWeek(weekIndex: number) {
    let weekFormGroup: FormGroup = this.weekBasedCleaningTypeWeeksArray.at(weekIndex) as FormGroup;
    weekFormGroup.controls.isSelected.setValue(!weekFormGroup.controls.isSelected.value);
  }


  private _selectCleaningPluginType() {

  }
}
