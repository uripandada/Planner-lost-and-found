/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.10.8.0 (NJsonSchema v10.3.11.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';
import 'moment-duration-format';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable({
    providedIn: 'root'
})
export class AccountClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    login(request: MasterLoginQuery): Observable<ProcessResponseOfMasterLoginModel> {
        let url_ = this.baseUrl + "/api/Account/Login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(<any>response_);
                } catch (e) {
                    return <Observable<ProcessResponseOfMasterLoginModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProcessResponseOfMasterLoginModel>><any>_observableThrow(response_);
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<ProcessResponseOfMasterLoginModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProcessResponseOfMasterLoginModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProcessResponseOfMasterLoginModel>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class AutomaticHousekeepingUpdatesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getListOfAutomaticHousekeepingUpdateSettings(request: GetListOfAutomaticHousekeepingUpdateSettingsQuery): Observable<AutomaticHousekeepingUpdateSettingsListItem[]> {
        let url_ = this.baseUrl + "/api/AutomaticHousekeepingUpdates/GetListOfAutomaticHousekeepingUpdateSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListOfAutomaticHousekeepingUpdateSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListOfAutomaticHousekeepingUpdateSettings(<any>response_);
                } catch (e) {
                    return <Observable<AutomaticHousekeepingUpdateSettingsListItem[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AutomaticHousekeepingUpdateSettingsListItem[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetListOfAutomaticHousekeepingUpdateSettings(response: HttpResponseBase): Observable<AutomaticHousekeepingUpdateSettingsListItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AutomaticHousekeepingUpdateSettingsListItem.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AutomaticHousekeepingUpdateSettingsListItem[]>(<any>null);
    }

    insertAutomaticHousekeepingUpdateSettings(request: InsertAutomaticHousekeepingUpdateSettingsCommand): Observable<ProcessResponseOfGuid> {
        let url_ = this.baseUrl + "/api/AutomaticHousekeepingUpdates/InsertAutomaticHousekeepingUpdateSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertAutomaticHousekeepingUpdateSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertAutomaticHousekeepingUpdateSettings(<any>response_);
                } catch (e) {
                    return <Observable<ProcessResponseOfGuid>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProcessResponseOfGuid>><any>_observableThrow(response_);
        }));
    }

    protected processInsertAutomaticHousekeepingUpdateSettings(response: HttpResponseBase): Observable<ProcessResponseOfGuid> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProcessResponseOfGuid.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProcessResponseOfGuid>(<any>null);
    }

    updateAutomaticHousekeepingUpdateSettings(request: UpdateAutomaticHousekeepingUpdateSettingsCommand): Observable<ProcessResponse> {
        let url_ = this.baseUrl + "/api/AutomaticHousekeepingUpdates/UpdateAutomaticHousekeepingUpdateSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAutomaticHousekeepingUpdateSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAutomaticHousekeepingUpdateSettings(<any>response_);
                } catch (e) {
                    return <Observable<ProcessResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProcessResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAutomaticHousekeepingUpdateSettings(response: HttpResponseBase): Observable<ProcessResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProcessResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProcessResponse>(<any>null);
    }

    deleteAutomaticHousekeepingUpdateSettings(request: DeleteAutomaticHousekeepingUpdateSettingsCommand): Observable<ProcessResponse> {
        let url_ = this.baseUrl + "/api/AutomaticHousekeepingUpdates/DeleteAutomaticHousekeepingUpdateSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAutomaticHousekeepingUpdateSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAutomaticHousekeepingUpdateSettings(<any>response_);
                } catch (e) {
                    return <Observable<ProcessResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProcessResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAutomaticHousekeepingUpdateSettings(response: HttpResponseBase): Observable<ProcessResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProcessResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProcessResponse>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class CleaningCalendarClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getWeeklyCleaningCalendar(request: GetWeeklyCleaningCalendarQuery): Observable<CleaningCalendarIntervalResult> {
        let url_ = this.baseUrl + "/api/CleaningCalendar/GetWeeklyCleaningCalendar";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWeeklyCleaningCalendar(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWeeklyCleaningCalendar(<any>response_);
                } catch (e) {
                    return <Observable<CleaningCalendarIntervalResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CleaningCalendarIntervalResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetWeeklyCleaningCalendar(response: HttpResponseBase): Observable<CleaningCalendarIntervalResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CleaningCalendarIntervalResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CleaningCalendarIntervalResult>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class CleaningPluginsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getCleaningPluginsConfiguration(request: GetCleaningPluginsConfigurationDataQuery): Observable<CleaningPluginsConfigurationData> {
        let url_ = this.baseUrl + "/api/CleaningPlugins/GetCleaningPluginsConfiguration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCleaningPluginsConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCleaningPluginsConfiguration(<any>response_);
                } catch (e) {
                    return <Observable<CleaningPluginsConfigurationData>><any>_observableThrow(e);
                }
            } else
                return <Observable<CleaningPluginsConfigurationData>><any>_observableThrow(response_);
        }));
    }

    protected processGetCleaningPluginsConfiguration(response: HttpResponseBase): Observable<CleaningPluginsConfigurationData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CleaningPluginsConfigurationData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CleaningPluginsConfigurationData>(<any>null);
    }

    getHotelCleaningPlugins(request: GetHotelCleaningPluginsQuery): Observable<CleaningPluginGridData[]> {
        let url_ = this.baseUrl + "/api/CleaningPlugins/GetHotelCleaningPlugins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHotelCleaningPlugins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHotelCleaningPlugins(<any>response_);
                } catch (e) {
                    return <Observable<CleaningPluginGridData[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CleaningPluginGridData[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetHotelCleaningPlugins(response: HttpResponseBase): Observable<CleaningPluginGridData[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CleaningPluginGridData.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CleaningPluginGridData[]>(<any>null);
    }

    getCleaningPluginDetails(request: GetCleaningPluginDetailsQuery): Observable<CleaningPluginDetailsData> {
        let url_ = this.baseUrl + "/api/CleaningPlugins/GetCleaningPluginDetails";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCleaningPluginDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCleaningPluginDetails(<any>response_);
                } catch (e) {
                    return <Observable<CleaningPluginDetailsData>><any>_observableThrow(e);
                }
            } else
                return <Observable<CleaningPluginDetailsData>><any>_observableThrow(response_);
        }));
    }

    protected processGetCleaningPluginDetails(response: HttpResponseBase): Observable<CleaningPluginDetailsData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CleaningPluginDetailsData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CleaningPluginDetailsData>(<any>null);
    }

    insertCleaningPlugin(request: InsertCleaningPluginCommand): Observable<ProcessResponseOfGuid> {
        let url_ = this.baseUrl + "/api/CleaningPlugins/InsertCleaningPlugin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertCleaningPlugin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertCleaningPlugin(<any>response_);
                } catch (e) {
                    return <Observable<ProcessResponseOfGuid>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProcessResponseOfGuid>><any>_observableThrow(response_);
        }));
    }

    protected processInsertCleaningPlugin(response: HttpResponseBase): Observable<ProcessResponseOfGuid> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProcessResponseOfGuid.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProcessResponseOfGuid>(<any>null);
    }

    updateCleaningPlugin(request: UpdateCleaningPluginCommand): Observable<ProcessResponse> {
        let url_ = this.baseUrl + "/api/CleaningPlugins/UpdateCleaningPlugin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCleaningPlugin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCleaningPlugin(<any>response_);
                } catch (e) {
                    return <Observable<ProcessResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProcessResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCleaningPlugin(response: HttpResponseBase): Observable<ProcessResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProcessResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProcessResponse>(<any>null);
    }

    deleteCleaningPlugin(request: DeleteCleaningPluginCommand): Observable<ProcessResponse> {
        let url_ = this.baseUrl + "/api/CleaningPlugins/DeleteCleaningPlugin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCleaningPlugin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCleaningPlugin(<any>response_);
                } catch (e) {
                    return <Observable<ProcessResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProcessResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteCleaningPlugin(response: HttpResponseBase): Observable<ProcessResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProcessResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProcessResponse>(<any>null);
    }

    updatePluginOrder(request: UpdatePluginOrderCommand): Observable<ProcessResponse> {
        let url_ = this.baseUrl + "/api/CleaningPlugins/UpdatePluginOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePluginOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePluginOrder(<any>response_);
                } catch (e) {
                    return <Observable<ProcessResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProcessResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePluginOrder(response: HttpResponseBase): Observable<ProcessResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProcessResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProcessResponse>(<any>null);
    }

    getCleaningPluginTests(request: PredictionsTesterRequest): Observable<PredictionsTesterResult> {
        let url_ = this.baseUrl + "/api/CleaningPlugins/GetCleaningPluginTests";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCleaningPluginTests(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCleaningPluginTests(<any>response_);
                } catch (e) {
                    return <Observable<PredictionsTesterResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<PredictionsTesterResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetCleaningPluginTests(response: HttpResponseBase): Observable<PredictionsTesterResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PredictionsTesterResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PredictionsTesterResult>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class HotelClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getHotels(query: GetHotelsQuery): Observable<HotelGridData[]> {
        let url_ = this.baseUrl + "/api/Hotel/GetHotels";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHotels(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHotels(<any>response_);
                } catch (e) {
                    return <Observable<HotelGridData[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<HotelGridData[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetHotels(response: HttpResponseBase): Observable<HotelGridData[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(HotelGridData.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HotelGridData[]>(<any>null);
    }

    getHotelRoomCategories(query: GetHotelRoomCategoriesQuery): Observable<HotelRoomCategoryData[]> {
        let url_ = this.baseUrl + "/api/Hotel/GetHotelRoomCategories";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHotelRoomCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHotelRoomCategories(<any>response_);
                } catch (e) {
                    return <Observable<HotelRoomCategoryData[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<HotelRoomCategoryData[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetHotelRoomCategories(response: HttpResponseBase): Observable<HotelRoomCategoryData[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(HotelRoomCategoryData.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HotelRoomCategoryData[]>(<any>null);
    }

    getHotelHierarchy(query: GetHotelHierarchyQuery): Observable<HotelHierarchyData> {
        let url_ = this.baseUrl + "/api/Hotel/GetHotelHierarchy";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHotelHierarchy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHotelHierarchy(<any>response_);
                } catch (e) {
                    return <Observable<HotelHierarchyData>><any>_observableThrow(e);
                }
            } else
                return <Observable<HotelHierarchyData>><any>_observableThrow(response_);
        }));
    }

    protected processGetHotelHierarchy(response: HttpResponseBase): Observable<HotelHierarchyData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HotelHierarchyData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HotelHierarchyData>(<any>null);
    }

    getHotelRooms(query: GetHotelRoomsQuery): Observable<HotelRoomData[]> {
        let url_ = this.baseUrl + "/api/Hotel/GetHotelRooms";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHotelRooms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHotelRooms(<any>response_);
                } catch (e) {
                    return <Observable<HotelRoomData[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<HotelRoomData[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetHotelRooms(response: HttpResponseBase): Observable<HotelRoomData[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(HotelRoomData.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HotelRoomData[]>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class HotelGroupClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getHotelGroupDetails(query: GetHotelGroupDetailsQuery): Observable<HotelGroupDetailsData> {
        let url_ = this.baseUrl + "/api/HotelGroup/GetHotelGroupDetails";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHotelGroupDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHotelGroupDetails(<any>response_);
                } catch (e) {
                    return <Observable<HotelGroupDetailsData>><any>_observableThrow(e);
                }
            } else
                return <Observable<HotelGroupDetailsData>><any>_observableThrow(response_);
        }));
    }

    protected processGetHotelGroupDetails(response: HttpResponseBase): Observable<HotelGroupDetailsData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HotelGroupDetailsData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HotelGroupDetailsData>(<any>null);
    }

    getHotelGroups(query: GetHotelGroupsQuery): Observable<HotelGroupGridData[]> {
        let url_ = this.baseUrl + "/api/HotelGroup/GetHotelGroups";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHotelGroups(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHotelGroups(<any>response_);
                } catch (e) {
                    return <Observable<HotelGroupGridData[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<HotelGroupGridData[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetHotelGroups(response: HttpResponseBase): Observable<HotelGroupGridData[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(HotelGroupGridData.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HotelGroupGridData[]>(<any>null);
    }

    getPageOfHotelGroupAssets(query: GetPageOfHotelGroupAssetsQuery): Observable<PageOfOfHotelGroupAssetData> {
        let url_ = this.baseUrl + "/api/HotelGroup/GetPageOfHotelGroupAssets";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPageOfHotelGroupAssets(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPageOfHotelGroupAssets(<any>response_);
                } catch (e) {
                    return <Observable<PageOfOfHotelGroupAssetData>><any>_observableThrow(e);
                }
            } else
                return <Observable<PageOfOfHotelGroupAssetData>><any>_observableThrow(response_);
        }));
    }

    protected processGetPageOfHotelGroupAssets(response: HttpResponseBase): Observable<PageOfOfHotelGroupAssetData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageOfOfHotelGroupAssetData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PageOfOfHotelGroupAssetData>(<any>null);
    }

    getPageOfHotelGroupHotelReservations(query: GetPageOfHotelGroupHotelReservationsQuery): Observable<PageOfOfHotelGroupHotelReservationData> {
        let url_ = this.baseUrl + "/api/HotelGroup/GetPageOfHotelGroupHotelReservations";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPageOfHotelGroupHotelReservations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPageOfHotelGroupHotelReservations(<any>response_);
                } catch (e) {
                    return <Observable<PageOfOfHotelGroupHotelReservationData>><any>_observableThrow(e);
                }
            } else
                return <Observable<PageOfOfHotelGroupHotelReservationData>><any>_observableThrow(response_);
        }));
    }

    protected processGetPageOfHotelGroupHotelReservations(response: HttpResponseBase): Observable<PageOfOfHotelGroupHotelReservationData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageOfOfHotelGroupHotelReservationData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PageOfOfHotelGroupHotelReservationData>(<any>null);
    }

    getPageOfHotelGroupHotelRooms(query: GetPageOfHotelGroupHotelRoomsQuery): Observable<PageOfOfHotelGroupHotelRoomsData> {
        let url_ = this.baseUrl + "/api/HotelGroup/GetPageOfHotelGroupHotelRooms";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPageOfHotelGroupHotelRooms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPageOfHotelGroupHotelRooms(<any>response_);
                } catch (e) {
                    return <Observable<PageOfOfHotelGroupHotelRoomsData>><any>_observableThrow(e);
                }
            } else
                return <Observable<PageOfOfHotelGroupHotelRoomsData>><any>_observableThrow(response_);
        }));
    }

    protected processGetPageOfHotelGroupHotelRooms(response: HttpResponseBase): Observable<PageOfOfHotelGroupHotelRoomsData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageOfOfHotelGroupHotelRoomsData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PageOfOfHotelGroupHotelRoomsData>(<any>null);
    }

    getPageOfHotelGroupHotels(query: GetPageOfHotelGroupHotelsQuery): Observable<PageOfOfHotelGroupHotelData> {
        let url_ = this.baseUrl + "/api/HotelGroup/GetPageOfHotelGroupHotels";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPageOfHotelGroupHotels(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPageOfHotelGroupHotels(<any>response_);
                } catch (e) {
                    return <Observable<PageOfOfHotelGroupHotelData>><any>_observableThrow(e);
                }
            } else
                return <Observable<PageOfOfHotelGroupHotelData>><any>_observableThrow(response_);
        }));
    }

    protected processGetPageOfHotelGroupHotels(response: HttpResponseBase): Observable<PageOfOfHotelGroupHotelData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageOfOfHotelGroupHotelData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PageOfOfHotelGroupHotelData>(<any>null);
    }

    getPageOfHotelGroups(query: GetPageOfHotelGroupsQuery): Observable<PageOfOfHotelGroupData> {
        let url_ = this.baseUrl + "/api/HotelGroup/GetPageOfHotelGroups";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPageOfHotelGroups(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPageOfHotelGroups(<any>response_);
                } catch (e) {
                    return <Observable<PageOfOfHotelGroupData>><any>_observableThrow(e);
                }
            } else
                return <Observable<PageOfOfHotelGroupData>><any>_observableThrow(response_);
        }));
    }

    protected processGetPageOfHotelGroups(response: HttpResponseBase): Observable<PageOfOfHotelGroupData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageOfOfHotelGroupData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PageOfOfHotelGroupData>(<any>null);
    }

    getPageOfHotelGroupUsers(query: GetPageOfHotelGroupUsersQuery): Observable<PageOfOfHotelGroupUserData> {
        let url_ = this.baseUrl + "/api/HotelGroup/GetPageOfHotelGroupUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPageOfHotelGroupUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPageOfHotelGroupUsers(<any>response_);
                } catch (e) {
                    return <Observable<PageOfOfHotelGroupUserData>><any>_observableThrow(e);
                }
            } else
                return <Observable<PageOfOfHotelGroupUserData>><any>_observableThrow(response_);
        }));
    }

    protected processGetPageOfHotelGroupUsers(response: HttpResponseBase): Observable<PageOfOfHotelGroupUserData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageOfOfHotelGroupUserData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PageOfOfHotelGroupUserData>(<any>null);
    }

    deleteHotelGroup(command: DeleteHotelGroupCommand): Observable<ProcessResponse> {
        let url_ = this.baseUrl + "/api/HotelGroup/DeleteHotelGroup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteHotelGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteHotelGroup(<any>response_);
                } catch (e) {
                    return <Observable<ProcessResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProcessResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteHotelGroup(response: HttpResponseBase): Observable<ProcessResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProcessResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProcessResponse>(<any>null);
    }

    deleteHotelGroupHotel(command: DeleteHotelGroupHotelCommand): Observable<ProcessResponse> {
        let url_ = this.baseUrl + "/api/HotelGroup/DeleteHotelGroupHotel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteHotelGroupHotel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteHotelGroupHotel(<any>response_);
                } catch (e) {
                    return <Observable<ProcessResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProcessResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteHotelGroupHotel(response: HttpResponseBase): Observable<ProcessResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProcessResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProcessResponse>(<any>null);
    }

    insertHotelGroup(command: InsertHotelGroupCommand): Observable<ProcessResponseOfGuid> {
        let url_ = this.baseUrl + "/api/HotelGroup/InsertHotelGroup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertHotelGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertHotelGroup(<any>response_);
                } catch (e) {
                    return <Observable<ProcessResponseOfGuid>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProcessResponseOfGuid>><any>_observableThrow(response_);
        }));
    }

    protected processInsertHotelGroup(response: HttpResponseBase): Observable<ProcessResponseOfGuid> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProcessResponseOfGuid.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProcessResponseOfGuid>(<any>null);
    }

    insertHotelGroupHotel(command: InsertHotelGroupHotelCommand): Observable<ProcessResponse> {
        let url_ = this.baseUrl + "/api/HotelGroup/InsertHotelGroupHotel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertHotelGroupHotel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertHotelGroupHotel(<any>response_);
                } catch (e) {
                    return <Observable<ProcessResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProcessResponse>><any>_observableThrow(response_);
        }));
    }

    protected processInsertHotelGroupHotel(response: HttpResponseBase): Observable<ProcessResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProcessResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProcessResponse>(<any>null);
    }

    updateHotelGroup(command: UpdateHotelGroupCommand): Observable<ProcessResponse> {
        let url_ = this.baseUrl + "/api/HotelGroup/UpdateHotelGroup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateHotelGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateHotelGroup(<any>response_);
                } catch (e) {
                    return <Observable<ProcessResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProcessResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateHotelGroup(response: HttpResponseBase): Observable<ProcessResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProcessResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProcessResponse>(<any>null);
    }

    updateHotelGroupHotel(command: UpdateHotelGroupHotelCommand): Observable<ProcessResponse> {
        let url_ = this.baseUrl + "/api/HotelGroup/UpdateHotelGroupHotel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateHotelGroupHotel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateHotelGroupHotel(<any>response_);
                } catch (e) {
                    return <Observable<ProcessResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProcessResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateHotelGroupHotel(response: HttpResponseBase): Observable<ProcessResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProcessResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProcessResponse>(<any>null);
    }

    getListOfWindowsTimeZones(request: GetListOfWindowsTimeZonesQuery): Observable<TimeZoneData[]> {
        let url_ = this.baseUrl + "/api/HotelGroup/GetListOfWindowsTimeZones";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListOfWindowsTimeZones(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListOfWindowsTimeZones(<any>response_);
                } catch (e) {
                    return <Observable<TimeZoneData[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TimeZoneData[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetListOfWindowsTimeZones(response: HttpResponseBase): Observable<TimeZoneData[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TimeZoneData.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TimeZoneData[]>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class OidcConfigurationClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getClientRequestParameters(clientId: string | null): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/_configuration/{clientId}";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClientRequestParameters(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClientRequestParameters(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetClientRequestParameters(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ProductClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getListOfProducts(request: GetListOfProductsQuery): Observable<ProductListItem[]> {
        let url_ = this.baseUrl + "/api/Product/GetListOfProducts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListOfProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListOfProducts(<any>response_);
                } catch (e) {
                    return <Observable<ProductListItem[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductListItem[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetListOfProducts(response: HttpResponseBase): Observable<ProductListItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductListItem.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductListItem[]>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class UserManagementClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getUserById(id: string | undefined): Observable<ProcessResponseOfMasterUserModel> {
        let url_ = this.baseUrl + "/api/UserManagement/GetUserById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserById(<any>response_);
                } catch (e) {
                    return <Observable<ProcessResponseOfMasterUserModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProcessResponseOfMasterUserModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserById(response: HttpResponseBase): Observable<ProcessResponseOfMasterUserModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProcessResponseOfMasterUserModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProcessResponseOfMasterUserModel>(<any>null);
    }

    getUserDetails(query: GetUserDetailsQuery): Observable<UserDetailsData> {
        let url_ = this.baseUrl + "/api/UserManagement/GetUserDetails";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserDetails(<any>response_);
                } catch (e) {
                    return <Observable<UserDetailsData>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDetailsData>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserDetails(response: HttpResponseBase): Observable<UserDetailsData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDetailsData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDetailsData>(<any>null);
    }

    getPageOfUsers(query: GetPageOfUsersQuery): Observable<PageOfOfUserGridData> {
        let url_ = this.baseUrl + "/api/UserManagement/GetPageOfUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPageOfUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPageOfUsers(<any>response_);
                } catch (e) {
                    return <Observable<PageOfOfUserGridData>><any>_observableThrow(e);
                }
            } else
                return <Observable<PageOfOfUserGridData>><any>_observableThrow(response_);
        }));
    }

    protected processGetPageOfUsers(response: HttpResponseBase): Observable<PageOfOfUserGridData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageOfOfUserGridData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PageOfOfUserGridData>(<any>null);
    }

    insertUser(query: InsertUserCommand): Observable<ProcessResponseOfGuid> {
        let url_ = this.baseUrl + "/api/UserManagement/InsertUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertUser(<any>response_);
                } catch (e) {
                    return <Observable<ProcessResponseOfGuid>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProcessResponseOfGuid>><any>_observableThrow(response_);
        }));
    }

    protected processInsertUser(response: HttpResponseBase): Observable<ProcessResponseOfGuid> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProcessResponseOfGuid.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProcessResponseOfGuid>(<any>null);
    }

    updateUser(query: UpdateUserCommand): Observable<ProcessResponse> {
        let url_ = this.baseUrl + "/api/UserManagement/UpdateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUser(<any>response_);
                } catch (e) {
                    return <Observable<ProcessResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProcessResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUser(response: HttpResponseBase): Observable<ProcessResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProcessResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProcessResponse>(<any>null);
    }

    deactivateUser(query: DeactivateUserCommand): Observable<ProcessResponse> {
        let url_ = this.baseUrl + "/api/UserManagement/DeactivateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeactivateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeactivateUser(<any>response_);
                } catch (e) {
                    return <Observable<ProcessResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProcessResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDeactivateUser(response: HttpResponseBase): Observable<ProcessResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProcessResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProcessResponse>(<any>null);
    }
}

export class ProcessResponse implements IProcessResponse {
    isSuccess!: boolean;
    hasError!: boolean;
    message?: string | null;
    modelErrors?: ErrorData[] | null;

    constructor(data?: IProcessResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"] !== undefined ? _data["isSuccess"] : <any>null;
            this.hasError = _data["hasError"] !== undefined ? _data["hasError"] : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            if (Array.isArray(_data["modelErrors"])) {
                this.modelErrors = [] as any;
                for (let item of _data["modelErrors"])
                    this.modelErrors!.push(ErrorData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProcessResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess !== undefined ? this.isSuccess : <any>null;
        data["hasError"] = this.hasError !== undefined ? this.hasError : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        if (Array.isArray(this.modelErrors)) {
            data["modelErrors"] = [];
            for (let item of this.modelErrors)
                data["modelErrors"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IProcessResponse {
    isSuccess: boolean;
    hasError: boolean;
    message?: string | null;
    modelErrors?: ErrorData[] | null;
}

export class ProcessResponseOfMasterLoginModel extends ProcessResponse implements IProcessResponseOfMasterLoginModel {
    data?: MasterLoginModel | null;

    constructor(data?: IProcessResponseOfMasterLoginModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.data = _data["data"] ? MasterLoginModel.fromJS(_data["data"]) : <any>null;
        }
    }

    static fromJS(data: any): ProcessResponseOfMasterLoginModel {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessResponseOfMasterLoginModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        super.toJSON(data);
        return data; 
    }
}

export interface IProcessResponseOfMasterLoginModel extends IProcessResponse {
    data?: MasterLoginModel | null;
}

export class MasterLoginModel implements IMasterLoginModel {
    cookieOptions?: CookieOptions | null;

    constructor(data?: IMasterLoginModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cookieOptions = _data["cookieOptions"] ? CookieOptions.fromJS(_data["cookieOptions"]) : <any>null;
        }
    }

    static fromJS(data: any): MasterLoginModel {
        data = typeof data === 'object' ? data : {};
        let result = new MasterLoginModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cookieOptions"] = this.cookieOptions ? this.cookieOptions.toJSON() : <any>null;
        return data; 
    }
}

export interface IMasterLoginModel {
    cookieOptions?: CookieOptions | null;
}

export class CookieOptions implements ICookieOptions {
    domain?: string | null;
    path?: string | null;
    expires?: moment.Moment | null;
    secure!: boolean;
    sameSite!: SameSiteMode;
    httpOnly!: boolean;
    maxAge?: moment.Duration | null;
    isEssential!: boolean;

    constructor(data?: ICookieOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.domain = _data["domain"] !== undefined ? _data["domain"] : <any>null;
            this.path = _data["path"] !== undefined ? _data["path"] : <any>null;
            this.expires = _data["expires"] ? moment(_data["expires"].toString()) : <any>null;
            this.secure = _data["secure"] !== undefined ? _data["secure"] : <any>null;
            this.sameSite = _data["sameSite"] !== undefined ? _data["sameSite"] : <any>null;
            this.httpOnly = _data["httpOnly"] !== undefined ? _data["httpOnly"] : <any>null;
            this.maxAge = _data["maxAge"] ? moment.duration(_data["maxAge"].toString()) : <any>null;
            this.isEssential = _data["isEssential"] !== undefined ? _data["isEssential"] : <any>null;
        }
    }

    static fromJS(data: any): CookieOptions {
        data = typeof data === 'object' ? data : {};
        let result = new CookieOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["domain"] = this.domain !== undefined ? this.domain : <any>null;
        data["path"] = this.path !== undefined ? this.path : <any>null;
        data["expires"] = this.expires ? this.expires.toISOString() : <any>null;
        data["secure"] = this.secure !== undefined ? this.secure : <any>null;
        data["sameSite"] = this.sameSite !== undefined ? this.sameSite : <any>null;
        data["httpOnly"] = this.httpOnly !== undefined ? this.httpOnly : <any>null;
        data["maxAge"] = this.maxAge ? this.maxAge.format('d.hh:mm:ss.SS', { trim: false }) : <any>null;
        data["isEssential"] = this.isEssential !== undefined ? this.isEssential : <any>null;
        return data; 
    }
}

export interface ICookieOptions {
    domain?: string | null;
    path?: string | null;
    expires?: moment.Moment | null;
    secure: boolean;
    sameSite: SameSiteMode;
    httpOnly: boolean;
    maxAge?: moment.Duration | null;
    isEssential: boolean;
}

export enum SameSiteMode {
    None = 0,
    Lax = 1,
    Strict = 2,
    Unspecified = -1,
}

export class ErrorData implements IErrorData {
    key?: string | null;
    validatorKey?: string | null;

    constructor(data?: IErrorData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"] !== undefined ? _data["key"] : <any>null;
            this.validatorKey = _data["validatorKey"] !== undefined ? _data["validatorKey"] : <any>null;
        }
    }

    static fromJS(data: any): ErrorData {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key !== undefined ? this.key : <any>null;
        data["validatorKey"] = this.validatorKey !== undefined ? this.validatorKey : <any>null;
        return data; 
    }
}

export interface IErrorData {
    key?: string | null;
    validatorKey?: string | null;
}

export class MasterLoginQuery implements IMasterLoginQuery {
    username?: string | null;
    password?: string | null;
    rememberMe!: boolean;

    constructor(data?: IMasterLoginQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"] !== undefined ? _data["username"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
            this.rememberMe = _data["rememberMe"] !== undefined ? _data["rememberMe"] : <any>null;
        }
    }

    static fromJS(data: any): MasterLoginQuery {
        data = typeof data === 'object' ? data : {};
        let result = new MasterLoginQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username !== undefined ? this.username : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        data["rememberMe"] = this.rememberMe !== undefined ? this.rememberMe : <any>null;
        return data; 
    }
}

export interface IMasterLoginQuery {
    username?: string | null;
    password?: string | null;
    rememberMe: boolean;
}

export class AutomaticHousekeepingUpdateSettingsListItem implements IAutomaticHousekeepingUpdateSettingsListItem {
    id!: string;
    dirty!: boolean;
    clean!: boolean;
    cleanNeedsInspection!: boolean;
    inspected!: boolean;
    vacant!: boolean;
    occupied!: boolean;
    doNotDisturb!: boolean;
    doDisturb!: boolean;
    outOfService!: boolean;
    inService!: boolean;
    roomNameRegex?: string | null;
    updateStatusTo!: AutomaticHousekeepingUpdateCleaningStatusTo;
    updateStatusWhen!: AutomaticHousekeepingUpdateCleaningStatusWhen;
    updateStatusAtTime?: string | null;

    constructor(data?: IAutomaticHousekeepingUpdateSettingsListItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.dirty = _data["dirty"] !== undefined ? _data["dirty"] : <any>null;
            this.clean = _data["clean"] !== undefined ? _data["clean"] : <any>null;
            this.cleanNeedsInspection = _data["cleanNeedsInspection"] !== undefined ? _data["cleanNeedsInspection"] : <any>null;
            this.inspected = _data["inspected"] !== undefined ? _data["inspected"] : <any>null;
            this.vacant = _data["vacant"] !== undefined ? _data["vacant"] : <any>null;
            this.occupied = _data["occupied"] !== undefined ? _data["occupied"] : <any>null;
            this.doNotDisturb = _data["doNotDisturb"] !== undefined ? _data["doNotDisturb"] : <any>null;
            this.doDisturb = _data["doDisturb"] !== undefined ? _data["doDisturb"] : <any>null;
            this.outOfService = _data["outOfService"] !== undefined ? _data["outOfService"] : <any>null;
            this.inService = _data["inService"] !== undefined ? _data["inService"] : <any>null;
            this.roomNameRegex = _data["roomNameRegex"] !== undefined ? _data["roomNameRegex"] : <any>null;
            this.updateStatusTo = _data["updateStatusTo"] !== undefined ? _data["updateStatusTo"] : <any>null;
            this.updateStatusWhen = _data["updateStatusWhen"] !== undefined ? _data["updateStatusWhen"] : <any>null;
            this.updateStatusAtTime = _data["updateStatusAtTime"] !== undefined ? _data["updateStatusAtTime"] : <any>null;
        }
    }

    static fromJS(data: any): AutomaticHousekeepingUpdateSettingsListItem {
        data = typeof data === 'object' ? data : {};
        let result = new AutomaticHousekeepingUpdateSettingsListItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["dirty"] = this.dirty !== undefined ? this.dirty : <any>null;
        data["clean"] = this.clean !== undefined ? this.clean : <any>null;
        data["cleanNeedsInspection"] = this.cleanNeedsInspection !== undefined ? this.cleanNeedsInspection : <any>null;
        data["inspected"] = this.inspected !== undefined ? this.inspected : <any>null;
        data["vacant"] = this.vacant !== undefined ? this.vacant : <any>null;
        data["occupied"] = this.occupied !== undefined ? this.occupied : <any>null;
        data["doNotDisturb"] = this.doNotDisturb !== undefined ? this.doNotDisturb : <any>null;
        data["doDisturb"] = this.doDisturb !== undefined ? this.doDisturb : <any>null;
        data["outOfService"] = this.outOfService !== undefined ? this.outOfService : <any>null;
        data["inService"] = this.inService !== undefined ? this.inService : <any>null;
        data["roomNameRegex"] = this.roomNameRegex !== undefined ? this.roomNameRegex : <any>null;
        data["updateStatusTo"] = this.updateStatusTo !== undefined ? this.updateStatusTo : <any>null;
        data["updateStatusWhen"] = this.updateStatusWhen !== undefined ? this.updateStatusWhen : <any>null;
        data["updateStatusAtTime"] = this.updateStatusAtTime !== undefined ? this.updateStatusAtTime : <any>null;
        return data; 
    }
}

export interface IAutomaticHousekeepingUpdateSettingsListItem {
    id: string;
    dirty: boolean;
    clean: boolean;
    cleanNeedsInspection: boolean;
    inspected: boolean;
    vacant: boolean;
    occupied: boolean;
    doNotDisturb: boolean;
    doDisturb: boolean;
    outOfService: boolean;
    inService: boolean;
    roomNameRegex?: string | null;
    updateStatusTo: AutomaticHousekeepingUpdateCleaningStatusTo;
    updateStatusWhen: AutomaticHousekeepingUpdateCleaningStatusWhen;
    updateStatusAtTime?: string | null;
}

export enum AutomaticHousekeepingUpdateCleaningStatusTo {
    CLEAN = 0,
    DIRTY = 1,
}

export enum AutomaticHousekeepingUpdateCleaningStatusWhen {
    EVERY_DAY = 0,
    ON_CLEANING_DAY = 1,
}

export class GetListOfAutomaticHousekeepingUpdateSettingsQuery implements IGetListOfAutomaticHousekeepingUpdateSettingsQuery {
    hotelId?: string | null;

    constructor(data?: IGetListOfAutomaticHousekeepingUpdateSettingsQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hotelId = _data["hotelId"] !== undefined ? _data["hotelId"] : <any>null;
        }
    }

    static fromJS(data: any): GetListOfAutomaticHousekeepingUpdateSettingsQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetListOfAutomaticHousekeepingUpdateSettingsQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hotelId"] = this.hotelId !== undefined ? this.hotelId : <any>null;
        return data; 
    }
}

export interface IGetListOfAutomaticHousekeepingUpdateSettingsQuery {
    hotelId?: string | null;
}

export class ProcessResponseOfGuid extends ProcessResponse implements IProcessResponseOfGuid {
    data!: string;

    constructor(data?: IProcessResponseOfGuid) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.data = _data["data"] !== undefined ? _data["data"] : <any>null;
        }
    }

    static fromJS(data: any): ProcessResponseOfGuid {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessResponseOfGuid();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data !== undefined ? this.data : <any>null;
        super.toJSON(data);
        return data; 
    }
}

export interface IProcessResponseOfGuid extends IProcessResponse {
    data: string;
}

export class SaveAutomaticHousekeepingUpdateSettings implements ISaveAutomaticHousekeepingUpdateSettings {
    hotelId?: string | null;
    dirty!: boolean;
    clean!: boolean;
    cleanNeedsInspection!: boolean;
    inspected!: boolean;
    vacant!: boolean;
    occupied!: boolean;
    doNotDisturb!: boolean;
    doDisturb!: boolean;
    outOfService!: boolean;
    inService!: boolean;
    roomNameRegex?: string | null;
    updateStatusTo!: AutomaticHousekeepingUpdateCleaningStatusTo;
    updateStatusWhen!: AutomaticHousekeepingUpdateCleaningStatusWhen;
    updateStatusAtTime?: string | null;

    constructor(data?: ISaveAutomaticHousekeepingUpdateSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hotelId = _data["hotelId"] !== undefined ? _data["hotelId"] : <any>null;
            this.dirty = _data["dirty"] !== undefined ? _data["dirty"] : <any>null;
            this.clean = _data["clean"] !== undefined ? _data["clean"] : <any>null;
            this.cleanNeedsInspection = _data["cleanNeedsInspection"] !== undefined ? _data["cleanNeedsInspection"] : <any>null;
            this.inspected = _data["inspected"] !== undefined ? _data["inspected"] : <any>null;
            this.vacant = _data["vacant"] !== undefined ? _data["vacant"] : <any>null;
            this.occupied = _data["occupied"] !== undefined ? _data["occupied"] : <any>null;
            this.doNotDisturb = _data["doNotDisturb"] !== undefined ? _data["doNotDisturb"] : <any>null;
            this.doDisturb = _data["doDisturb"] !== undefined ? _data["doDisturb"] : <any>null;
            this.outOfService = _data["outOfService"] !== undefined ? _data["outOfService"] : <any>null;
            this.inService = _data["inService"] !== undefined ? _data["inService"] : <any>null;
            this.roomNameRegex = _data["roomNameRegex"] !== undefined ? _data["roomNameRegex"] : <any>null;
            this.updateStatusTo = _data["updateStatusTo"] !== undefined ? _data["updateStatusTo"] : <any>null;
            this.updateStatusWhen = _data["updateStatusWhen"] !== undefined ? _data["updateStatusWhen"] : <any>null;
            this.updateStatusAtTime = _data["updateStatusAtTime"] !== undefined ? _data["updateStatusAtTime"] : <any>null;
        }
    }

    static fromJS(data: any): SaveAutomaticHousekeepingUpdateSettings {
        data = typeof data === 'object' ? data : {};
        let result = new SaveAutomaticHousekeepingUpdateSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hotelId"] = this.hotelId !== undefined ? this.hotelId : <any>null;
        data["dirty"] = this.dirty !== undefined ? this.dirty : <any>null;
        data["clean"] = this.clean !== undefined ? this.clean : <any>null;
        data["cleanNeedsInspection"] = this.cleanNeedsInspection !== undefined ? this.cleanNeedsInspection : <any>null;
        data["inspected"] = this.inspected !== undefined ? this.inspected : <any>null;
        data["vacant"] = this.vacant !== undefined ? this.vacant : <any>null;
        data["occupied"] = this.occupied !== undefined ? this.occupied : <any>null;
        data["doNotDisturb"] = this.doNotDisturb !== undefined ? this.doNotDisturb : <any>null;
        data["doDisturb"] = this.doDisturb !== undefined ? this.doDisturb : <any>null;
        data["outOfService"] = this.outOfService !== undefined ? this.outOfService : <any>null;
        data["inService"] = this.inService !== undefined ? this.inService : <any>null;
        data["roomNameRegex"] = this.roomNameRegex !== undefined ? this.roomNameRegex : <any>null;
        data["updateStatusTo"] = this.updateStatusTo !== undefined ? this.updateStatusTo : <any>null;
        data["updateStatusWhen"] = this.updateStatusWhen !== undefined ? this.updateStatusWhen : <any>null;
        data["updateStatusAtTime"] = this.updateStatusAtTime !== undefined ? this.updateStatusAtTime : <any>null;
        return data; 
    }
}

export interface ISaveAutomaticHousekeepingUpdateSettings {
    hotelId?: string | null;
    dirty: boolean;
    clean: boolean;
    cleanNeedsInspection: boolean;
    inspected: boolean;
    vacant: boolean;
    occupied: boolean;
    doNotDisturb: boolean;
    doDisturb: boolean;
    outOfService: boolean;
    inService: boolean;
    roomNameRegex?: string | null;
    updateStatusTo: AutomaticHousekeepingUpdateCleaningStatusTo;
    updateStatusWhen: AutomaticHousekeepingUpdateCleaningStatusWhen;
    updateStatusAtTime?: string | null;
}

export class InsertAutomaticHousekeepingUpdateSettingsCommand extends SaveAutomaticHousekeepingUpdateSettings implements IInsertAutomaticHousekeepingUpdateSettingsCommand {

    constructor(data?: IInsertAutomaticHousekeepingUpdateSettingsCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): InsertAutomaticHousekeepingUpdateSettingsCommand {
        data = typeof data === 'object' ? data : {};
        let result = new InsertAutomaticHousekeepingUpdateSettingsCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IInsertAutomaticHousekeepingUpdateSettingsCommand extends ISaveAutomaticHousekeepingUpdateSettings {
}

export class UpdateAutomaticHousekeepingUpdateSettingsCommand extends SaveAutomaticHousekeepingUpdateSettings implements IUpdateAutomaticHousekeepingUpdateSettingsCommand {
    id!: string;

    constructor(data?: IUpdateAutomaticHousekeepingUpdateSettingsCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
        }
    }

    static fromJS(data: any): UpdateAutomaticHousekeepingUpdateSettingsCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAutomaticHousekeepingUpdateSettingsCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        super.toJSON(data);
        return data; 
    }
}

export interface IUpdateAutomaticHousekeepingUpdateSettingsCommand extends ISaveAutomaticHousekeepingUpdateSettings {
    id: string;
}

export class DeleteAutomaticHousekeepingUpdateSettingsCommand implements IDeleteAutomaticHousekeepingUpdateSettingsCommand {
    id!: string;

    constructor(data?: IDeleteAutomaticHousekeepingUpdateSettingsCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
        }
    }

    static fromJS(data: any): DeleteAutomaticHousekeepingUpdateSettingsCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteAutomaticHousekeepingUpdateSettingsCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        return data; 
    }
}

export interface IDeleteAutomaticHousekeepingUpdateSettingsCommand {
    id: string;
}

export class CleaningCalendarIntervalResult implements ICleaningCalendarIntervalResult {
    days?: CalendarDay[] | null;
    rooms?: CleaningCalendarRoom[] | null;

    constructor(data?: ICleaningCalendarIntervalResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["days"])) {
                this.days = [] as any;
                for (let item of _data["days"])
                    this.days!.push(CalendarDay.fromJS(item));
            }
            if (Array.isArray(_data["rooms"])) {
                this.rooms = [] as any;
                for (let item of _data["rooms"])
                    this.rooms!.push(CleaningCalendarRoom.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CleaningCalendarIntervalResult {
        data = typeof data === 'object' ? data : {};
        let result = new CleaningCalendarIntervalResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.days)) {
            data["days"] = [];
            for (let item of this.days)
                data["days"].push(item.toJSON());
        }
        if (Array.isArray(this.rooms)) {
            data["rooms"] = [];
            for (let item of this.rooms)
                data["rooms"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICleaningCalendarIntervalResult {
    days?: CalendarDay[] | null;
    rooms?: CleaningCalendarRoom[] | null;
}

export class CalendarDay implements ICalendarDay {
    date!: moment.Moment;
    dayName?: string | null;
    dateString?: string | null;

    constructor(data?: ICalendarDay) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? moment(_data["date"].toString()) : <any>null;
            this.dayName = _data["dayName"] !== undefined ? _data["dayName"] : <any>null;
            this.dateString = _data["dateString"] !== undefined ? _data["dateString"] : <any>null;
        }
    }

    static fromJS(data: any): CalendarDay {
        data = typeof data === 'object' ? data : {};
        let result = new CalendarDay();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>null;
        data["dayName"] = this.dayName !== undefined ? this.dayName : <any>null;
        data["dateString"] = this.dateString !== undefined ? this.dateString : <any>null;
        return data; 
    }
}

export interface ICalendarDay {
    date: moment.Moment;
    dayName?: string | null;
    dateString?: string | null;
}

export class CleaningCalendarRoom implements ICleaningCalendarRoom {
    name?: string | null;
    categoryName?: string | null;
    days?: CleaningCalendarDay[] | null;

    constructor(data?: ICleaningCalendarRoom) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.categoryName = _data["categoryName"] !== undefined ? _data["categoryName"] : <any>null;
            if (Array.isArray(_data["days"])) {
                this.days = [] as any;
                for (let item of _data["days"])
                    this.days!.push(CleaningCalendarDay.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CleaningCalendarRoom {
        data = typeof data === 'object' ? data : {};
        let result = new CleaningCalendarRoom();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["categoryName"] = this.categoryName !== undefined ? this.categoryName : <any>null;
        if (Array.isArray(this.days)) {
            data["days"] = [];
            for (let item of this.days)
                data["days"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICleaningCalendarRoom {
    name?: string | null;
    categoryName?: string | null;
    days?: CleaningCalendarDay[] | null;
}

export class CleaningCalendarDay extends CalendarDay implements ICleaningCalendarDay {
    reservations?: CleaningCalendarReservation[] | null;
    cleanings?: CleaningCalendarCleaning[] | null;

    constructor(data?: ICleaningCalendarDay) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["reservations"])) {
                this.reservations = [] as any;
                for (let item of _data["reservations"])
                    this.reservations!.push(CleaningCalendarReservation.fromJS(item));
            }
            if (Array.isArray(_data["cleanings"])) {
                this.cleanings = [] as any;
                for (let item of _data["cleanings"])
                    this.cleanings!.push(CleaningCalendarCleaning.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CleaningCalendarDay {
        data = typeof data === 'object' ? data : {};
        let result = new CleaningCalendarDay();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.reservations)) {
            data["reservations"] = [];
            for (let item of this.reservations)
                data["reservations"].push(item.toJSON());
        }
        if (Array.isArray(this.cleanings)) {
            data["cleanings"] = [];
            for (let item of this.cleanings)
                data["cleanings"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface ICleaningCalendarDay extends ICalendarDay {
    reservations?: CleaningCalendarReservation[] | null;
    cleanings?: CleaningCalendarCleaning[] | null;
}

export class CleaningCalendarReservation implements ICleaningCalendarReservation {
    reservationId?: string | null;
    guestName?: string | null;
    isArrival!: boolean;
    isDeparture!: boolean;

    constructor(data?: ICleaningCalendarReservation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reservationId = _data["reservationId"] !== undefined ? _data["reservationId"] : <any>null;
            this.guestName = _data["guestName"] !== undefined ? _data["guestName"] : <any>null;
            this.isArrival = _data["isArrival"] !== undefined ? _data["isArrival"] : <any>null;
            this.isDeparture = _data["isDeparture"] !== undefined ? _data["isDeparture"] : <any>null;
        }
    }

    static fromJS(data: any): CleaningCalendarReservation {
        data = typeof data === 'object' ? data : {};
        let result = new CleaningCalendarReservation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reservationId"] = this.reservationId !== undefined ? this.reservationId : <any>null;
        data["guestName"] = this.guestName !== undefined ? this.guestName : <any>null;
        data["isArrival"] = this.isArrival !== undefined ? this.isArrival : <any>null;
        data["isDeparture"] = this.isDeparture !== undefined ? this.isDeparture : <any>null;
        return data; 
    }
}

export interface ICleaningCalendarReservation {
    reservationId?: string | null;
    guestName?: string | null;
    isArrival: boolean;
    isDeparture: boolean;
}

export class CleaningCalendarCleaning implements ICleaningCalendarCleaning {
    cleaningName?: string | null;
    hasRecommendedInterval!: boolean;
    recommendedIntervalFromTimeString?: string | null;
    recommendedIntervalToTimeString?: string | null;

    constructor(data?: ICleaningCalendarCleaning) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cleaningName = _data["cleaningName"] !== undefined ? _data["cleaningName"] : <any>null;
            this.hasRecommendedInterval = _data["hasRecommendedInterval"] !== undefined ? _data["hasRecommendedInterval"] : <any>null;
            this.recommendedIntervalFromTimeString = _data["recommendedIntervalFromTimeString"] !== undefined ? _data["recommendedIntervalFromTimeString"] : <any>null;
            this.recommendedIntervalToTimeString = _data["recommendedIntervalToTimeString"] !== undefined ? _data["recommendedIntervalToTimeString"] : <any>null;
        }
    }

    static fromJS(data: any): CleaningCalendarCleaning {
        data = typeof data === 'object' ? data : {};
        let result = new CleaningCalendarCleaning();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cleaningName"] = this.cleaningName !== undefined ? this.cleaningName : <any>null;
        data["hasRecommendedInterval"] = this.hasRecommendedInterval !== undefined ? this.hasRecommendedInterval : <any>null;
        data["recommendedIntervalFromTimeString"] = this.recommendedIntervalFromTimeString !== undefined ? this.recommendedIntervalFromTimeString : <any>null;
        data["recommendedIntervalToTimeString"] = this.recommendedIntervalToTimeString !== undefined ? this.recommendedIntervalToTimeString : <any>null;
        return data; 
    }
}

export interface ICleaningCalendarCleaning {
    cleaningName?: string | null;
    hasRecommendedInterval: boolean;
    recommendedIntervalFromTimeString?: string | null;
    recommendedIntervalToTimeString?: string | null;
}

export class GetWeeklyCleaningCalendarQuery implements IGetWeeklyCleaningCalendarQuery {
    hotelId?: string | null;
    fromDate!: moment.Moment;
    toDate!: moment.Moment;

    constructor(data?: IGetWeeklyCleaningCalendarQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hotelId = _data["hotelId"] !== undefined ? _data["hotelId"] : <any>null;
            this.fromDate = _data["fromDate"] ? moment(_data["fromDate"].toString()) : <any>null;
            this.toDate = _data["toDate"] ? moment(_data["toDate"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): GetWeeklyCleaningCalendarQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetWeeklyCleaningCalendarQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hotelId"] = this.hotelId !== undefined ? this.hotelId : <any>null;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>null;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>null;
        return data; 
    }
}

export interface IGetWeeklyCleaningCalendarQuery {
    hotelId?: string | null;
    fromDate: moment.Moment;
    toDate: moment.Moment;
}

export class CleaningPluginsConfigurationData implements ICleaningPluginsConfigurationData {
    cleaningPluginTypes?: CleaningPluginTypeData[] | null;
    cleaningPluginBasedOns?: CleaningPluginBasedOnConfigurationData[] | null;
    displayStyles?: CleaningPluginDisplayStyleData[] | null;
    selectedBasedOns?: CleaningPluginBasedOnData[] | null;

    constructor(data?: ICleaningPluginsConfigurationData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["cleaningPluginTypes"])) {
                this.cleaningPluginTypes = [] as any;
                for (let item of _data["cleaningPluginTypes"])
                    this.cleaningPluginTypes!.push(CleaningPluginTypeData.fromJS(item));
            }
            if (Array.isArray(_data["cleaningPluginBasedOns"])) {
                this.cleaningPluginBasedOns = [] as any;
                for (let item of _data["cleaningPluginBasedOns"])
                    this.cleaningPluginBasedOns!.push(CleaningPluginBasedOnConfigurationData.fromJS(item));
            }
            if (Array.isArray(_data["displayStyles"])) {
                this.displayStyles = [] as any;
                for (let item of _data["displayStyles"])
                    this.displayStyles!.push(CleaningPluginDisplayStyleData.fromJS(item));
            }
            if (Array.isArray(_data["selectedBasedOns"])) {
                this.selectedBasedOns = [] as any;
                for (let item of _data["selectedBasedOns"])
                    this.selectedBasedOns!.push(CleaningPluginBasedOnData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CleaningPluginsConfigurationData {
        data = typeof data === 'object' ? data : {};
        let result = new CleaningPluginsConfigurationData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.cleaningPluginTypes)) {
            data["cleaningPluginTypes"] = [];
            for (let item of this.cleaningPluginTypes)
                data["cleaningPluginTypes"].push(item.toJSON());
        }
        if (Array.isArray(this.cleaningPluginBasedOns)) {
            data["cleaningPluginBasedOns"] = [];
            for (let item of this.cleaningPluginBasedOns)
                data["cleaningPluginBasedOns"].push(item.toJSON());
        }
        if (Array.isArray(this.displayStyles)) {
            data["displayStyles"] = [];
            for (let item of this.displayStyles)
                data["displayStyles"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedBasedOns)) {
            data["selectedBasedOns"] = [];
            for (let item of this.selectedBasedOns)
                data["selectedBasedOns"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICleaningPluginsConfigurationData {
    cleaningPluginTypes?: CleaningPluginTypeData[] | null;
    cleaningPluginBasedOns?: CleaningPluginBasedOnConfigurationData[] | null;
    displayStyles?: CleaningPluginDisplayStyleData[] | null;
    selectedBasedOns?: CleaningPluginBasedOnData[] | null;
}

export class CleaningPluginTypeData implements ICleaningPluginTypeData {
    key?: string | null;
    name?: string | null;
    parametersDescription?: string | null;
    parametersExpectedFormat?: string | null;

    constructor(data?: ICleaningPluginTypeData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"] !== undefined ? _data["key"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.parametersDescription = _data["parametersDescription"] !== undefined ? _data["parametersDescription"] : <any>null;
            this.parametersExpectedFormat = _data["parametersExpectedFormat"] !== undefined ? _data["parametersExpectedFormat"] : <any>null;
        }
    }

    static fromJS(data: any): CleaningPluginTypeData {
        data = typeof data === 'object' ? data : {};
        let result = new CleaningPluginTypeData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key !== undefined ? this.key : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["parametersDescription"] = this.parametersDescription !== undefined ? this.parametersDescription : <any>null;
        data["parametersExpectedFormat"] = this.parametersExpectedFormat !== undefined ? this.parametersExpectedFormat : <any>null;
        return data; 
    }
}

export interface ICleaningPluginTypeData {
    key?: string | null;
    name?: string | null;
    parametersDescription?: string | null;
    parametersExpectedFormat?: string | null;
}

export class CleaningPluginBasedOnConfigurationData implements ICleaningPluginBasedOnConfigurationData {
    key?: string | null;
    name?: string | null;
    parametersDescription?: string | null;
    predefinedParameters?: string | null;

    constructor(data?: ICleaningPluginBasedOnConfigurationData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"] !== undefined ? _data["key"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.parametersDescription = _data["parametersDescription"] !== undefined ? _data["parametersDescription"] : <any>null;
            this.predefinedParameters = _data["predefinedParameters"] !== undefined ? _data["predefinedParameters"] : <any>null;
        }
    }

    static fromJS(data: any): CleaningPluginBasedOnConfigurationData {
        data = typeof data === 'object' ? data : {};
        let result = new CleaningPluginBasedOnConfigurationData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key !== undefined ? this.key : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["parametersDescription"] = this.parametersDescription !== undefined ? this.parametersDescription : <any>null;
        data["predefinedParameters"] = this.predefinedParameters !== undefined ? this.predefinedParameters : <any>null;
        return data; 
    }
}

export interface ICleaningPluginBasedOnConfigurationData {
    key?: string | null;
    name?: string | null;
    parametersDescription?: string | null;
    predefinedParameters?: string | null;
}

export class CleaningPluginDisplayStyleData implements ICleaningPluginDisplayStyleData {
    name?: string | null;

    constructor(data?: ICleaningPluginDisplayStyleData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
        }
    }

    static fromJS(data: any): CleaningPluginDisplayStyleData {
        data = typeof data === 'object' ? data : {};
        let result = new CleaningPluginDisplayStyleData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface ICleaningPluginDisplayStyleData {
    name?: string | null;
}

export class CleaningPluginBasedOnData extends CleaningPluginBasedOnConfigurationData implements ICleaningPluginBasedOnData {
    id!: string;

    constructor(data?: ICleaningPluginBasedOnData) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
        }
    }

    static fromJS(data: any): CleaningPluginBasedOnData {
        data = typeof data === 'object' ? data : {};
        let result = new CleaningPluginBasedOnData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        super.toJSON(data);
        return data; 
    }
}

export interface ICleaningPluginBasedOnData extends ICleaningPluginBasedOnConfigurationData {
    id: string;
}

export class GetCleaningPluginsConfigurationDataQuery implements IGetCleaningPluginsConfigurationDataQuery {

    constructor(data?: IGetCleaningPluginsConfigurationDataQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): GetCleaningPluginsConfigurationDataQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetCleaningPluginsConfigurationDataQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IGetCleaningPluginsConfigurationDataQuery {
}

export class CleaningPluginGridData implements ICleaningPluginGridData {
    id!: string;
    name?: string | null;
    typeKey?: string | null;
    typeDescription?: string | null;
    isActive!: boolean;
    isTopRule!: boolean;
    ordinalNumber!: number;

    constructor(data?: ICleaningPluginGridData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.typeKey = _data["typeKey"] !== undefined ? _data["typeKey"] : <any>null;
            this.typeDescription = _data["typeDescription"] !== undefined ? _data["typeDescription"] : <any>null;
            this.isActive = _data["isActive"] !== undefined ? _data["isActive"] : <any>null;
            this.isTopRule = _data["isTopRule"] !== undefined ? _data["isTopRule"] : <any>null;
            this.ordinalNumber = _data["ordinalNumber"] !== undefined ? _data["ordinalNumber"] : <any>null;
        }
    }

    static fromJS(data: any): CleaningPluginGridData {
        data = typeof data === 'object' ? data : {};
        let result = new CleaningPluginGridData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["typeKey"] = this.typeKey !== undefined ? this.typeKey : <any>null;
        data["typeDescription"] = this.typeDescription !== undefined ? this.typeDescription : <any>null;
        data["isActive"] = this.isActive !== undefined ? this.isActive : <any>null;
        data["isTopRule"] = this.isTopRule !== undefined ? this.isTopRule : <any>null;
        data["ordinalNumber"] = this.ordinalNumber !== undefined ? this.ordinalNumber : <any>null;
        return data; 
    }
}

export interface ICleaningPluginGridData {
    id: string;
    name?: string | null;
    typeKey?: string | null;
    typeDescription?: string | null;
    isActive: boolean;
    isTopRule: boolean;
    ordinalNumber: number;
}

export class GetHotelCleaningPluginsQuery implements IGetHotelCleaningPluginsQuery {
    hotelId?: string | null;

    constructor(data?: IGetHotelCleaningPluginsQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hotelId = _data["hotelId"] !== undefined ? _data["hotelId"] : <any>null;
        }
    }

    static fromJS(data: any): GetHotelCleaningPluginsQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetHotelCleaningPluginsQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hotelId"] = this.hotelId !== undefined ? this.hotelId : <any>null;
        return data; 
    }
}

export interface IGetHotelCleaningPluginsQuery {
    hotelId?: string | null;
}

export class CleaningPluginDetailsData implements ICleaningPluginDetailsData {
    id!: string;
    ordinalNumber!: number;
    isActive!: boolean;
    hotelId?: string | null;
    changeSheets!: boolean;
    isNightlyCleaningPlugin!: boolean;
    cleanOnHolidays!: boolean;
    cleanOnSaturday!: boolean;
    cleanOnSunday!: boolean;
    color?: string | null;
    dailyCleaningTypeTimes?: string[] | null;
    dailyCleaningTimeTypeKey?: string | null;
    displayStyleKey?: string | null;
    instructions?: string | null;
    isTopRule!: boolean;
    monthlyCleaningTypeTimeOfMonthKey?: string | null;
    name?: string | null;
    postponeUntilVacant!: boolean;
    startsCleaningAfter?: number | null;
    typeKey?: string | null;
    weekBasedCleaningTypeWeeks?: number[] | null;
    periodicalIntervals?: CleaningPluginDetailsPeriodicalInterval[] | null;
    periodicalPostponeSundayCleaningsToMonday?: boolean | null;
    weeklyCleanOnMonday?: boolean | null;
    weeklyCleanOnTuesday?: boolean | null;
    weeklyCleanOnWednesday?: boolean | null;
    weeklyCleanOnThursday?: boolean | null;
    weeklyCleanOnFriday?: boolean | null;
    weeklyCleanOnSaturday?: boolean | null;
    weeklyCleanOnSunday?: boolean | null;
    weeklyCleaningTypeMondayTimes?: string[] | null;
    weeklyCleaningTypeTuesdayTimes?: string[] | null;
    weeklyCleaningTypeWednesdayTimes?: string[] | null;
    weeklyCleaningTypeThursdayTimes?: string[] | null;
    weeklyCleaningTypeFridayTimes?: string[] | null;
    weeklyCleaningTypeSaturdayTimes?: string[] | null;
    weeklyCleaningTypeSundayTimes?: string[] | null;
    weeklyTimeMondayTypeKey?: string | null;
    weeklyTimeTuesdayTypeKey?: string | null;
    weeklyTimeWednesdayTypeKey?: string | null;
    weeklyTimeThursdayTypeKey?: string | null;
    weeklyTimeFridayTypeKey?: string | null;
    weeklyTimeSaturdayTypeKey?: string | null;
    weeklyTimeSundayTypeKey?: string | null;
    weekBasedCleaningDayOfTheWeekKey?: string | null;
    basedOns?: CleaningPluginDetailsBasedOnData[] | null;

    constructor(data?: ICleaningPluginDetailsData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.ordinalNumber = _data["ordinalNumber"] !== undefined ? _data["ordinalNumber"] : <any>null;
            this.isActive = _data["isActive"] !== undefined ? _data["isActive"] : <any>null;
            this.hotelId = _data["hotelId"] !== undefined ? _data["hotelId"] : <any>null;
            this.changeSheets = _data["changeSheets"] !== undefined ? _data["changeSheets"] : <any>null;
            this.isNightlyCleaningPlugin = _data["isNightlyCleaningPlugin"] !== undefined ? _data["isNightlyCleaningPlugin"] : <any>null;
            this.cleanOnHolidays = _data["cleanOnHolidays"] !== undefined ? _data["cleanOnHolidays"] : <any>null;
            this.cleanOnSaturday = _data["cleanOnSaturday"] !== undefined ? _data["cleanOnSaturday"] : <any>null;
            this.cleanOnSunday = _data["cleanOnSunday"] !== undefined ? _data["cleanOnSunday"] : <any>null;
            this.color = _data["color"] !== undefined ? _data["color"] : <any>null;
            if (Array.isArray(_data["dailyCleaningTypeTimes"])) {
                this.dailyCleaningTypeTimes = [] as any;
                for (let item of _data["dailyCleaningTypeTimes"])
                    this.dailyCleaningTypeTimes!.push(item);
            }
            this.dailyCleaningTimeTypeKey = _data["dailyCleaningTimeTypeKey"] !== undefined ? _data["dailyCleaningTimeTypeKey"] : <any>null;
            this.displayStyleKey = _data["displayStyleKey"] !== undefined ? _data["displayStyleKey"] : <any>null;
            this.instructions = _data["instructions"] !== undefined ? _data["instructions"] : <any>null;
            this.isTopRule = _data["isTopRule"] !== undefined ? _data["isTopRule"] : <any>null;
            this.monthlyCleaningTypeTimeOfMonthKey = _data["monthlyCleaningTypeTimeOfMonthKey"] !== undefined ? _data["monthlyCleaningTypeTimeOfMonthKey"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.postponeUntilVacant = _data["postponeUntilVacant"] !== undefined ? _data["postponeUntilVacant"] : <any>null;
            this.startsCleaningAfter = _data["startsCleaningAfter"] !== undefined ? _data["startsCleaningAfter"] : <any>null;
            this.typeKey = _data["typeKey"] !== undefined ? _data["typeKey"] : <any>null;
            if (Array.isArray(_data["weekBasedCleaningTypeWeeks"])) {
                this.weekBasedCleaningTypeWeeks = [] as any;
                for (let item of _data["weekBasedCleaningTypeWeeks"])
                    this.weekBasedCleaningTypeWeeks!.push(item);
            }
            if (Array.isArray(_data["periodicalIntervals"])) {
                this.periodicalIntervals = [] as any;
                for (let item of _data["periodicalIntervals"])
                    this.periodicalIntervals!.push(CleaningPluginDetailsPeriodicalInterval.fromJS(item));
            }
            this.periodicalPostponeSundayCleaningsToMonday = _data["periodicalPostponeSundayCleaningsToMonday"] !== undefined ? _data["periodicalPostponeSundayCleaningsToMonday"] : <any>null;
            this.weeklyCleanOnMonday = _data["weeklyCleanOnMonday"] !== undefined ? _data["weeklyCleanOnMonday"] : <any>null;
            this.weeklyCleanOnTuesday = _data["weeklyCleanOnTuesday"] !== undefined ? _data["weeklyCleanOnTuesday"] : <any>null;
            this.weeklyCleanOnWednesday = _data["weeklyCleanOnWednesday"] !== undefined ? _data["weeklyCleanOnWednesday"] : <any>null;
            this.weeklyCleanOnThursday = _data["weeklyCleanOnThursday"] !== undefined ? _data["weeklyCleanOnThursday"] : <any>null;
            this.weeklyCleanOnFriday = _data["weeklyCleanOnFriday"] !== undefined ? _data["weeklyCleanOnFriday"] : <any>null;
            this.weeklyCleanOnSaturday = _data["weeklyCleanOnSaturday"] !== undefined ? _data["weeklyCleanOnSaturday"] : <any>null;
            this.weeklyCleanOnSunday = _data["weeklyCleanOnSunday"] !== undefined ? _data["weeklyCleanOnSunday"] : <any>null;
            if (Array.isArray(_data["weeklyCleaningTypeMondayTimes"])) {
                this.weeklyCleaningTypeMondayTimes = [] as any;
                for (let item of _data["weeklyCleaningTypeMondayTimes"])
                    this.weeklyCleaningTypeMondayTimes!.push(item);
            }
            if (Array.isArray(_data["weeklyCleaningTypeTuesdayTimes"])) {
                this.weeklyCleaningTypeTuesdayTimes = [] as any;
                for (let item of _data["weeklyCleaningTypeTuesdayTimes"])
                    this.weeklyCleaningTypeTuesdayTimes!.push(item);
            }
            if (Array.isArray(_data["weeklyCleaningTypeWednesdayTimes"])) {
                this.weeklyCleaningTypeWednesdayTimes = [] as any;
                for (let item of _data["weeklyCleaningTypeWednesdayTimes"])
                    this.weeklyCleaningTypeWednesdayTimes!.push(item);
            }
            if (Array.isArray(_data["weeklyCleaningTypeThursdayTimes"])) {
                this.weeklyCleaningTypeThursdayTimes = [] as any;
                for (let item of _data["weeklyCleaningTypeThursdayTimes"])
                    this.weeklyCleaningTypeThursdayTimes!.push(item);
            }
            if (Array.isArray(_data["weeklyCleaningTypeFridayTimes"])) {
                this.weeklyCleaningTypeFridayTimes = [] as any;
                for (let item of _data["weeklyCleaningTypeFridayTimes"])
                    this.weeklyCleaningTypeFridayTimes!.push(item);
            }
            if (Array.isArray(_data["weeklyCleaningTypeSaturdayTimes"])) {
                this.weeklyCleaningTypeSaturdayTimes = [] as any;
                for (let item of _data["weeklyCleaningTypeSaturdayTimes"])
                    this.weeklyCleaningTypeSaturdayTimes!.push(item);
            }
            if (Array.isArray(_data["weeklyCleaningTypeSundayTimes"])) {
                this.weeklyCleaningTypeSundayTimes = [] as any;
                for (let item of _data["weeklyCleaningTypeSundayTimes"])
                    this.weeklyCleaningTypeSundayTimes!.push(item);
            }
            this.weeklyTimeMondayTypeKey = _data["weeklyTimeMondayTypeKey"] !== undefined ? _data["weeklyTimeMondayTypeKey"] : <any>null;
            this.weeklyTimeTuesdayTypeKey = _data["weeklyTimeTuesdayTypeKey"] !== undefined ? _data["weeklyTimeTuesdayTypeKey"] : <any>null;
            this.weeklyTimeWednesdayTypeKey = _data["weeklyTimeWednesdayTypeKey"] !== undefined ? _data["weeklyTimeWednesdayTypeKey"] : <any>null;
            this.weeklyTimeThursdayTypeKey = _data["weeklyTimeThursdayTypeKey"] !== undefined ? _data["weeklyTimeThursdayTypeKey"] : <any>null;
            this.weeklyTimeFridayTypeKey = _data["weeklyTimeFridayTypeKey"] !== undefined ? _data["weeklyTimeFridayTypeKey"] : <any>null;
            this.weeklyTimeSaturdayTypeKey = _data["weeklyTimeSaturdayTypeKey"] !== undefined ? _data["weeklyTimeSaturdayTypeKey"] : <any>null;
            this.weeklyTimeSundayTypeKey = _data["weeklyTimeSundayTypeKey"] !== undefined ? _data["weeklyTimeSundayTypeKey"] : <any>null;
            this.weekBasedCleaningDayOfTheWeekKey = _data["weekBasedCleaningDayOfTheWeekKey"] !== undefined ? _data["weekBasedCleaningDayOfTheWeekKey"] : <any>null;
            if (Array.isArray(_data["basedOns"])) {
                this.basedOns = [] as any;
                for (let item of _data["basedOns"])
                    this.basedOns!.push(CleaningPluginDetailsBasedOnData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CleaningPluginDetailsData {
        data = typeof data === 'object' ? data : {};
        let result = new CleaningPluginDetailsData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["ordinalNumber"] = this.ordinalNumber !== undefined ? this.ordinalNumber : <any>null;
        data["isActive"] = this.isActive !== undefined ? this.isActive : <any>null;
        data["hotelId"] = this.hotelId !== undefined ? this.hotelId : <any>null;
        data["changeSheets"] = this.changeSheets !== undefined ? this.changeSheets : <any>null;
        data["isNightlyCleaningPlugin"] = this.isNightlyCleaningPlugin !== undefined ? this.isNightlyCleaningPlugin : <any>null;
        data["cleanOnHolidays"] = this.cleanOnHolidays !== undefined ? this.cleanOnHolidays : <any>null;
        data["cleanOnSaturday"] = this.cleanOnSaturday !== undefined ? this.cleanOnSaturday : <any>null;
        data["cleanOnSunday"] = this.cleanOnSunday !== undefined ? this.cleanOnSunday : <any>null;
        data["color"] = this.color !== undefined ? this.color : <any>null;
        if (Array.isArray(this.dailyCleaningTypeTimes)) {
            data["dailyCleaningTypeTimes"] = [];
            for (let item of this.dailyCleaningTypeTimes)
                data["dailyCleaningTypeTimes"].push(item);
        }
        data["dailyCleaningTimeTypeKey"] = this.dailyCleaningTimeTypeKey !== undefined ? this.dailyCleaningTimeTypeKey : <any>null;
        data["displayStyleKey"] = this.displayStyleKey !== undefined ? this.displayStyleKey : <any>null;
        data["instructions"] = this.instructions !== undefined ? this.instructions : <any>null;
        data["isTopRule"] = this.isTopRule !== undefined ? this.isTopRule : <any>null;
        data["monthlyCleaningTypeTimeOfMonthKey"] = this.monthlyCleaningTypeTimeOfMonthKey !== undefined ? this.monthlyCleaningTypeTimeOfMonthKey : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["postponeUntilVacant"] = this.postponeUntilVacant !== undefined ? this.postponeUntilVacant : <any>null;
        data["startsCleaningAfter"] = this.startsCleaningAfter !== undefined ? this.startsCleaningAfter : <any>null;
        data["typeKey"] = this.typeKey !== undefined ? this.typeKey : <any>null;
        if (Array.isArray(this.weekBasedCleaningTypeWeeks)) {
            data["weekBasedCleaningTypeWeeks"] = [];
            for (let item of this.weekBasedCleaningTypeWeeks)
                data["weekBasedCleaningTypeWeeks"].push(item);
        }
        if (Array.isArray(this.periodicalIntervals)) {
            data["periodicalIntervals"] = [];
            for (let item of this.periodicalIntervals)
                data["periodicalIntervals"].push(item.toJSON());
        }
        data["periodicalPostponeSundayCleaningsToMonday"] = this.periodicalPostponeSundayCleaningsToMonday !== undefined ? this.periodicalPostponeSundayCleaningsToMonday : <any>null;
        data["weeklyCleanOnMonday"] = this.weeklyCleanOnMonday !== undefined ? this.weeklyCleanOnMonday : <any>null;
        data["weeklyCleanOnTuesday"] = this.weeklyCleanOnTuesday !== undefined ? this.weeklyCleanOnTuesday : <any>null;
        data["weeklyCleanOnWednesday"] = this.weeklyCleanOnWednesday !== undefined ? this.weeklyCleanOnWednesday : <any>null;
        data["weeklyCleanOnThursday"] = this.weeklyCleanOnThursday !== undefined ? this.weeklyCleanOnThursday : <any>null;
        data["weeklyCleanOnFriday"] = this.weeklyCleanOnFriday !== undefined ? this.weeklyCleanOnFriday : <any>null;
        data["weeklyCleanOnSaturday"] = this.weeklyCleanOnSaturday !== undefined ? this.weeklyCleanOnSaturday : <any>null;
        data["weeklyCleanOnSunday"] = this.weeklyCleanOnSunday !== undefined ? this.weeklyCleanOnSunday : <any>null;
        if (Array.isArray(this.weeklyCleaningTypeMondayTimes)) {
            data["weeklyCleaningTypeMondayTimes"] = [];
            for (let item of this.weeklyCleaningTypeMondayTimes)
                data["weeklyCleaningTypeMondayTimes"].push(item);
        }
        if (Array.isArray(this.weeklyCleaningTypeTuesdayTimes)) {
            data["weeklyCleaningTypeTuesdayTimes"] = [];
            for (let item of this.weeklyCleaningTypeTuesdayTimes)
                data["weeklyCleaningTypeTuesdayTimes"].push(item);
        }
        if (Array.isArray(this.weeklyCleaningTypeWednesdayTimes)) {
            data["weeklyCleaningTypeWednesdayTimes"] = [];
            for (let item of this.weeklyCleaningTypeWednesdayTimes)
                data["weeklyCleaningTypeWednesdayTimes"].push(item);
        }
        if (Array.isArray(this.weeklyCleaningTypeThursdayTimes)) {
            data["weeklyCleaningTypeThursdayTimes"] = [];
            for (let item of this.weeklyCleaningTypeThursdayTimes)
                data["weeklyCleaningTypeThursdayTimes"].push(item);
        }
        if (Array.isArray(this.weeklyCleaningTypeFridayTimes)) {
            data["weeklyCleaningTypeFridayTimes"] = [];
            for (let item of this.weeklyCleaningTypeFridayTimes)
                data["weeklyCleaningTypeFridayTimes"].push(item);
        }
        if (Array.isArray(this.weeklyCleaningTypeSaturdayTimes)) {
            data["weeklyCleaningTypeSaturdayTimes"] = [];
            for (let item of this.weeklyCleaningTypeSaturdayTimes)
                data["weeklyCleaningTypeSaturdayTimes"].push(item);
        }
        if (Array.isArray(this.weeklyCleaningTypeSundayTimes)) {
            data["weeklyCleaningTypeSundayTimes"] = [];
            for (let item of this.weeklyCleaningTypeSundayTimes)
                data["weeklyCleaningTypeSundayTimes"].push(item);
        }
        data["weeklyTimeMondayTypeKey"] = this.weeklyTimeMondayTypeKey !== undefined ? this.weeklyTimeMondayTypeKey : <any>null;
        data["weeklyTimeTuesdayTypeKey"] = this.weeklyTimeTuesdayTypeKey !== undefined ? this.weeklyTimeTuesdayTypeKey : <any>null;
        data["weeklyTimeWednesdayTypeKey"] = this.weeklyTimeWednesdayTypeKey !== undefined ? this.weeklyTimeWednesdayTypeKey : <any>null;
        data["weeklyTimeThursdayTypeKey"] = this.weeklyTimeThursdayTypeKey !== undefined ? this.weeklyTimeThursdayTypeKey : <any>null;
        data["weeklyTimeFridayTypeKey"] = this.weeklyTimeFridayTypeKey !== undefined ? this.weeklyTimeFridayTypeKey : <any>null;
        data["weeklyTimeSaturdayTypeKey"] = this.weeklyTimeSaturdayTypeKey !== undefined ? this.weeklyTimeSaturdayTypeKey : <any>null;
        data["weeklyTimeSundayTypeKey"] = this.weeklyTimeSundayTypeKey !== undefined ? this.weeklyTimeSundayTypeKey : <any>null;
        data["weekBasedCleaningDayOfTheWeekKey"] = this.weekBasedCleaningDayOfTheWeekKey !== undefined ? this.weekBasedCleaningDayOfTheWeekKey : <any>null;
        if (Array.isArray(this.basedOns)) {
            data["basedOns"] = [];
            for (let item of this.basedOns)
                data["basedOns"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICleaningPluginDetailsData {
    id: string;
    ordinalNumber: number;
    isActive: boolean;
    hotelId?: string | null;
    changeSheets: boolean;
    isNightlyCleaningPlugin: boolean;
    cleanOnHolidays: boolean;
    cleanOnSaturday: boolean;
    cleanOnSunday: boolean;
    color?: string | null;
    dailyCleaningTypeTimes?: string[] | null;
    dailyCleaningTimeTypeKey?: string | null;
    displayStyleKey?: string | null;
    instructions?: string | null;
    isTopRule: boolean;
    monthlyCleaningTypeTimeOfMonthKey?: string | null;
    name?: string | null;
    postponeUntilVacant: boolean;
    startsCleaningAfter?: number | null;
    typeKey?: string | null;
    weekBasedCleaningTypeWeeks?: number[] | null;
    periodicalIntervals?: CleaningPluginDetailsPeriodicalInterval[] | null;
    periodicalPostponeSundayCleaningsToMonday?: boolean | null;
    weeklyCleanOnMonday?: boolean | null;
    weeklyCleanOnTuesday?: boolean | null;
    weeklyCleanOnWednesday?: boolean | null;
    weeklyCleanOnThursday?: boolean | null;
    weeklyCleanOnFriday?: boolean | null;
    weeklyCleanOnSaturday?: boolean | null;
    weeklyCleanOnSunday?: boolean | null;
    weeklyCleaningTypeMondayTimes?: string[] | null;
    weeklyCleaningTypeTuesdayTimes?: string[] | null;
    weeklyCleaningTypeWednesdayTimes?: string[] | null;
    weeklyCleaningTypeThursdayTimes?: string[] | null;
    weeklyCleaningTypeFridayTimes?: string[] | null;
    weeklyCleaningTypeSaturdayTimes?: string[] | null;
    weeklyCleaningTypeSundayTimes?: string[] | null;
    weeklyTimeMondayTypeKey?: string | null;
    weeklyTimeTuesdayTypeKey?: string | null;
    weeklyTimeWednesdayTypeKey?: string | null;
    weeklyTimeThursdayTypeKey?: string | null;
    weeklyTimeFridayTypeKey?: string | null;
    weeklyTimeSaturdayTypeKey?: string | null;
    weeklyTimeSundayTypeKey?: string | null;
    weekBasedCleaningDayOfTheWeekKey?: string | null;
    basedOns?: CleaningPluginDetailsBasedOnData[] | null;
}

export class CleaningPluginDetailsPeriodicalInterval implements ICleaningPluginDetailsPeriodicalInterval {
    numberOfCleanings!: number;
    everyNumberOfDays!: number;
    fromNights!: number;
    toNights!: number;
    fromDayKey?: string | null;
    periodTypeKey?: string | null;
    intervalTypeKey?: string | null;

    constructor(data?: ICleaningPluginDetailsPeriodicalInterval) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.numberOfCleanings = _data["numberOfCleanings"] !== undefined ? _data["numberOfCleanings"] : <any>null;
            this.everyNumberOfDays = _data["everyNumberOfDays"] !== undefined ? _data["everyNumberOfDays"] : <any>null;
            this.fromNights = _data["fromNights"] !== undefined ? _data["fromNights"] : <any>null;
            this.toNights = _data["toNights"] !== undefined ? _data["toNights"] : <any>null;
            this.fromDayKey = _data["fromDayKey"] !== undefined ? _data["fromDayKey"] : <any>null;
            this.periodTypeKey = _data["periodTypeKey"] !== undefined ? _data["periodTypeKey"] : <any>null;
            this.intervalTypeKey = _data["intervalTypeKey"] !== undefined ? _data["intervalTypeKey"] : <any>null;
        }
    }

    static fromJS(data: any): CleaningPluginDetailsPeriodicalInterval {
        data = typeof data === 'object' ? data : {};
        let result = new CleaningPluginDetailsPeriodicalInterval();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["numberOfCleanings"] = this.numberOfCleanings !== undefined ? this.numberOfCleanings : <any>null;
        data["everyNumberOfDays"] = this.everyNumberOfDays !== undefined ? this.everyNumberOfDays : <any>null;
        data["fromNights"] = this.fromNights !== undefined ? this.fromNights : <any>null;
        data["toNights"] = this.toNights !== undefined ? this.toNights : <any>null;
        data["fromDayKey"] = this.fromDayKey !== undefined ? this.fromDayKey : <any>null;
        data["periodTypeKey"] = this.periodTypeKey !== undefined ? this.periodTypeKey : <any>null;
        data["intervalTypeKey"] = this.intervalTypeKey !== undefined ? this.intervalTypeKey : <any>null;
        return data; 
    }
}

export interface ICleaningPluginDetailsPeriodicalInterval {
    numberOfCleanings: number;
    everyNumberOfDays: number;
    fromNights: number;
    toNights: number;
    fromDayKey?: string | null;
    periodTypeKey?: string | null;
    intervalTypeKey?: string | null;
}

export class CleaningPluginDetailsBasedOnData implements ICleaningPluginDetailsBasedOnData {
    id?: string | null;
    name?: string | null;
    key?: string | null;
    description?: string | null;
    cleanDeparture?: boolean | null;
    cleanStay?: boolean | null;
    cleanVacant?: boolean | null;
    cleanVacantEveryNumberOfDays?: number | null;
    cleanOutOfService?: boolean | null;
    productsTagsMustBeConsumedOnTime?: boolean | null;
    productsTagsConsumationIntervalFrom?: moment.Moment | null;
    productsTagsConsumationIntervalTo?: moment.Moment | null;
    nightsTypeKey?: string | null;
    nightsEveryNumberOfDays?: number | null;
    nightsFromKey?: string | null;
    cleanlinessKey?: string | null;
    foorIds?: string[] | null;
    sections?: string[] | null;
    subSections?: string[] | null;
    nights?: number[] | null;
    reservationSpaceCategories?: string[] | null;
    productsTags?: string[] | null;
    rooms?: HotelRoomCreditsData[] | null;
    otherProperties?: KeyValue[] | null;
    categories?: CleaningPluginDetailsBasedOnRoomCategoryData[] | null;
    productsTagsExtended?: CleaningPluginDetailsBasedOnProdutsTagsExtendedData[] | null;
    otherPropertiesExtended?: CleaningPluginDetailsBasedOnOtherPropertiesExtendedData[] | null;

    constructor(data?: ICleaningPluginDetailsBasedOnData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.key = _data["key"] !== undefined ? _data["key"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.cleanDeparture = _data["cleanDeparture"] !== undefined ? _data["cleanDeparture"] : <any>null;
            this.cleanStay = _data["cleanStay"] !== undefined ? _data["cleanStay"] : <any>null;
            this.cleanVacant = _data["cleanVacant"] !== undefined ? _data["cleanVacant"] : <any>null;
            this.cleanVacantEveryNumberOfDays = _data["cleanVacantEveryNumberOfDays"] !== undefined ? _data["cleanVacantEveryNumberOfDays"] : <any>null;
            this.cleanOutOfService = _data["cleanOutOfService"] !== undefined ? _data["cleanOutOfService"] : <any>null;
            this.productsTagsMustBeConsumedOnTime = _data["productsTagsMustBeConsumedOnTime"] !== undefined ? _data["productsTagsMustBeConsumedOnTime"] : <any>null;
            this.productsTagsConsumationIntervalFrom = _data["productsTagsConsumationIntervalFrom"] ? moment(_data["productsTagsConsumationIntervalFrom"].toString()) : <any>null;
            this.productsTagsConsumationIntervalTo = _data["productsTagsConsumationIntervalTo"] ? moment(_data["productsTagsConsumationIntervalTo"].toString()) : <any>null;
            this.nightsTypeKey = _data["nightsTypeKey"] !== undefined ? _data["nightsTypeKey"] : <any>null;
            this.nightsEveryNumberOfDays = _data["nightsEveryNumberOfDays"] !== undefined ? _data["nightsEveryNumberOfDays"] : <any>null;
            this.nightsFromKey = _data["nightsFromKey"] !== undefined ? _data["nightsFromKey"] : <any>null;
            this.cleanlinessKey = _data["cleanlinessKey"] !== undefined ? _data["cleanlinessKey"] : <any>null;
            if (Array.isArray(_data["foorIds"])) {
                this.foorIds = [] as any;
                for (let item of _data["foorIds"])
                    this.foorIds!.push(item);
            }
            if (Array.isArray(_data["sections"])) {
                this.sections = [] as any;
                for (let item of _data["sections"])
                    this.sections!.push(item);
            }
            if (Array.isArray(_data["subSections"])) {
                this.subSections = [] as any;
                for (let item of _data["subSections"])
                    this.subSections!.push(item);
            }
            if (Array.isArray(_data["nights"])) {
                this.nights = [] as any;
                for (let item of _data["nights"])
                    this.nights!.push(item);
            }
            if (Array.isArray(_data["reservationSpaceCategories"])) {
                this.reservationSpaceCategories = [] as any;
                for (let item of _data["reservationSpaceCategories"])
                    this.reservationSpaceCategories!.push(item);
            }
            if (Array.isArray(_data["productsTags"])) {
                this.productsTags = [] as any;
                for (let item of _data["productsTags"])
                    this.productsTags!.push(item);
            }
            if (Array.isArray(_data["rooms"])) {
                this.rooms = [] as any;
                for (let item of _data["rooms"])
                    this.rooms!.push(HotelRoomCreditsData.fromJS(item));
            }
            if (Array.isArray(_data["otherProperties"])) {
                this.otherProperties = [] as any;
                for (let item of _data["otherProperties"])
                    this.otherProperties!.push(KeyValue.fromJS(item));
            }
            if (Array.isArray(_data["categories"])) {
                this.categories = [] as any;
                for (let item of _data["categories"])
                    this.categories!.push(CleaningPluginDetailsBasedOnRoomCategoryData.fromJS(item));
            }
            if (Array.isArray(_data["productsTagsExtended"])) {
                this.productsTagsExtended = [] as any;
                for (let item of _data["productsTagsExtended"])
                    this.productsTagsExtended!.push(CleaningPluginDetailsBasedOnProdutsTagsExtendedData.fromJS(item));
            }
            if (Array.isArray(_data["otherPropertiesExtended"])) {
                this.otherPropertiesExtended = [] as any;
                for (let item of _data["otherPropertiesExtended"])
                    this.otherPropertiesExtended!.push(CleaningPluginDetailsBasedOnOtherPropertiesExtendedData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CleaningPluginDetailsBasedOnData {
        data = typeof data === 'object' ? data : {};
        let result = new CleaningPluginDetailsBasedOnData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["key"] = this.key !== undefined ? this.key : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["cleanDeparture"] = this.cleanDeparture !== undefined ? this.cleanDeparture : <any>null;
        data["cleanStay"] = this.cleanStay !== undefined ? this.cleanStay : <any>null;
        data["cleanVacant"] = this.cleanVacant !== undefined ? this.cleanVacant : <any>null;
        data["cleanVacantEveryNumberOfDays"] = this.cleanVacantEveryNumberOfDays !== undefined ? this.cleanVacantEveryNumberOfDays : <any>null;
        data["cleanOutOfService"] = this.cleanOutOfService !== undefined ? this.cleanOutOfService : <any>null;
        data["productsTagsMustBeConsumedOnTime"] = this.productsTagsMustBeConsumedOnTime !== undefined ? this.productsTagsMustBeConsumedOnTime : <any>null;
        data["productsTagsConsumationIntervalFrom"] = this.productsTagsConsumationIntervalFrom ? this.productsTagsConsumationIntervalFrom.toISOString() : <any>null;
        data["productsTagsConsumationIntervalTo"] = this.productsTagsConsumationIntervalTo ? this.productsTagsConsumationIntervalTo.toISOString() : <any>null;
        data["nightsTypeKey"] = this.nightsTypeKey !== undefined ? this.nightsTypeKey : <any>null;
        data["nightsEveryNumberOfDays"] = this.nightsEveryNumberOfDays !== undefined ? this.nightsEveryNumberOfDays : <any>null;
        data["nightsFromKey"] = this.nightsFromKey !== undefined ? this.nightsFromKey : <any>null;
        data["cleanlinessKey"] = this.cleanlinessKey !== undefined ? this.cleanlinessKey : <any>null;
        if (Array.isArray(this.foorIds)) {
            data["foorIds"] = [];
            for (let item of this.foorIds)
                data["foorIds"].push(item);
        }
        if (Array.isArray(this.sections)) {
            data["sections"] = [];
            for (let item of this.sections)
                data["sections"].push(item);
        }
        if (Array.isArray(this.subSections)) {
            data["subSections"] = [];
            for (let item of this.subSections)
                data["subSections"].push(item);
        }
        if (Array.isArray(this.nights)) {
            data["nights"] = [];
            for (let item of this.nights)
                data["nights"].push(item);
        }
        if (Array.isArray(this.reservationSpaceCategories)) {
            data["reservationSpaceCategories"] = [];
            for (let item of this.reservationSpaceCategories)
                data["reservationSpaceCategories"].push(item);
        }
        if (Array.isArray(this.productsTags)) {
            data["productsTags"] = [];
            for (let item of this.productsTags)
                data["productsTags"].push(item);
        }
        if (Array.isArray(this.rooms)) {
            data["rooms"] = [];
            for (let item of this.rooms)
                data["rooms"].push(item.toJSON());
        }
        if (Array.isArray(this.otherProperties)) {
            data["otherProperties"] = [];
            for (let item of this.otherProperties)
                data["otherProperties"].push(item.toJSON());
        }
        if (Array.isArray(this.categories)) {
            data["categories"] = [];
            for (let item of this.categories)
                data["categories"].push(item.toJSON());
        }
        if (Array.isArray(this.productsTagsExtended)) {
            data["productsTagsExtended"] = [];
            for (let item of this.productsTagsExtended)
                data["productsTagsExtended"].push(item.toJSON());
        }
        if (Array.isArray(this.otherPropertiesExtended)) {
            data["otherPropertiesExtended"] = [];
            for (let item of this.otherPropertiesExtended)
                data["otherPropertiesExtended"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICleaningPluginDetailsBasedOnData {
    id?: string | null;
    name?: string | null;
    key?: string | null;
    description?: string | null;
    cleanDeparture?: boolean | null;
    cleanStay?: boolean | null;
    cleanVacant?: boolean | null;
    cleanVacantEveryNumberOfDays?: number | null;
    cleanOutOfService?: boolean | null;
    productsTagsMustBeConsumedOnTime?: boolean | null;
    productsTagsConsumationIntervalFrom?: moment.Moment | null;
    productsTagsConsumationIntervalTo?: moment.Moment | null;
    nightsTypeKey?: string | null;
    nightsEveryNumberOfDays?: number | null;
    nightsFromKey?: string | null;
    cleanlinessKey?: string | null;
    foorIds?: string[] | null;
    sections?: string[] | null;
    subSections?: string[] | null;
    nights?: number[] | null;
    reservationSpaceCategories?: string[] | null;
    productsTags?: string[] | null;
    rooms?: HotelRoomCreditsData[] | null;
    otherProperties?: KeyValue[] | null;
    categories?: CleaningPluginDetailsBasedOnRoomCategoryData[] | null;
    productsTagsExtended?: CleaningPluginDetailsBasedOnProdutsTagsExtendedData[] | null;
    otherPropertiesExtended?: CleaningPluginDetailsBasedOnOtherPropertiesExtendedData[] | null;
}

export class HotelRoomCreditsData implements IHotelRoomCreditsData {
    roomId!: string;
    credits?: number | null;

    constructor(data?: IHotelRoomCreditsData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roomId = _data["roomId"] !== undefined ? _data["roomId"] : <any>null;
            this.credits = _data["credits"] !== undefined ? _data["credits"] : <any>null;
        }
    }

    static fromJS(data: any): HotelRoomCreditsData {
        data = typeof data === 'object' ? data : {};
        let result = new HotelRoomCreditsData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roomId"] = this.roomId !== undefined ? this.roomId : <any>null;
        data["credits"] = this.credits !== undefined ? this.credits : <any>null;
        return data; 
    }
}

export interface IHotelRoomCreditsData {
    roomId: string;
    credits?: number | null;
}

export class KeyValue implements IKeyValue {
    key?: string | null;
    value?: string | null;

    constructor(data?: IKeyValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"] !== undefined ? _data["key"] : <any>null;
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
        }
    }

    static fromJS(data: any): KeyValue {
        data = typeof data === 'object' ? data : {};
        let result = new KeyValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key !== undefined ? this.key : <any>null;
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data; 
    }
}

export interface IKeyValue {
    key?: string | null;
    value?: string | null;
}

export class CleaningPluginDetailsBasedOnRoomCategoryData implements ICleaningPluginDetailsBasedOnRoomCategoryData {
    categoryId!: string;
    isSelected!: boolean;
    credits!: number;

    constructor(data?: ICleaningPluginDetailsBasedOnRoomCategoryData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.categoryId = _data["categoryId"] !== undefined ? _data["categoryId"] : <any>null;
            this.isSelected = _data["isSelected"] !== undefined ? _data["isSelected"] : <any>null;
            this.credits = _data["credits"] !== undefined ? _data["credits"] : <any>null;
        }
    }

    static fromJS(data: any): CleaningPluginDetailsBasedOnRoomCategoryData {
        data = typeof data === 'object' ? data : {};
        let result = new CleaningPluginDetailsBasedOnRoomCategoryData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryId"] = this.categoryId !== undefined ? this.categoryId : <any>null;
        data["isSelected"] = this.isSelected !== undefined ? this.isSelected : <any>null;
        data["credits"] = this.credits !== undefined ? this.credits : <any>null;
        return data; 
    }
}

export interface ICleaningPluginDetailsBasedOnRoomCategoryData {
    categoryId: string;
    isSelected: boolean;
    credits: number;
}

export class CleaningPluginDetailsBasedOnProdutsTagsExtendedData implements ICleaningPluginDetailsBasedOnProdutsTagsExtendedData {
    basedOnProductsTagsTypeKey?: string | null;
    isCaseSensitive!: boolean;
    comparisonValue?: string | null;
    productId?: string | null;

    constructor(data?: ICleaningPluginDetailsBasedOnProdutsTagsExtendedData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.basedOnProductsTagsTypeKey = _data["basedOnProductsTagsTypeKey"] !== undefined ? _data["basedOnProductsTagsTypeKey"] : <any>null;
            this.isCaseSensitive = _data["isCaseSensitive"] !== undefined ? _data["isCaseSensitive"] : <any>null;
            this.comparisonValue = _data["comparisonValue"] !== undefined ? _data["comparisonValue"] : <any>null;
            this.productId = _data["productId"] !== undefined ? _data["productId"] : <any>null;
        }
    }

    static fromJS(data: any): CleaningPluginDetailsBasedOnProdutsTagsExtendedData {
        data = typeof data === 'object' ? data : {};
        let result = new CleaningPluginDetailsBasedOnProdutsTagsExtendedData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["basedOnProductsTagsTypeKey"] = this.basedOnProductsTagsTypeKey !== undefined ? this.basedOnProductsTagsTypeKey : <any>null;
        data["isCaseSensitive"] = this.isCaseSensitive !== undefined ? this.isCaseSensitive : <any>null;
        data["comparisonValue"] = this.comparisonValue !== undefined ? this.comparisonValue : <any>null;
        data["productId"] = this.productId !== undefined ? this.productId : <any>null;
        return data; 
    }
}

export interface ICleaningPluginDetailsBasedOnProdutsTagsExtendedData {
    basedOnProductsTagsTypeKey?: string | null;
    isCaseSensitive: boolean;
    comparisonValue?: string | null;
    productId?: string | null;
}

export class CleaningPluginDetailsBasedOnOtherPropertiesExtendedData implements ICleaningPluginDetailsBasedOnOtherPropertiesExtendedData {
    basedOnOtherPropertiesTypeKey?: string | null;
    key?: string | null;
    value?: string | null;

    constructor(data?: ICleaningPluginDetailsBasedOnOtherPropertiesExtendedData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.basedOnOtherPropertiesTypeKey = _data["basedOnOtherPropertiesTypeKey"] !== undefined ? _data["basedOnOtherPropertiesTypeKey"] : <any>null;
            this.key = _data["key"] !== undefined ? _data["key"] : <any>null;
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
        }
    }

    static fromJS(data: any): CleaningPluginDetailsBasedOnOtherPropertiesExtendedData {
        data = typeof data === 'object' ? data : {};
        let result = new CleaningPluginDetailsBasedOnOtherPropertiesExtendedData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["basedOnOtherPropertiesTypeKey"] = this.basedOnOtherPropertiesTypeKey !== undefined ? this.basedOnOtherPropertiesTypeKey : <any>null;
        data["key"] = this.key !== undefined ? this.key : <any>null;
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data; 
    }
}

export interface ICleaningPluginDetailsBasedOnOtherPropertiesExtendedData {
    basedOnOtherPropertiesTypeKey?: string | null;
    key?: string | null;
    value?: string | null;
}

export class GetCleaningPluginDetailsQuery implements IGetCleaningPluginDetailsQuery {
    id!: string;

    constructor(data?: IGetCleaningPluginDetailsQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
        }
    }

    static fromJS(data: any): GetCleaningPluginDetailsQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetCleaningPluginDetailsQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        return data; 
    }
}

export interface IGetCleaningPluginDetailsQuery {
    id: string;
}

export class InsertCleaningPluginCommand implements IInsertCleaningPluginCommand {
    data?: InsertCleaningPluginData | null;

    constructor(data?: IInsertCleaningPluginCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? InsertCleaningPluginData.fromJS(_data["data"]) : <any>null;
        }
    }

    static fromJS(data: any): InsertCleaningPluginCommand {
        data = typeof data === 'object' ? data : {};
        let result = new InsertCleaningPluginCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        return data; 
    }
}

export interface IInsertCleaningPluginCommand {
    data?: InsertCleaningPluginData | null;
}

export class InsertCleaningPluginData implements IInsertCleaningPluginData {
    isActive!: boolean;
    hotelId?: string | null;
    ordinalNumber!: number;
    periodicalIntervals?: SavePeriodicalIntervalData[] | null;
    periodicalPostponeSundayCleaningsToMonday?: boolean | null;
    changeSheets!: boolean;
    isNightlyCleaningPlugin!: boolean;
    cleanOnHolidays!: boolean;
    cleanOnSaturday!: boolean;
    cleanOnSunday!: boolean;
    color?: string | null;
    dailyCleaningTypeTimes?: string[] | null;
    dailyCleaningTimeTypeKey?: string | null;
    displayStyleKey?: string | null;
    instructions?: string | null;
    isTopRule!: boolean;
    monthlyCleaningTypeTimeOfMonthKey?: string | null;
    name?: string | null;
    postponeUntilVacant!: boolean;
    startsCleaningAfter?: number | null;
    typeKey?: string | null;
    weekBasedCleaningTypeWeeks?: number[] | null;
    weeklyCleanOnMonday?: boolean | null;
    weeklyCleanOnTuesday?: boolean | null;
    weeklyCleanOnWednesday?: boolean | null;
    weeklyCleanOnThursday?: boolean | null;
    weeklyCleanOnFriday?: boolean | null;
    weeklyCleanOnSaturday?: boolean | null;
    weeklyCleanOnSunday?: boolean | null;
    weeklyCleaningTypeMondayTimes?: string[] | null;
    weeklyCleaningTypeTuesdayTimes?: string[] | null;
    weeklyCleaningTypeWednesdayTimes?: string[] | null;
    weeklyCleaningTypeThursdayTimes?: string[] | null;
    weeklyCleaningTypeFridayTimes?: string[] | null;
    weeklyCleaningTypeSaturdayTimes?: string[] | null;
    weeklyCleaningTypeSundayTimes?: string[] | null;
    weeklyTimeMondayTypeKey?: string | null;
    weeklyTimeTuesdayTypeKey?: string | null;
    weeklyTimeWednesdayTypeKey?: string | null;
    weeklyTimeThursdayTypeKey?: string | null;
    weeklyTimeFridayTypeKey?: string | null;
    weeklyTimeSaturdayTypeKey?: string | null;
    weeklyTimeSundayTypeKey?: string | null;
    weekBasedCleaningDayOfTheWeekKey?: string | null;
    basedOns?: SaveBasedOnData[] | null;

    constructor(data?: IInsertCleaningPluginData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isActive = _data["isActive"] !== undefined ? _data["isActive"] : <any>null;
            this.hotelId = _data["hotelId"] !== undefined ? _data["hotelId"] : <any>null;
            this.ordinalNumber = _data["ordinalNumber"] !== undefined ? _data["ordinalNumber"] : <any>null;
            if (Array.isArray(_data["periodicalIntervals"])) {
                this.periodicalIntervals = [] as any;
                for (let item of _data["periodicalIntervals"])
                    this.periodicalIntervals!.push(SavePeriodicalIntervalData.fromJS(item));
            }
            this.periodicalPostponeSundayCleaningsToMonday = _data["periodicalPostponeSundayCleaningsToMonday"] !== undefined ? _data["periodicalPostponeSundayCleaningsToMonday"] : <any>null;
            this.changeSheets = _data["changeSheets"] !== undefined ? _data["changeSheets"] : <any>null;
            this.isNightlyCleaningPlugin = _data["isNightlyCleaningPlugin"] !== undefined ? _data["isNightlyCleaningPlugin"] : <any>null;
            this.cleanOnHolidays = _data["cleanOnHolidays"] !== undefined ? _data["cleanOnHolidays"] : <any>null;
            this.cleanOnSaturday = _data["cleanOnSaturday"] !== undefined ? _data["cleanOnSaturday"] : <any>null;
            this.cleanOnSunday = _data["cleanOnSunday"] !== undefined ? _data["cleanOnSunday"] : <any>null;
            this.color = _data["color"] !== undefined ? _data["color"] : <any>null;
            if (Array.isArray(_data["dailyCleaningTypeTimes"])) {
                this.dailyCleaningTypeTimes = [] as any;
                for (let item of _data["dailyCleaningTypeTimes"])
                    this.dailyCleaningTypeTimes!.push(item);
            }
            this.dailyCleaningTimeTypeKey = _data["dailyCleaningTimeTypeKey"] !== undefined ? _data["dailyCleaningTimeTypeKey"] : <any>null;
            this.displayStyleKey = _data["displayStyleKey"] !== undefined ? _data["displayStyleKey"] : <any>null;
            this.instructions = _data["instructions"] !== undefined ? _data["instructions"] : <any>null;
            this.isTopRule = _data["isTopRule"] !== undefined ? _data["isTopRule"] : <any>null;
            this.monthlyCleaningTypeTimeOfMonthKey = _data["monthlyCleaningTypeTimeOfMonthKey"] !== undefined ? _data["monthlyCleaningTypeTimeOfMonthKey"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.postponeUntilVacant = _data["postponeUntilVacant"] !== undefined ? _data["postponeUntilVacant"] : <any>null;
            this.startsCleaningAfter = _data["startsCleaningAfter"] !== undefined ? _data["startsCleaningAfter"] : <any>null;
            this.typeKey = _data["typeKey"] !== undefined ? _data["typeKey"] : <any>null;
            if (Array.isArray(_data["weekBasedCleaningTypeWeeks"])) {
                this.weekBasedCleaningTypeWeeks = [] as any;
                for (let item of _data["weekBasedCleaningTypeWeeks"])
                    this.weekBasedCleaningTypeWeeks!.push(item);
            }
            this.weeklyCleanOnMonday = _data["weeklyCleanOnMonday"] !== undefined ? _data["weeklyCleanOnMonday"] : <any>null;
            this.weeklyCleanOnTuesday = _data["weeklyCleanOnTuesday"] !== undefined ? _data["weeklyCleanOnTuesday"] : <any>null;
            this.weeklyCleanOnWednesday = _data["weeklyCleanOnWednesday"] !== undefined ? _data["weeklyCleanOnWednesday"] : <any>null;
            this.weeklyCleanOnThursday = _data["weeklyCleanOnThursday"] !== undefined ? _data["weeklyCleanOnThursday"] : <any>null;
            this.weeklyCleanOnFriday = _data["weeklyCleanOnFriday"] !== undefined ? _data["weeklyCleanOnFriday"] : <any>null;
            this.weeklyCleanOnSaturday = _data["weeklyCleanOnSaturday"] !== undefined ? _data["weeklyCleanOnSaturday"] : <any>null;
            this.weeklyCleanOnSunday = _data["weeklyCleanOnSunday"] !== undefined ? _data["weeklyCleanOnSunday"] : <any>null;
            if (Array.isArray(_data["weeklyCleaningTypeMondayTimes"])) {
                this.weeklyCleaningTypeMondayTimes = [] as any;
                for (let item of _data["weeklyCleaningTypeMondayTimes"])
                    this.weeklyCleaningTypeMondayTimes!.push(item);
            }
            if (Array.isArray(_data["weeklyCleaningTypeTuesdayTimes"])) {
                this.weeklyCleaningTypeTuesdayTimes = [] as any;
                for (let item of _data["weeklyCleaningTypeTuesdayTimes"])
                    this.weeklyCleaningTypeTuesdayTimes!.push(item);
            }
            if (Array.isArray(_data["weeklyCleaningTypeWednesdayTimes"])) {
                this.weeklyCleaningTypeWednesdayTimes = [] as any;
                for (let item of _data["weeklyCleaningTypeWednesdayTimes"])
                    this.weeklyCleaningTypeWednesdayTimes!.push(item);
            }
            if (Array.isArray(_data["weeklyCleaningTypeThursdayTimes"])) {
                this.weeklyCleaningTypeThursdayTimes = [] as any;
                for (let item of _data["weeklyCleaningTypeThursdayTimes"])
                    this.weeklyCleaningTypeThursdayTimes!.push(item);
            }
            if (Array.isArray(_data["weeklyCleaningTypeFridayTimes"])) {
                this.weeklyCleaningTypeFridayTimes = [] as any;
                for (let item of _data["weeklyCleaningTypeFridayTimes"])
                    this.weeklyCleaningTypeFridayTimes!.push(item);
            }
            if (Array.isArray(_data["weeklyCleaningTypeSaturdayTimes"])) {
                this.weeklyCleaningTypeSaturdayTimes = [] as any;
                for (let item of _data["weeklyCleaningTypeSaturdayTimes"])
                    this.weeklyCleaningTypeSaturdayTimes!.push(item);
            }
            if (Array.isArray(_data["weeklyCleaningTypeSundayTimes"])) {
                this.weeklyCleaningTypeSundayTimes = [] as any;
                for (let item of _data["weeklyCleaningTypeSundayTimes"])
                    this.weeklyCleaningTypeSundayTimes!.push(item);
            }
            this.weeklyTimeMondayTypeKey = _data["weeklyTimeMondayTypeKey"] !== undefined ? _data["weeklyTimeMondayTypeKey"] : <any>null;
            this.weeklyTimeTuesdayTypeKey = _data["weeklyTimeTuesdayTypeKey"] !== undefined ? _data["weeklyTimeTuesdayTypeKey"] : <any>null;
            this.weeklyTimeWednesdayTypeKey = _data["weeklyTimeWednesdayTypeKey"] !== undefined ? _data["weeklyTimeWednesdayTypeKey"] : <any>null;
            this.weeklyTimeThursdayTypeKey = _data["weeklyTimeThursdayTypeKey"] !== undefined ? _data["weeklyTimeThursdayTypeKey"] : <any>null;
            this.weeklyTimeFridayTypeKey = _data["weeklyTimeFridayTypeKey"] !== undefined ? _data["weeklyTimeFridayTypeKey"] : <any>null;
            this.weeklyTimeSaturdayTypeKey = _data["weeklyTimeSaturdayTypeKey"] !== undefined ? _data["weeklyTimeSaturdayTypeKey"] : <any>null;
            this.weeklyTimeSundayTypeKey = _data["weeklyTimeSundayTypeKey"] !== undefined ? _data["weeklyTimeSundayTypeKey"] : <any>null;
            this.weekBasedCleaningDayOfTheWeekKey = _data["weekBasedCleaningDayOfTheWeekKey"] !== undefined ? _data["weekBasedCleaningDayOfTheWeekKey"] : <any>null;
            if (Array.isArray(_data["basedOns"])) {
                this.basedOns = [] as any;
                for (let item of _data["basedOns"])
                    this.basedOns!.push(SaveBasedOnData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InsertCleaningPluginData {
        data = typeof data === 'object' ? data : {};
        let result = new InsertCleaningPluginData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isActive"] = this.isActive !== undefined ? this.isActive : <any>null;
        data["hotelId"] = this.hotelId !== undefined ? this.hotelId : <any>null;
        data["ordinalNumber"] = this.ordinalNumber !== undefined ? this.ordinalNumber : <any>null;
        if (Array.isArray(this.periodicalIntervals)) {
            data["periodicalIntervals"] = [];
            for (let item of this.periodicalIntervals)
                data["periodicalIntervals"].push(item.toJSON());
        }
        data["periodicalPostponeSundayCleaningsToMonday"] = this.periodicalPostponeSundayCleaningsToMonday !== undefined ? this.periodicalPostponeSundayCleaningsToMonday : <any>null;
        data["changeSheets"] = this.changeSheets !== undefined ? this.changeSheets : <any>null;
        data["isNightlyCleaningPlugin"] = this.isNightlyCleaningPlugin !== undefined ? this.isNightlyCleaningPlugin : <any>null;
        data["cleanOnHolidays"] = this.cleanOnHolidays !== undefined ? this.cleanOnHolidays : <any>null;
        data["cleanOnSaturday"] = this.cleanOnSaturday !== undefined ? this.cleanOnSaturday : <any>null;
        data["cleanOnSunday"] = this.cleanOnSunday !== undefined ? this.cleanOnSunday : <any>null;
        data["color"] = this.color !== undefined ? this.color : <any>null;
        if (Array.isArray(this.dailyCleaningTypeTimes)) {
            data["dailyCleaningTypeTimes"] = [];
            for (let item of this.dailyCleaningTypeTimes)
                data["dailyCleaningTypeTimes"].push(item);
        }
        data["dailyCleaningTimeTypeKey"] = this.dailyCleaningTimeTypeKey !== undefined ? this.dailyCleaningTimeTypeKey : <any>null;
        data["displayStyleKey"] = this.displayStyleKey !== undefined ? this.displayStyleKey : <any>null;
        data["instructions"] = this.instructions !== undefined ? this.instructions : <any>null;
        data["isTopRule"] = this.isTopRule !== undefined ? this.isTopRule : <any>null;
        data["monthlyCleaningTypeTimeOfMonthKey"] = this.monthlyCleaningTypeTimeOfMonthKey !== undefined ? this.monthlyCleaningTypeTimeOfMonthKey : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["postponeUntilVacant"] = this.postponeUntilVacant !== undefined ? this.postponeUntilVacant : <any>null;
        data["startsCleaningAfter"] = this.startsCleaningAfter !== undefined ? this.startsCleaningAfter : <any>null;
        data["typeKey"] = this.typeKey !== undefined ? this.typeKey : <any>null;
        if (Array.isArray(this.weekBasedCleaningTypeWeeks)) {
            data["weekBasedCleaningTypeWeeks"] = [];
            for (let item of this.weekBasedCleaningTypeWeeks)
                data["weekBasedCleaningTypeWeeks"].push(item);
        }
        data["weeklyCleanOnMonday"] = this.weeklyCleanOnMonday !== undefined ? this.weeklyCleanOnMonday : <any>null;
        data["weeklyCleanOnTuesday"] = this.weeklyCleanOnTuesday !== undefined ? this.weeklyCleanOnTuesday : <any>null;
        data["weeklyCleanOnWednesday"] = this.weeklyCleanOnWednesday !== undefined ? this.weeklyCleanOnWednesday : <any>null;
        data["weeklyCleanOnThursday"] = this.weeklyCleanOnThursday !== undefined ? this.weeklyCleanOnThursday : <any>null;
        data["weeklyCleanOnFriday"] = this.weeklyCleanOnFriday !== undefined ? this.weeklyCleanOnFriday : <any>null;
        data["weeklyCleanOnSaturday"] = this.weeklyCleanOnSaturday !== undefined ? this.weeklyCleanOnSaturday : <any>null;
        data["weeklyCleanOnSunday"] = this.weeklyCleanOnSunday !== undefined ? this.weeklyCleanOnSunday : <any>null;
        if (Array.isArray(this.weeklyCleaningTypeMondayTimes)) {
            data["weeklyCleaningTypeMondayTimes"] = [];
            for (let item of this.weeklyCleaningTypeMondayTimes)
                data["weeklyCleaningTypeMondayTimes"].push(item);
        }
        if (Array.isArray(this.weeklyCleaningTypeTuesdayTimes)) {
            data["weeklyCleaningTypeTuesdayTimes"] = [];
            for (let item of this.weeklyCleaningTypeTuesdayTimes)
                data["weeklyCleaningTypeTuesdayTimes"].push(item);
        }
        if (Array.isArray(this.weeklyCleaningTypeWednesdayTimes)) {
            data["weeklyCleaningTypeWednesdayTimes"] = [];
            for (let item of this.weeklyCleaningTypeWednesdayTimes)
                data["weeklyCleaningTypeWednesdayTimes"].push(item);
        }
        if (Array.isArray(this.weeklyCleaningTypeThursdayTimes)) {
            data["weeklyCleaningTypeThursdayTimes"] = [];
            for (let item of this.weeklyCleaningTypeThursdayTimes)
                data["weeklyCleaningTypeThursdayTimes"].push(item);
        }
        if (Array.isArray(this.weeklyCleaningTypeFridayTimes)) {
            data["weeklyCleaningTypeFridayTimes"] = [];
            for (let item of this.weeklyCleaningTypeFridayTimes)
                data["weeklyCleaningTypeFridayTimes"].push(item);
        }
        if (Array.isArray(this.weeklyCleaningTypeSaturdayTimes)) {
            data["weeklyCleaningTypeSaturdayTimes"] = [];
            for (let item of this.weeklyCleaningTypeSaturdayTimes)
                data["weeklyCleaningTypeSaturdayTimes"].push(item);
        }
        if (Array.isArray(this.weeklyCleaningTypeSundayTimes)) {
            data["weeklyCleaningTypeSundayTimes"] = [];
            for (let item of this.weeklyCleaningTypeSundayTimes)
                data["weeklyCleaningTypeSundayTimes"].push(item);
        }
        data["weeklyTimeMondayTypeKey"] = this.weeklyTimeMondayTypeKey !== undefined ? this.weeklyTimeMondayTypeKey : <any>null;
        data["weeklyTimeTuesdayTypeKey"] = this.weeklyTimeTuesdayTypeKey !== undefined ? this.weeklyTimeTuesdayTypeKey : <any>null;
        data["weeklyTimeWednesdayTypeKey"] = this.weeklyTimeWednesdayTypeKey !== undefined ? this.weeklyTimeWednesdayTypeKey : <any>null;
        data["weeklyTimeThursdayTypeKey"] = this.weeklyTimeThursdayTypeKey !== undefined ? this.weeklyTimeThursdayTypeKey : <any>null;
        data["weeklyTimeFridayTypeKey"] = this.weeklyTimeFridayTypeKey !== undefined ? this.weeklyTimeFridayTypeKey : <any>null;
        data["weeklyTimeSaturdayTypeKey"] = this.weeklyTimeSaturdayTypeKey !== undefined ? this.weeklyTimeSaturdayTypeKey : <any>null;
        data["weeklyTimeSundayTypeKey"] = this.weeklyTimeSundayTypeKey !== undefined ? this.weeklyTimeSundayTypeKey : <any>null;
        data["weekBasedCleaningDayOfTheWeekKey"] = this.weekBasedCleaningDayOfTheWeekKey !== undefined ? this.weekBasedCleaningDayOfTheWeekKey : <any>null;
        if (Array.isArray(this.basedOns)) {
            data["basedOns"] = [];
            for (let item of this.basedOns)
                data["basedOns"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IInsertCleaningPluginData {
    isActive: boolean;
    hotelId?: string | null;
    ordinalNumber: number;
    periodicalIntervals?: SavePeriodicalIntervalData[] | null;
    periodicalPostponeSundayCleaningsToMonday?: boolean | null;
    changeSheets: boolean;
    isNightlyCleaningPlugin: boolean;
    cleanOnHolidays: boolean;
    cleanOnSaturday: boolean;
    cleanOnSunday: boolean;
    color?: string | null;
    dailyCleaningTypeTimes?: string[] | null;
    dailyCleaningTimeTypeKey?: string | null;
    displayStyleKey?: string | null;
    instructions?: string | null;
    isTopRule: boolean;
    monthlyCleaningTypeTimeOfMonthKey?: string | null;
    name?: string | null;
    postponeUntilVacant: boolean;
    startsCleaningAfter?: number | null;
    typeKey?: string | null;
    weekBasedCleaningTypeWeeks?: number[] | null;
    weeklyCleanOnMonday?: boolean | null;
    weeklyCleanOnTuesday?: boolean | null;
    weeklyCleanOnWednesday?: boolean | null;
    weeklyCleanOnThursday?: boolean | null;
    weeklyCleanOnFriday?: boolean | null;
    weeklyCleanOnSaturday?: boolean | null;
    weeklyCleanOnSunday?: boolean | null;
    weeklyCleaningTypeMondayTimes?: string[] | null;
    weeklyCleaningTypeTuesdayTimes?: string[] | null;
    weeklyCleaningTypeWednesdayTimes?: string[] | null;
    weeklyCleaningTypeThursdayTimes?: string[] | null;
    weeklyCleaningTypeFridayTimes?: string[] | null;
    weeklyCleaningTypeSaturdayTimes?: string[] | null;
    weeklyCleaningTypeSundayTimes?: string[] | null;
    weeklyTimeMondayTypeKey?: string | null;
    weeklyTimeTuesdayTypeKey?: string | null;
    weeklyTimeWednesdayTypeKey?: string | null;
    weeklyTimeThursdayTypeKey?: string | null;
    weeklyTimeFridayTypeKey?: string | null;
    weeklyTimeSaturdayTypeKey?: string | null;
    weeklyTimeSundayTypeKey?: string | null;
    weekBasedCleaningDayOfTheWeekKey?: string | null;
    basedOns?: SaveBasedOnData[] | null;
}

export class SavePeriodicalIntervalData implements ISavePeriodicalIntervalData {
    numberOfCleanings!: number;
    everyNumberOfDays!: number;
    fromNights!: number;
    toNights!: number;
    fromDayKey?: string | null;
    periodTypeKey?: string | null;
    intervalTypeKey?: string | null;

    constructor(data?: ISavePeriodicalIntervalData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.numberOfCleanings = _data["numberOfCleanings"] !== undefined ? _data["numberOfCleanings"] : <any>null;
            this.everyNumberOfDays = _data["everyNumberOfDays"] !== undefined ? _data["everyNumberOfDays"] : <any>null;
            this.fromNights = _data["fromNights"] !== undefined ? _data["fromNights"] : <any>null;
            this.toNights = _data["toNights"] !== undefined ? _data["toNights"] : <any>null;
            this.fromDayKey = _data["fromDayKey"] !== undefined ? _data["fromDayKey"] : <any>null;
            this.periodTypeKey = _data["periodTypeKey"] !== undefined ? _data["periodTypeKey"] : <any>null;
            this.intervalTypeKey = _data["intervalTypeKey"] !== undefined ? _data["intervalTypeKey"] : <any>null;
        }
    }

    static fromJS(data: any): SavePeriodicalIntervalData {
        data = typeof data === 'object' ? data : {};
        let result = new SavePeriodicalIntervalData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["numberOfCleanings"] = this.numberOfCleanings !== undefined ? this.numberOfCleanings : <any>null;
        data["everyNumberOfDays"] = this.everyNumberOfDays !== undefined ? this.everyNumberOfDays : <any>null;
        data["fromNights"] = this.fromNights !== undefined ? this.fromNights : <any>null;
        data["toNights"] = this.toNights !== undefined ? this.toNights : <any>null;
        data["fromDayKey"] = this.fromDayKey !== undefined ? this.fromDayKey : <any>null;
        data["periodTypeKey"] = this.periodTypeKey !== undefined ? this.periodTypeKey : <any>null;
        data["intervalTypeKey"] = this.intervalTypeKey !== undefined ? this.intervalTypeKey : <any>null;
        return data; 
    }
}

export interface ISavePeriodicalIntervalData {
    numberOfCleanings: number;
    everyNumberOfDays: number;
    fromNights: number;
    toNights: number;
    fromDayKey?: string | null;
    periodTypeKey?: string | null;
    intervalTypeKey?: string | null;
}

export class SaveBasedOnData implements ISaveBasedOnData {
    id?: string | null;
    name?: string | null;
    key?: string | null;
    description?: string | null;
    cleanDeparture?: boolean | null;
    cleanStay?: boolean | null;
    cleanVacant?: boolean | null;
    cleanVacantEveryNumberOfDays?: number | null;
    cleanOutOfService?: boolean | null;
    productsTagsMustBeConsumedOnTime?: boolean | null;
    productsTagsConsumationIntervalFrom?: moment.Moment | null;
    productsTagsConsumationIntervalTo?: moment.Moment | null;
    nightsTypeKey?: string | null;
    nightsEveryNumberOfDays?: number | null;
    nightsFromKey?: string | null;
    cleanlinessKey?: string | null;
    foorIds?: string[] | null;
    sections?: string[] | null;
    subSections?: string[] | null;
    nights?: number[] | null;
    reservationSpaceCategories?: string[] | null;
    productsTags?: string[] | null;
    rooms?: HotelRoomCreditsData[] | null;
    otherProperties?: KeyValue[] | null;
    categories?: SaveBasedOnRoomCategory[] | null;
    productsTagsExtended?: SaveBasedOnProductsTags[] | null;
    otherPropertiesExtended?: SaveBasedOnOtherProperties[] | null;

    constructor(data?: ISaveBasedOnData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.key = _data["key"] !== undefined ? _data["key"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.cleanDeparture = _data["cleanDeparture"] !== undefined ? _data["cleanDeparture"] : <any>null;
            this.cleanStay = _data["cleanStay"] !== undefined ? _data["cleanStay"] : <any>null;
            this.cleanVacant = _data["cleanVacant"] !== undefined ? _data["cleanVacant"] : <any>null;
            this.cleanVacantEveryNumberOfDays = _data["cleanVacantEveryNumberOfDays"] !== undefined ? _data["cleanVacantEveryNumberOfDays"] : <any>null;
            this.cleanOutOfService = _data["cleanOutOfService"] !== undefined ? _data["cleanOutOfService"] : <any>null;
            this.productsTagsMustBeConsumedOnTime = _data["productsTagsMustBeConsumedOnTime"] !== undefined ? _data["productsTagsMustBeConsumedOnTime"] : <any>null;
            this.productsTagsConsumationIntervalFrom = _data["productsTagsConsumationIntervalFrom"] ? moment(_data["productsTagsConsumationIntervalFrom"].toString()) : <any>null;
            this.productsTagsConsumationIntervalTo = _data["productsTagsConsumationIntervalTo"] ? moment(_data["productsTagsConsumationIntervalTo"].toString()) : <any>null;
            this.nightsTypeKey = _data["nightsTypeKey"] !== undefined ? _data["nightsTypeKey"] : <any>null;
            this.nightsEveryNumberOfDays = _data["nightsEveryNumberOfDays"] !== undefined ? _data["nightsEveryNumberOfDays"] : <any>null;
            this.nightsFromKey = _data["nightsFromKey"] !== undefined ? _data["nightsFromKey"] : <any>null;
            this.cleanlinessKey = _data["cleanlinessKey"] !== undefined ? _data["cleanlinessKey"] : <any>null;
            if (Array.isArray(_data["foorIds"])) {
                this.foorIds = [] as any;
                for (let item of _data["foorIds"])
                    this.foorIds!.push(item);
            }
            if (Array.isArray(_data["sections"])) {
                this.sections = [] as any;
                for (let item of _data["sections"])
                    this.sections!.push(item);
            }
            if (Array.isArray(_data["subSections"])) {
                this.subSections = [] as any;
                for (let item of _data["subSections"])
                    this.subSections!.push(item);
            }
            if (Array.isArray(_data["nights"])) {
                this.nights = [] as any;
                for (let item of _data["nights"])
                    this.nights!.push(item);
            }
            if (Array.isArray(_data["reservationSpaceCategories"])) {
                this.reservationSpaceCategories = [] as any;
                for (let item of _data["reservationSpaceCategories"])
                    this.reservationSpaceCategories!.push(item);
            }
            if (Array.isArray(_data["productsTags"])) {
                this.productsTags = [] as any;
                for (let item of _data["productsTags"])
                    this.productsTags!.push(item);
            }
            if (Array.isArray(_data["rooms"])) {
                this.rooms = [] as any;
                for (let item of _data["rooms"])
                    this.rooms!.push(HotelRoomCreditsData.fromJS(item));
            }
            if (Array.isArray(_data["otherProperties"])) {
                this.otherProperties = [] as any;
                for (let item of _data["otherProperties"])
                    this.otherProperties!.push(KeyValue.fromJS(item));
            }
            if (Array.isArray(_data["categories"])) {
                this.categories = [] as any;
                for (let item of _data["categories"])
                    this.categories!.push(SaveBasedOnRoomCategory.fromJS(item));
            }
            if (Array.isArray(_data["productsTagsExtended"])) {
                this.productsTagsExtended = [] as any;
                for (let item of _data["productsTagsExtended"])
                    this.productsTagsExtended!.push(SaveBasedOnProductsTags.fromJS(item));
            }
            if (Array.isArray(_data["otherPropertiesExtended"])) {
                this.otherPropertiesExtended = [] as any;
                for (let item of _data["otherPropertiesExtended"])
                    this.otherPropertiesExtended!.push(SaveBasedOnOtherProperties.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SaveBasedOnData {
        data = typeof data === 'object' ? data : {};
        let result = new SaveBasedOnData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["key"] = this.key !== undefined ? this.key : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["cleanDeparture"] = this.cleanDeparture !== undefined ? this.cleanDeparture : <any>null;
        data["cleanStay"] = this.cleanStay !== undefined ? this.cleanStay : <any>null;
        data["cleanVacant"] = this.cleanVacant !== undefined ? this.cleanVacant : <any>null;
        data["cleanVacantEveryNumberOfDays"] = this.cleanVacantEveryNumberOfDays !== undefined ? this.cleanVacantEveryNumberOfDays : <any>null;
        data["cleanOutOfService"] = this.cleanOutOfService !== undefined ? this.cleanOutOfService : <any>null;
        data["productsTagsMustBeConsumedOnTime"] = this.productsTagsMustBeConsumedOnTime !== undefined ? this.productsTagsMustBeConsumedOnTime : <any>null;
        data["productsTagsConsumationIntervalFrom"] = this.productsTagsConsumationIntervalFrom ? this.productsTagsConsumationIntervalFrom.toISOString() : <any>null;
        data["productsTagsConsumationIntervalTo"] = this.productsTagsConsumationIntervalTo ? this.productsTagsConsumationIntervalTo.toISOString() : <any>null;
        data["nightsTypeKey"] = this.nightsTypeKey !== undefined ? this.nightsTypeKey : <any>null;
        data["nightsEveryNumberOfDays"] = this.nightsEveryNumberOfDays !== undefined ? this.nightsEveryNumberOfDays : <any>null;
        data["nightsFromKey"] = this.nightsFromKey !== undefined ? this.nightsFromKey : <any>null;
        data["cleanlinessKey"] = this.cleanlinessKey !== undefined ? this.cleanlinessKey : <any>null;
        if (Array.isArray(this.foorIds)) {
            data["foorIds"] = [];
            for (let item of this.foorIds)
                data["foorIds"].push(item);
        }
        if (Array.isArray(this.sections)) {
            data["sections"] = [];
            for (let item of this.sections)
                data["sections"].push(item);
        }
        if (Array.isArray(this.subSections)) {
            data["subSections"] = [];
            for (let item of this.subSections)
                data["subSections"].push(item);
        }
        if (Array.isArray(this.nights)) {
            data["nights"] = [];
            for (let item of this.nights)
                data["nights"].push(item);
        }
        if (Array.isArray(this.reservationSpaceCategories)) {
            data["reservationSpaceCategories"] = [];
            for (let item of this.reservationSpaceCategories)
                data["reservationSpaceCategories"].push(item);
        }
        if (Array.isArray(this.productsTags)) {
            data["productsTags"] = [];
            for (let item of this.productsTags)
                data["productsTags"].push(item);
        }
        if (Array.isArray(this.rooms)) {
            data["rooms"] = [];
            for (let item of this.rooms)
                data["rooms"].push(item.toJSON());
        }
        if (Array.isArray(this.otherProperties)) {
            data["otherProperties"] = [];
            for (let item of this.otherProperties)
                data["otherProperties"].push(item.toJSON());
        }
        if (Array.isArray(this.categories)) {
            data["categories"] = [];
            for (let item of this.categories)
                data["categories"].push(item.toJSON());
        }
        if (Array.isArray(this.productsTagsExtended)) {
            data["productsTagsExtended"] = [];
            for (let item of this.productsTagsExtended)
                data["productsTagsExtended"].push(item.toJSON());
        }
        if (Array.isArray(this.otherPropertiesExtended)) {
            data["otherPropertiesExtended"] = [];
            for (let item of this.otherPropertiesExtended)
                data["otherPropertiesExtended"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISaveBasedOnData {
    id?: string | null;
    name?: string | null;
    key?: string | null;
    description?: string | null;
    cleanDeparture?: boolean | null;
    cleanStay?: boolean | null;
    cleanVacant?: boolean | null;
    cleanVacantEveryNumberOfDays?: number | null;
    cleanOutOfService?: boolean | null;
    productsTagsMustBeConsumedOnTime?: boolean | null;
    productsTagsConsumationIntervalFrom?: moment.Moment | null;
    productsTagsConsumationIntervalTo?: moment.Moment | null;
    nightsTypeKey?: string | null;
    nightsEveryNumberOfDays?: number | null;
    nightsFromKey?: string | null;
    cleanlinessKey?: string | null;
    foorIds?: string[] | null;
    sections?: string[] | null;
    subSections?: string[] | null;
    nights?: number[] | null;
    reservationSpaceCategories?: string[] | null;
    productsTags?: string[] | null;
    rooms?: HotelRoomCreditsData[] | null;
    otherProperties?: KeyValue[] | null;
    categories?: SaveBasedOnRoomCategory[] | null;
    productsTagsExtended?: SaveBasedOnProductsTags[] | null;
    otherPropertiesExtended?: SaveBasedOnOtherProperties[] | null;
}

export class SaveBasedOnRoomCategory implements ISaveBasedOnRoomCategory {
    categoryId!: string;
    isSelected!: boolean;
    credits!: number;

    constructor(data?: ISaveBasedOnRoomCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.categoryId = _data["categoryId"] !== undefined ? _data["categoryId"] : <any>null;
            this.isSelected = _data["isSelected"] !== undefined ? _data["isSelected"] : <any>null;
            this.credits = _data["credits"] !== undefined ? _data["credits"] : <any>null;
        }
    }

    static fromJS(data: any): SaveBasedOnRoomCategory {
        data = typeof data === 'object' ? data : {};
        let result = new SaveBasedOnRoomCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryId"] = this.categoryId !== undefined ? this.categoryId : <any>null;
        data["isSelected"] = this.isSelected !== undefined ? this.isSelected : <any>null;
        data["credits"] = this.credits !== undefined ? this.credits : <any>null;
        return data; 
    }
}

export interface ISaveBasedOnRoomCategory {
    categoryId: string;
    isSelected: boolean;
    credits: number;
}

export class SaveBasedOnProductsTags implements ISaveBasedOnProductsTags {
    basedOnProductsTagsTypeKey?: string | null;
    isCaseSensitive!: boolean;
    comparisonValue?: string | null;
    productId?: string | null;

    constructor(data?: ISaveBasedOnProductsTags) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.basedOnProductsTagsTypeKey = _data["basedOnProductsTagsTypeKey"] !== undefined ? _data["basedOnProductsTagsTypeKey"] : <any>null;
            this.isCaseSensitive = _data["isCaseSensitive"] !== undefined ? _data["isCaseSensitive"] : <any>null;
            this.comparisonValue = _data["comparisonValue"] !== undefined ? _data["comparisonValue"] : <any>null;
            this.productId = _data["productId"] !== undefined ? _data["productId"] : <any>null;
        }
    }

    static fromJS(data: any): SaveBasedOnProductsTags {
        data = typeof data === 'object' ? data : {};
        let result = new SaveBasedOnProductsTags();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["basedOnProductsTagsTypeKey"] = this.basedOnProductsTagsTypeKey !== undefined ? this.basedOnProductsTagsTypeKey : <any>null;
        data["isCaseSensitive"] = this.isCaseSensitive !== undefined ? this.isCaseSensitive : <any>null;
        data["comparisonValue"] = this.comparisonValue !== undefined ? this.comparisonValue : <any>null;
        data["productId"] = this.productId !== undefined ? this.productId : <any>null;
        return data; 
    }
}

export interface ISaveBasedOnProductsTags {
    basedOnProductsTagsTypeKey?: string | null;
    isCaseSensitive: boolean;
    comparisonValue?: string | null;
    productId?: string | null;
}

export class SaveBasedOnOtherProperties implements ISaveBasedOnOtherProperties {
    basedOnOtherPropertiesTypeKey?: string | null;
    key?: string | null;
    value?: string | null;

    constructor(data?: ISaveBasedOnOtherProperties) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.basedOnOtherPropertiesTypeKey = _data["basedOnOtherPropertiesTypeKey"] !== undefined ? _data["basedOnOtherPropertiesTypeKey"] : <any>null;
            this.key = _data["key"] !== undefined ? _data["key"] : <any>null;
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
        }
    }

    static fromJS(data: any): SaveBasedOnOtherProperties {
        data = typeof data === 'object' ? data : {};
        let result = new SaveBasedOnOtherProperties();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["basedOnOtherPropertiesTypeKey"] = this.basedOnOtherPropertiesTypeKey !== undefined ? this.basedOnOtherPropertiesTypeKey : <any>null;
        data["key"] = this.key !== undefined ? this.key : <any>null;
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data; 
    }
}

export interface ISaveBasedOnOtherProperties {
    basedOnOtherPropertiesTypeKey?: string | null;
    key?: string | null;
    value?: string | null;
}

export class UpdateCleaningPluginCommand implements IUpdateCleaningPluginCommand {
    data?: UpdateCleaningPluginData | null;

    constructor(data?: IUpdateCleaningPluginCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? UpdateCleaningPluginData.fromJS(_data["data"]) : <any>null;
        }
    }

    static fromJS(data: any): UpdateCleaningPluginCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCleaningPluginCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        return data; 
    }
}

export interface IUpdateCleaningPluginCommand {
    data?: UpdateCleaningPluginData | null;
}

export class UpdateCleaningPluginData extends InsertCleaningPluginData implements IUpdateCleaningPluginData {
    id!: string;

    constructor(data?: IUpdateCleaningPluginData) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
        }
    }

    static fromJS(data: any): UpdateCleaningPluginData {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCleaningPluginData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        super.toJSON(data);
        return data; 
    }
}

export interface IUpdateCleaningPluginData extends IInsertCleaningPluginData {
    id: string;
}

export class DeleteCleaningPluginCommand implements IDeleteCleaningPluginCommand {
    id!: string;

    constructor(data?: IDeleteCleaningPluginCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
        }
    }

    static fromJS(data: any): DeleteCleaningPluginCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteCleaningPluginCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        return data; 
    }
}

export interface IDeleteCleaningPluginCommand {
    id: string;
}

export class UpdatePluginOrderCommand implements IUpdatePluginOrderCommand {
    hotelId?: string | null;
    orderedPluginIds?: UpdatePluginOrderItem[] | null;

    constructor(data?: IUpdatePluginOrderCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hotelId = _data["hotelId"] !== undefined ? _data["hotelId"] : <any>null;
            if (Array.isArray(_data["orderedPluginIds"])) {
                this.orderedPluginIds = [] as any;
                for (let item of _data["orderedPluginIds"])
                    this.orderedPluginIds!.push(UpdatePluginOrderItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdatePluginOrderCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePluginOrderCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hotelId"] = this.hotelId !== undefined ? this.hotelId : <any>null;
        if (Array.isArray(this.orderedPluginIds)) {
            data["orderedPluginIds"] = [];
            for (let item of this.orderedPluginIds)
                data["orderedPluginIds"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUpdatePluginOrderCommand {
    hotelId?: string | null;
    orderedPluginIds?: UpdatePluginOrderItem[] | null;
}

export class UpdatePluginOrderItem implements IUpdatePluginOrderItem {
    pluginId!: string;
    ordinalNumber!: number;

    constructor(data?: IUpdatePluginOrderItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pluginId = _data["pluginId"] !== undefined ? _data["pluginId"] : <any>null;
            this.ordinalNumber = _data["ordinalNumber"] !== undefined ? _data["ordinalNumber"] : <any>null;
        }
    }

    static fromJS(data: any): UpdatePluginOrderItem {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePluginOrderItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pluginId"] = this.pluginId !== undefined ? this.pluginId : <any>null;
        data["ordinalNumber"] = this.ordinalNumber !== undefined ? this.ordinalNumber : <any>null;
        return data; 
    }
}

export interface IUpdatePluginOrderItem {
    pluginId: string;
    ordinalNumber: number;
}

export class PredictionsTesterResult implements IPredictionsTesterResult {
    days?: CalendarDay[] | null;
    rooms?: CleaningCalendarTesterRoom[] | null;
    errorResults?: PredictionsTesterError[] | null;

    constructor(data?: IPredictionsTesterResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["days"])) {
                this.days = [] as any;
                for (let item of _data["days"])
                    this.days!.push(CalendarDay.fromJS(item));
            }
            if (Array.isArray(_data["rooms"])) {
                this.rooms = [] as any;
                for (let item of _data["rooms"])
                    this.rooms!.push(CleaningCalendarTesterRoom.fromJS(item));
            }
            if (Array.isArray(_data["errorResults"])) {
                this.errorResults = [] as any;
                for (let item of _data["errorResults"])
                    this.errorResults!.push(PredictionsTesterError.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PredictionsTesterResult {
        data = typeof data === 'object' ? data : {};
        let result = new PredictionsTesterResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.days)) {
            data["days"] = [];
            for (let item of this.days)
                data["days"].push(item.toJSON());
        }
        if (Array.isArray(this.rooms)) {
            data["rooms"] = [];
            for (let item of this.rooms)
                data["rooms"].push(item.toJSON());
        }
        if (Array.isArray(this.errorResults)) {
            data["errorResults"] = [];
            for (let item of this.errorResults)
                data["errorResults"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPredictionsTesterResult {
    days?: CalendarDay[] | null;
    rooms?: CleaningCalendarTesterRoom[] | null;
    errorResults?: PredictionsTesterError[] | null;
}

export class CleaningCalendarTesterRoom extends CleaningCalendarRoom implements ICleaningCalendarTesterRoom {
    basedOnsDescription?: string | null;
    reservationsDescription?: string | null;
    isOutOfService!: boolean;
    isDoNotDisturb!: boolean;
    section?: string | null;
    subSection?: string | null;
    floorId?: string | null;
    days?: CleaningCalendarTesterDay[] | null;

    constructor(data?: ICleaningCalendarTesterRoom) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.basedOnsDescription = _data["basedOnsDescription"] !== undefined ? _data["basedOnsDescription"] : <any>null;
            this.reservationsDescription = _data["reservationsDescription"] !== undefined ? _data["reservationsDescription"] : <any>null;
            this.isOutOfService = _data["isOutOfService"] !== undefined ? _data["isOutOfService"] : <any>null;
            this.isDoNotDisturb = _data["isDoNotDisturb"] !== undefined ? _data["isDoNotDisturb"] : <any>null;
            this.section = _data["section"] !== undefined ? _data["section"] : <any>null;
            this.subSection = _data["subSection"] !== undefined ? _data["subSection"] : <any>null;
            this.floorId = _data["floorId"] !== undefined ? _data["floorId"] : <any>null;
            if (Array.isArray(_data["days"])) {
                this.days = [] as any;
                for (let item of _data["days"])
                    this.days!.push(CleaningCalendarTesterDay.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CleaningCalendarTesterRoom {
        data = typeof data === 'object' ? data : {};
        let result = new CleaningCalendarTesterRoom();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["basedOnsDescription"] = this.basedOnsDescription !== undefined ? this.basedOnsDescription : <any>null;
        data["reservationsDescription"] = this.reservationsDescription !== undefined ? this.reservationsDescription : <any>null;
        data["isOutOfService"] = this.isOutOfService !== undefined ? this.isOutOfService : <any>null;
        data["isDoNotDisturb"] = this.isDoNotDisturb !== undefined ? this.isDoNotDisturb : <any>null;
        data["section"] = this.section !== undefined ? this.section : <any>null;
        data["subSection"] = this.subSection !== undefined ? this.subSection : <any>null;
        data["floorId"] = this.floorId !== undefined ? this.floorId : <any>null;
        if (Array.isArray(this.days)) {
            data["days"] = [];
            for (let item of this.days)
                data["days"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface ICleaningCalendarTesterRoom extends ICleaningCalendarRoom {
    basedOnsDescription?: string | null;
    reservationsDescription?: string | null;
    isOutOfService: boolean;
    isDoNotDisturb: boolean;
    section?: string | null;
    subSection?: string | null;
    floorId?: string | null;
    days?: CleaningCalendarTesterDay[] | null;
}

export class CleaningCalendarTesterDay extends CleaningCalendarDay implements ICleaningCalendarTesterDay {
    cleanings?: CleaningCalendarTesterCleaning[] | null;

    constructor(data?: ICleaningCalendarTesterDay) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["cleanings"])) {
                this.cleanings = [] as any;
                for (let item of _data["cleanings"])
                    this.cleanings!.push(CleaningCalendarTesterCleaning.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CleaningCalendarTesterDay {
        data = typeof data === 'object' ? data : {};
        let result = new CleaningCalendarTesterDay();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.cleanings)) {
            data["cleanings"] = [];
            for (let item of this.cleanings)
                data["cleanings"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface ICleaningCalendarTesterDay extends ICleaningCalendarDay {
    cleanings?: CleaningCalendarTesterCleaning[] | null;
}

export class CleaningCalendarTesterCleaning extends CleaningCalendarCleaning implements ICleaningCalendarTesterCleaning {
    cleaningType?: string | null;
    credits!: number;

    constructor(data?: ICleaningCalendarTesterCleaning) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.cleaningType = _data["cleaningType"] !== undefined ? _data["cleaningType"] : <any>null;
            this.credits = _data["credits"] !== undefined ? _data["credits"] : <any>null;
        }
    }

    static fromJS(data: any): CleaningCalendarTesterCleaning {
        data = typeof data === 'object' ? data : {};
        let result = new CleaningCalendarTesterCleaning();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cleaningType"] = this.cleaningType !== undefined ? this.cleaningType : <any>null;
        data["credits"] = this.credits !== undefined ? this.credits : <any>null;
        super.toJSON(data);
        return data; 
    }
}

export interface ICleaningCalendarTesterCleaning extends ICleaningCalendarCleaning {
    cleaningType?: string | null;
    credits: number;
}

export class PredictionsTesterError implements IPredictionsTesterError {
    roomName?: string | null;
    cleaningDate!: moment.Moment;
    numberOfReservations!: number;
    numberOfPlugins!: number;
    message?: string | null;

    constructor(data?: IPredictionsTesterError) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roomName = _data["roomName"] !== undefined ? _data["roomName"] : <any>null;
            this.cleaningDate = _data["cleaningDate"] ? moment(_data["cleaningDate"].toString()) : <any>null;
            this.numberOfReservations = _data["numberOfReservations"] !== undefined ? _data["numberOfReservations"] : <any>null;
            this.numberOfPlugins = _data["numberOfPlugins"] !== undefined ? _data["numberOfPlugins"] : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
        }
    }

    static fromJS(data: any): PredictionsTesterError {
        data = typeof data === 'object' ? data : {};
        let result = new PredictionsTesterError();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roomName"] = this.roomName !== undefined ? this.roomName : <any>null;
        data["cleaningDate"] = this.cleaningDate ? this.cleaningDate.toISOString() : <any>null;
        data["numberOfReservations"] = this.numberOfReservations !== undefined ? this.numberOfReservations : <any>null;
        data["numberOfPlugins"] = this.numberOfPlugins !== undefined ? this.numberOfPlugins : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        return data; 
    }
}

export interface IPredictionsTesterError {
    roomName?: string | null;
    cleaningDate: moment.Moment;
    numberOfReservations: number;
    numberOfPlugins: number;
    message?: string | null;
}

export class PredictionsTesterRequest implements IPredictionsTesterRequest {
    basedOnKey?: string | null;
    reservationsKey?: string | null;

    constructor(data?: IPredictionsTesterRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.basedOnKey = _data["basedOnKey"] !== undefined ? _data["basedOnKey"] : <any>null;
            this.reservationsKey = _data["reservationsKey"] !== undefined ? _data["reservationsKey"] : <any>null;
        }
    }

    static fromJS(data: any): PredictionsTesterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PredictionsTesterRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["basedOnKey"] = this.basedOnKey !== undefined ? this.basedOnKey : <any>null;
        data["reservationsKey"] = this.reservationsKey !== undefined ? this.reservationsKey : <any>null;
        return data; 
    }
}

export interface IPredictionsTesterRequest {
    basedOnKey?: string | null;
    reservationsKey?: string | null;
}

export class HotelGridData implements IHotelGridData {
    id?: string | null;
    name?: string | null;

    constructor(data?: IHotelGridData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
        }
    }

    static fromJS(data: any): HotelGridData {
        data = typeof data === 'object' ? data : {};
        let result = new HotelGridData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface IHotelGridData {
    id?: string | null;
    name?: string | null;
}

export class GetHotelsQuery implements IGetHotelsQuery {

    constructor(data?: IGetHotelsQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): GetHotelsQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetHotelsQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IGetHotelsQuery {
}

export class HotelRoomCategoryData implements IHotelRoomCategoryData {
    id!: string;
    name?: string | null;

    constructor(data?: IHotelRoomCategoryData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
        }
    }

    static fromJS(data: any): HotelRoomCategoryData {
        data = typeof data === 'object' ? data : {};
        let result = new HotelRoomCategoryData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface IHotelRoomCategoryData {
    id: string;
    name?: string | null;
}

export class GetHotelRoomCategoriesQuery implements IGetHotelRoomCategoriesQuery {

    constructor(data?: IGetHotelRoomCategoriesQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): GetHotelRoomCategoriesQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetHotelRoomCategoriesQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IGetHotelRoomCategoriesQuery {
}

export class HotelHierarchyData implements IHotelHierarchyData {
    buildings?: HotelHierarchyBuildingData[] | null;

    constructor(data?: IHotelHierarchyData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["buildings"])) {
                this.buildings = [] as any;
                for (let item of _data["buildings"])
                    this.buildings!.push(HotelHierarchyBuildingData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): HotelHierarchyData {
        data = typeof data === 'object' ? data : {};
        let result = new HotelHierarchyData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.buildings)) {
            data["buildings"] = [];
            for (let item of this.buildings)
                data["buildings"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IHotelHierarchyData {
    buildings?: HotelHierarchyBuildingData[] | null;
}

export class HotelHierarchyBuildingData implements IHotelHierarchyBuildingData {
    id!: string;
    name?: string | null;
    floors?: HotelHierarchyFloorData[] | null;

    constructor(data?: IHotelHierarchyBuildingData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            if (Array.isArray(_data["floors"])) {
                this.floors = [] as any;
                for (let item of _data["floors"])
                    this.floors!.push(HotelHierarchyFloorData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): HotelHierarchyBuildingData {
        data = typeof data === 'object' ? data : {};
        let result = new HotelHierarchyBuildingData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        if (Array.isArray(this.floors)) {
            data["floors"] = [];
            for (let item of this.floors)
                data["floors"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IHotelHierarchyBuildingData {
    id: string;
    name?: string | null;
    floors?: HotelHierarchyFloorData[] | null;
}

export class HotelHierarchyFloorData implements IHotelHierarchyFloorData {
    id!: string;
    name?: string | null;
    sections?: HotelHierarchySectionData[] | null;

    constructor(data?: IHotelHierarchyFloorData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            if (Array.isArray(_data["sections"])) {
                this.sections = [] as any;
                for (let item of _data["sections"])
                    this.sections!.push(HotelHierarchySectionData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): HotelHierarchyFloorData {
        data = typeof data === 'object' ? data : {};
        let result = new HotelHierarchyFloorData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        if (Array.isArray(this.sections)) {
            data["sections"] = [];
            for (let item of this.sections)
                data["sections"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IHotelHierarchyFloorData {
    id: string;
    name?: string | null;
    sections?: HotelHierarchySectionData[] | null;
}

export class HotelHierarchySectionData implements IHotelHierarchySectionData {
    name?: string | null;
    subSections?: HotelHierarchySubSectionData[] | null;

    constructor(data?: IHotelHierarchySectionData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            if (Array.isArray(_data["subSections"])) {
                this.subSections = [] as any;
                for (let item of _data["subSections"])
                    this.subSections!.push(HotelHierarchySubSectionData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): HotelHierarchySectionData {
        data = typeof data === 'object' ? data : {};
        let result = new HotelHierarchySectionData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        if (Array.isArray(this.subSections)) {
            data["subSections"] = [];
            for (let item of this.subSections)
                data["subSections"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IHotelHierarchySectionData {
    name?: string | null;
    subSections?: HotelHierarchySubSectionData[] | null;
}

export class HotelHierarchySubSectionData implements IHotelHierarchySubSectionData {
    name?: string | null;

    constructor(data?: IHotelHierarchySubSectionData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
        }
    }

    static fromJS(data: any): HotelHierarchySubSectionData {
        data = typeof data === 'object' ? data : {};
        let result = new HotelHierarchySubSectionData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface IHotelHierarchySubSectionData {
    name?: string | null;
}

export class GetHotelHierarchyQuery implements IGetHotelHierarchyQuery {
    hotelId?: string | null;

    constructor(data?: IGetHotelHierarchyQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hotelId = _data["hotelId"] !== undefined ? _data["hotelId"] : <any>null;
        }
    }

    static fromJS(data: any): GetHotelHierarchyQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetHotelHierarchyQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hotelId"] = this.hotelId !== undefined ? this.hotelId : <any>null;
        return data; 
    }
}

export interface IGetHotelHierarchyQuery {
    hotelId?: string | null;
}

export class HotelRoomData implements IHotelRoomData {
    id!: string;
    name?: string | null;
    section?: string | null;
    subSection?: string | null;
    floor?: string | null;
    building?: string | null;

    constructor(data?: IHotelRoomData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.section = _data["section"] !== undefined ? _data["section"] : <any>null;
            this.subSection = _data["subSection"] !== undefined ? _data["subSection"] : <any>null;
            this.floor = _data["floor"] !== undefined ? _data["floor"] : <any>null;
            this.building = _data["building"] !== undefined ? _data["building"] : <any>null;
        }
    }

    static fromJS(data: any): HotelRoomData {
        data = typeof data === 'object' ? data : {};
        let result = new HotelRoomData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["section"] = this.section !== undefined ? this.section : <any>null;
        data["subSection"] = this.subSection !== undefined ? this.subSection : <any>null;
        data["floor"] = this.floor !== undefined ? this.floor : <any>null;
        data["building"] = this.building !== undefined ? this.building : <any>null;
        return data; 
    }
}

export interface IHotelRoomData {
    id: string;
    name?: string | null;
    section?: string | null;
    subSection?: string | null;
    floor?: string | null;
    building?: string | null;
}

export class GetHotelRoomsQuery implements IGetHotelRoomsQuery {
    hotelId?: string | null;

    constructor(data?: IGetHotelRoomsQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hotelId = _data["hotelId"] !== undefined ? _data["hotelId"] : <any>null;
        }
    }

    static fromJS(data: any): GetHotelRoomsQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetHotelRoomsQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hotelId"] = this.hotelId !== undefined ? this.hotelId : <any>null;
        return data; 
    }
}

export interface IGetHotelRoomsQuery {
    hotelId?: string | null;
}

export class HotelGroupDetailsData implements IHotelGroupDetailsData {
    id!: string;
    key?: string | null;
    name?: string | null;
    isActive!: boolean;
    connectionStringUserId?: string | null;
    connectionStringPassword?: string | null;
    connectionStringHost?: string | null;
    connectionStringPort?: string | null;
    connectionStringDatabase?: string | null;
    connectionStringPooling!: boolean;

    constructor(data?: IHotelGroupDetailsData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.key = _data["key"] !== undefined ? _data["key"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.isActive = _data["isActive"] !== undefined ? _data["isActive"] : <any>null;
            this.connectionStringUserId = _data["connectionStringUserId"] !== undefined ? _data["connectionStringUserId"] : <any>null;
            this.connectionStringPassword = _data["connectionStringPassword"] !== undefined ? _data["connectionStringPassword"] : <any>null;
            this.connectionStringHost = _data["connectionStringHost"] !== undefined ? _data["connectionStringHost"] : <any>null;
            this.connectionStringPort = _data["connectionStringPort"] !== undefined ? _data["connectionStringPort"] : <any>null;
            this.connectionStringDatabase = _data["connectionStringDatabase"] !== undefined ? _data["connectionStringDatabase"] : <any>null;
            this.connectionStringPooling = _data["connectionStringPooling"] !== undefined ? _data["connectionStringPooling"] : <any>null;
        }
    }

    static fromJS(data: any): HotelGroupDetailsData {
        data = typeof data === 'object' ? data : {};
        let result = new HotelGroupDetailsData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["key"] = this.key !== undefined ? this.key : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["isActive"] = this.isActive !== undefined ? this.isActive : <any>null;
        data["connectionStringUserId"] = this.connectionStringUserId !== undefined ? this.connectionStringUserId : <any>null;
        data["connectionStringPassword"] = this.connectionStringPassword !== undefined ? this.connectionStringPassword : <any>null;
        data["connectionStringHost"] = this.connectionStringHost !== undefined ? this.connectionStringHost : <any>null;
        data["connectionStringPort"] = this.connectionStringPort !== undefined ? this.connectionStringPort : <any>null;
        data["connectionStringDatabase"] = this.connectionStringDatabase !== undefined ? this.connectionStringDatabase : <any>null;
        data["connectionStringPooling"] = this.connectionStringPooling !== undefined ? this.connectionStringPooling : <any>null;
        return data; 
    }
}

export interface IHotelGroupDetailsData {
    id: string;
    key?: string | null;
    name?: string | null;
    isActive: boolean;
    connectionStringUserId?: string | null;
    connectionStringPassword?: string | null;
    connectionStringHost?: string | null;
    connectionStringPort?: string | null;
    connectionStringDatabase?: string | null;
    connectionStringPooling: boolean;
}

export class GetHotelGroupDetailsQuery implements IGetHotelGroupDetailsQuery {
    id!: string;

    constructor(data?: IGetHotelGroupDetailsQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
        }
    }

    static fromJS(data: any): GetHotelGroupDetailsQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetHotelGroupDetailsQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        return data; 
    }
}

export interface IGetHotelGroupDetailsQuery {
    id: string;
}

export class HotelGroupGridData implements IHotelGroupGridData {
    id!: string;
    name?: string | null;
    isActive!: boolean;

    constructor(data?: IHotelGroupGridData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.isActive = _data["isActive"] !== undefined ? _data["isActive"] : <any>null;
        }
    }

    static fromJS(data: any): HotelGroupGridData {
        data = typeof data === 'object' ? data : {};
        let result = new HotelGroupGridData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["isActive"] = this.isActive !== undefined ? this.isActive : <any>null;
        return data; 
    }
}

export interface IHotelGroupGridData {
    id: string;
    name?: string | null;
    isActive: boolean;
}

export class GetHotelGroupsQuery implements IGetHotelGroupsQuery {

    constructor(data?: IGetHotelGroupsQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): GetHotelGroupsQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetHotelGroupsQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IGetHotelGroupsQuery {
}

export class PageOfOfHotelGroupAssetData implements IPageOfOfHotelGroupAssetData {
    items?: HotelGroupAssetData[] | null;
    totalNumberOfItems!: number;

    constructor(data?: IPageOfOfHotelGroupAssetData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(HotelGroupAssetData.fromJS(item));
            }
            this.totalNumberOfItems = _data["totalNumberOfItems"] !== undefined ? _data["totalNumberOfItems"] : <any>null;
        }
    }

    static fromJS(data: any): PageOfOfHotelGroupAssetData {
        data = typeof data === 'object' ? data : {};
        let result = new PageOfOfHotelGroupAssetData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalNumberOfItems"] = this.totalNumberOfItems !== undefined ? this.totalNumberOfItems : <any>null;
        return data; 
    }
}

export interface IPageOfOfHotelGroupAssetData {
    items?: HotelGroupAssetData[] | null;
    totalNumberOfItems: number;
}

export class HotelGroupAssetData implements IHotelGroupAssetData {
    id!: string;
    name?: string | null;
    availableQuantity!: number;
    usesModels!: boolean;
    models?: HotelGroupAssetModelData[] | null;

    constructor(data?: IHotelGroupAssetData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.availableQuantity = _data["availableQuantity"] !== undefined ? _data["availableQuantity"] : <any>null;
            this.usesModels = _data["usesModels"] !== undefined ? _data["usesModels"] : <any>null;
            if (Array.isArray(_data["models"])) {
                this.models = [] as any;
                for (let item of _data["models"])
                    this.models!.push(HotelGroupAssetModelData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): HotelGroupAssetData {
        data = typeof data === 'object' ? data : {};
        let result = new HotelGroupAssetData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["availableQuantity"] = this.availableQuantity !== undefined ? this.availableQuantity : <any>null;
        data["usesModels"] = this.usesModels !== undefined ? this.usesModels : <any>null;
        if (Array.isArray(this.models)) {
            data["models"] = [];
            for (let item of this.models)
                data["models"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IHotelGroupAssetData {
    id: string;
    name?: string | null;
    availableQuantity: number;
    usesModels: boolean;
    models?: HotelGroupAssetModelData[] | null;
}

export class HotelGroupAssetModelData implements IHotelGroupAssetModelData {
    id!: string;
    name?: string | null;

    constructor(data?: IHotelGroupAssetModelData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
        }
    }

    static fromJS(data: any): HotelGroupAssetModelData {
        data = typeof data === 'object' ? data : {};
        let result = new HotelGroupAssetModelData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface IHotelGroupAssetModelData {
    id: string;
    name?: string | null;
}

export class GetPageRequest implements IGetPageRequest {
    skip!: number;
    take!: number;

    constructor(data?: IGetPageRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.skip = _data["skip"] !== undefined ? _data["skip"] : <any>null;
            this.take = _data["take"] !== undefined ? _data["take"] : <any>null;
        }
    }

    static fromJS(data: any): GetPageRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GetPageRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skip"] = this.skip !== undefined ? this.skip : <any>null;
        data["take"] = this.take !== undefined ? this.take : <any>null;
        return data; 
    }
}

export interface IGetPageRequest {
    skip: number;
    take: number;
}

export class GetPageOfHotelGroupAssetsQuery extends GetPageRequest implements IGetPageOfHotelGroupAssetsQuery {
    keywords?: string | null;
    sortKey?: string | null;
    activeStatusKey?: string | null;

    constructor(data?: IGetPageOfHotelGroupAssetsQuery) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.keywords = _data["keywords"] !== undefined ? _data["keywords"] : <any>null;
            this.sortKey = _data["sortKey"] !== undefined ? _data["sortKey"] : <any>null;
            this.activeStatusKey = _data["activeStatusKey"] !== undefined ? _data["activeStatusKey"] : <any>null;
        }
    }

    static fromJS(data: any): GetPageOfHotelGroupAssetsQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetPageOfHotelGroupAssetsQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["keywords"] = this.keywords !== undefined ? this.keywords : <any>null;
        data["sortKey"] = this.sortKey !== undefined ? this.sortKey : <any>null;
        data["activeStatusKey"] = this.activeStatusKey !== undefined ? this.activeStatusKey : <any>null;
        super.toJSON(data);
        return data; 
    }
}

export interface IGetPageOfHotelGroupAssetsQuery extends IGetPageRequest {
    keywords?: string | null;
    sortKey?: string | null;
    activeStatusKey?: string | null;
}

export class PageOfOfHotelGroupHotelReservationData implements IPageOfOfHotelGroupHotelReservationData {
    items?: HotelGroupHotelReservationData[] | null;
    totalNumberOfItems!: number;

    constructor(data?: IPageOfOfHotelGroupHotelReservationData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(HotelGroupHotelReservationData.fromJS(item));
            }
            this.totalNumberOfItems = _data["totalNumberOfItems"] !== undefined ? _data["totalNumberOfItems"] : <any>null;
        }
    }

    static fromJS(data: any): PageOfOfHotelGroupHotelReservationData {
        data = typeof data === 'object' ? data : {};
        let result = new PageOfOfHotelGroupHotelReservationData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalNumberOfItems"] = this.totalNumberOfItems !== undefined ? this.totalNumberOfItems : <any>null;
        return data; 
    }
}

export interface IPageOfOfHotelGroupHotelReservationData {
    items?: HotelGroupHotelReservationData[] | null;
    totalNumberOfItems: number;
}

export class HotelGroupHotelReservationData implements IHotelGroupHotelReservationData {
    id?: string | null;
    roomName?: string | null;
    pmsRoomName?: string | null;
    guestName?: string | null;
    checkIn?: moment.Moment | null;
    checkOut?: moment.Moment | null;
    rccReservationStatusKey?: string | null;
    numberOfAdults!: number;
    numberOfChildren!: number;
    numberOfInfants!: number;
    pmsNote?: string | null;
    vip?: string | null;
    otherProperties?: HotelGroupReservationOtherProperties[] | null;
    roomId?: string | null;

    constructor(data?: IHotelGroupHotelReservationData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.roomName = _data["roomName"] !== undefined ? _data["roomName"] : <any>null;
            this.pmsRoomName = _data["pmsRoomName"] !== undefined ? _data["pmsRoomName"] : <any>null;
            this.guestName = _data["guestName"] !== undefined ? _data["guestName"] : <any>null;
            this.checkIn = _data["checkIn"] ? moment(_data["checkIn"].toString()) : <any>null;
            this.checkOut = _data["checkOut"] ? moment(_data["checkOut"].toString()) : <any>null;
            this.rccReservationStatusKey = _data["rccReservationStatusKey"] !== undefined ? _data["rccReservationStatusKey"] : <any>null;
            this.numberOfAdults = _data["numberOfAdults"] !== undefined ? _data["numberOfAdults"] : <any>null;
            this.numberOfChildren = _data["numberOfChildren"] !== undefined ? _data["numberOfChildren"] : <any>null;
            this.numberOfInfants = _data["numberOfInfants"] !== undefined ? _data["numberOfInfants"] : <any>null;
            this.pmsNote = _data["pmsNote"] !== undefined ? _data["pmsNote"] : <any>null;
            this.vip = _data["vip"] !== undefined ? _data["vip"] : <any>null;
            if (Array.isArray(_data["otherProperties"])) {
                this.otherProperties = [] as any;
                for (let item of _data["otherProperties"])
                    this.otherProperties!.push(HotelGroupReservationOtherProperties.fromJS(item));
            }
            this.roomId = _data["roomId"] !== undefined ? _data["roomId"] : <any>null;
        }
    }

    static fromJS(data: any): HotelGroupHotelReservationData {
        data = typeof data === 'object' ? data : {};
        let result = new HotelGroupHotelReservationData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["roomName"] = this.roomName !== undefined ? this.roomName : <any>null;
        data["pmsRoomName"] = this.pmsRoomName !== undefined ? this.pmsRoomName : <any>null;
        data["guestName"] = this.guestName !== undefined ? this.guestName : <any>null;
        data["checkIn"] = this.checkIn ? this.checkIn.toISOString() : <any>null;
        data["checkOut"] = this.checkOut ? this.checkOut.toISOString() : <any>null;
        data["rccReservationStatusKey"] = this.rccReservationStatusKey !== undefined ? this.rccReservationStatusKey : <any>null;
        data["numberOfAdults"] = this.numberOfAdults !== undefined ? this.numberOfAdults : <any>null;
        data["numberOfChildren"] = this.numberOfChildren !== undefined ? this.numberOfChildren : <any>null;
        data["numberOfInfants"] = this.numberOfInfants !== undefined ? this.numberOfInfants : <any>null;
        data["pmsNote"] = this.pmsNote !== undefined ? this.pmsNote : <any>null;
        data["vip"] = this.vip !== undefined ? this.vip : <any>null;
        if (Array.isArray(this.otherProperties)) {
            data["otherProperties"] = [];
            for (let item of this.otherProperties)
                data["otherProperties"].push(item.toJSON());
        }
        data["roomId"] = this.roomId !== undefined ? this.roomId : <any>null;
        return data; 
    }
}

export interface IHotelGroupHotelReservationData {
    id?: string | null;
    roomName?: string | null;
    pmsRoomName?: string | null;
    guestName?: string | null;
    checkIn?: moment.Moment | null;
    checkOut?: moment.Moment | null;
    rccReservationStatusKey?: string | null;
    numberOfAdults: number;
    numberOfChildren: number;
    numberOfInfants: number;
    pmsNote?: string | null;
    vip?: string | null;
    otherProperties?: HotelGroupReservationOtherProperties[] | null;
    roomId?: string | null;
}

export class HotelGroupReservationOtherProperties implements IHotelGroupReservationOtherProperties {
    key?: string | null;
    value?: string | null;

    constructor(data?: IHotelGroupReservationOtherProperties) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"] !== undefined ? _data["key"] : <any>null;
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
        }
    }

    static fromJS(data: any): HotelGroupReservationOtherProperties {
        data = typeof data === 'object' ? data : {};
        let result = new HotelGroupReservationOtherProperties();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key !== undefined ? this.key : <any>null;
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data; 
    }
}

export interface IHotelGroupReservationOtherProperties {
    key?: string | null;
    value?: string | null;
}

export class GetPageOfHotelGroupHotelReservationsQuery extends GetPageRequest implements IGetPageOfHotelGroupHotelReservationsQuery {
    keywords?: string | null;
    sortKey?: string | null;
    hotelId?: string | null;

    constructor(data?: IGetPageOfHotelGroupHotelReservationsQuery) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.keywords = _data["keywords"] !== undefined ? _data["keywords"] : <any>null;
            this.sortKey = _data["sortKey"] !== undefined ? _data["sortKey"] : <any>null;
            this.hotelId = _data["hotelId"] !== undefined ? _data["hotelId"] : <any>null;
        }
    }

    static fromJS(data: any): GetPageOfHotelGroupHotelReservationsQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetPageOfHotelGroupHotelReservationsQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["keywords"] = this.keywords !== undefined ? this.keywords : <any>null;
        data["sortKey"] = this.sortKey !== undefined ? this.sortKey : <any>null;
        data["hotelId"] = this.hotelId !== undefined ? this.hotelId : <any>null;
        super.toJSON(data);
        return data; 
    }
}

export interface IGetPageOfHotelGroupHotelReservationsQuery extends IGetPageRequest {
    keywords?: string | null;
    sortKey?: string | null;
    hotelId?: string | null;
}

export class PageOfOfHotelGroupHotelRoomsData implements IPageOfOfHotelGroupHotelRoomsData {
    items?: HotelGroupHotelRoomsData[] | null;
    totalNumberOfItems!: number;

    constructor(data?: IPageOfOfHotelGroupHotelRoomsData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(HotelGroupHotelRoomsData.fromJS(item));
            }
            this.totalNumberOfItems = _data["totalNumberOfItems"] !== undefined ? _data["totalNumberOfItems"] : <any>null;
        }
    }

    static fromJS(data: any): PageOfOfHotelGroupHotelRoomsData {
        data = typeof data === 'object' ? data : {};
        let result = new PageOfOfHotelGroupHotelRoomsData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalNumberOfItems"] = this.totalNumberOfItems !== undefined ? this.totalNumberOfItems : <any>null;
        return data; 
    }
}

export interface IPageOfOfHotelGroupHotelRoomsData {
    items?: HotelGroupHotelRoomsData[] | null;
    totalNumberOfItems: number;
}

export class HotelGroupHotelRoomsData implements IHotelGroupHotelRoomsData {
    id!: string;
    externalId?: string | null;
    name?: string | null;
    typeKey?: string | null;
    typeName?: string | null;
    ordinalNumber!: number;
    floorSectionName?: string | null;
    floorSubSectionName?: string | null;
    areaId?: string | null;
    areaName?: string | null;
    buildingId?: string | null;
    buildingName?: string | null;
    floorId?: string | null;
    floorName?: string | null;
    categoryId?: string | null;
    categoryName?: string | null;
    isAutogeneratedFromReservationSync?: boolean | null;
    isAssignedToBuildingAndFloor!: boolean;
    isOccupied!: boolean;
    isClean!: boolean;
    isOutOfOrder!: boolean;
    isDoNotDisturb!: boolean;

    constructor(data?: IHotelGroupHotelRoomsData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.externalId = _data["externalId"] !== undefined ? _data["externalId"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.typeKey = _data["typeKey"] !== undefined ? _data["typeKey"] : <any>null;
            this.typeName = _data["typeName"] !== undefined ? _data["typeName"] : <any>null;
            this.ordinalNumber = _data["ordinalNumber"] !== undefined ? _data["ordinalNumber"] : <any>null;
            this.floorSectionName = _data["floorSectionName"] !== undefined ? _data["floorSectionName"] : <any>null;
            this.floorSubSectionName = _data["floorSubSectionName"] !== undefined ? _data["floorSubSectionName"] : <any>null;
            this.areaId = _data["areaId"] !== undefined ? _data["areaId"] : <any>null;
            this.areaName = _data["areaName"] !== undefined ? _data["areaName"] : <any>null;
            this.buildingId = _data["buildingId"] !== undefined ? _data["buildingId"] : <any>null;
            this.buildingName = _data["buildingName"] !== undefined ? _data["buildingName"] : <any>null;
            this.floorId = _data["floorId"] !== undefined ? _data["floorId"] : <any>null;
            this.floorName = _data["floorName"] !== undefined ? _data["floorName"] : <any>null;
            this.categoryId = _data["categoryId"] !== undefined ? _data["categoryId"] : <any>null;
            this.categoryName = _data["categoryName"] !== undefined ? _data["categoryName"] : <any>null;
            this.isAutogeneratedFromReservationSync = _data["isAutogeneratedFromReservationSync"] !== undefined ? _data["isAutogeneratedFromReservationSync"] : <any>null;
            this.isAssignedToBuildingAndFloor = _data["isAssignedToBuildingAndFloor"] !== undefined ? _data["isAssignedToBuildingAndFloor"] : <any>null;
            this.isOccupied = _data["isOccupied"] !== undefined ? _data["isOccupied"] : <any>null;
            this.isClean = _data["isClean"] !== undefined ? _data["isClean"] : <any>null;
            this.isOutOfOrder = _data["isOutOfOrder"] !== undefined ? _data["isOutOfOrder"] : <any>null;
            this.isDoNotDisturb = _data["isDoNotDisturb"] !== undefined ? _data["isDoNotDisturb"] : <any>null;
        }
    }

    static fromJS(data: any): HotelGroupHotelRoomsData {
        data = typeof data === 'object' ? data : {};
        let result = new HotelGroupHotelRoomsData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["externalId"] = this.externalId !== undefined ? this.externalId : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["typeKey"] = this.typeKey !== undefined ? this.typeKey : <any>null;
        data["typeName"] = this.typeName !== undefined ? this.typeName : <any>null;
        data["ordinalNumber"] = this.ordinalNumber !== undefined ? this.ordinalNumber : <any>null;
        data["floorSectionName"] = this.floorSectionName !== undefined ? this.floorSectionName : <any>null;
        data["floorSubSectionName"] = this.floorSubSectionName !== undefined ? this.floorSubSectionName : <any>null;
        data["areaId"] = this.areaId !== undefined ? this.areaId : <any>null;
        data["areaName"] = this.areaName !== undefined ? this.areaName : <any>null;
        data["buildingId"] = this.buildingId !== undefined ? this.buildingId : <any>null;
        data["buildingName"] = this.buildingName !== undefined ? this.buildingName : <any>null;
        data["floorId"] = this.floorId !== undefined ? this.floorId : <any>null;
        data["floorName"] = this.floorName !== undefined ? this.floorName : <any>null;
        data["categoryId"] = this.categoryId !== undefined ? this.categoryId : <any>null;
        data["categoryName"] = this.categoryName !== undefined ? this.categoryName : <any>null;
        data["isAutogeneratedFromReservationSync"] = this.isAutogeneratedFromReservationSync !== undefined ? this.isAutogeneratedFromReservationSync : <any>null;
        data["isAssignedToBuildingAndFloor"] = this.isAssignedToBuildingAndFloor !== undefined ? this.isAssignedToBuildingAndFloor : <any>null;
        data["isOccupied"] = this.isOccupied !== undefined ? this.isOccupied : <any>null;
        data["isClean"] = this.isClean !== undefined ? this.isClean : <any>null;
        data["isOutOfOrder"] = this.isOutOfOrder !== undefined ? this.isOutOfOrder : <any>null;
        data["isDoNotDisturb"] = this.isDoNotDisturb !== undefined ? this.isDoNotDisturb : <any>null;
        return data; 
    }
}

export interface IHotelGroupHotelRoomsData {
    id: string;
    externalId?: string | null;
    name?: string | null;
    typeKey?: string | null;
    typeName?: string | null;
    ordinalNumber: number;
    floorSectionName?: string | null;
    floorSubSectionName?: string | null;
    areaId?: string | null;
    areaName?: string | null;
    buildingId?: string | null;
    buildingName?: string | null;
    floorId?: string | null;
    floorName?: string | null;
    categoryId?: string | null;
    categoryName?: string | null;
    isAutogeneratedFromReservationSync?: boolean | null;
    isAssignedToBuildingAndFloor: boolean;
    isOccupied: boolean;
    isClean: boolean;
    isOutOfOrder: boolean;
    isDoNotDisturb: boolean;
}

export class GetPageOfHotelGroupHotelRoomsQuery extends GetPageRequest implements IGetPageOfHotelGroupHotelRoomsQuery {
    keywords?: string | null;
    sortKey?: string | null;
    activeStatusKey?: string | null;
    hotelId?: string | null;

    constructor(data?: IGetPageOfHotelGroupHotelRoomsQuery) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.keywords = _data["keywords"] !== undefined ? _data["keywords"] : <any>null;
            this.sortKey = _data["sortKey"] !== undefined ? _data["sortKey"] : <any>null;
            this.activeStatusKey = _data["activeStatusKey"] !== undefined ? _data["activeStatusKey"] : <any>null;
            this.hotelId = _data["hotelId"] !== undefined ? _data["hotelId"] : <any>null;
        }
    }

    static fromJS(data: any): GetPageOfHotelGroupHotelRoomsQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetPageOfHotelGroupHotelRoomsQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["keywords"] = this.keywords !== undefined ? this.keywords : <any>null;
        data["sortKey"] = this.sortKey !== undefined ? this.sortKey : <any>null;
        data["activeStatusKey"] = this.activeStatusKey !== undefined ? this.activeStatusKey : <any>null;
        data["hotelId"] = this.hotelId !== undefined ? this.hotelId : <any>null;
        super.toJSON(data);
        return data; 
    }
}

export interface IGetPageOfHotelGroupHotelRoomsQuery extends IGetPageRequest {
    keywords?: string | null;
    sortKey?: string | null;
    activeStatusKey?: string | null;
    hotelId?: string | null;
}

export class PageOfOfHotelGroupHotelData implements IPageOfOfHotelGroupHotelData {
    items?: HotelGroupHotelData[] | null;
    totalNumberOfItems!: number;

    constructor(data?: IPageOfOfHotelGroupHotelData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(HotelGroupHotelData.fromJS(item));
            }
            this.totalNumberOfItems = _data["totalNumberOfItems"] !== undefined ? _data["totalNumberOfItems"] : <any>null;
        }
    }

    static fromJS(data: any): PageOfOfHotelGroupHotelData {
        data = typeof data === 'object' ? data : {};
        let result = new PageOfOfHotelGroupHotelData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalNumberOfItems"] = this.totalNumberOfItems !== undefined ? this.totalNumberOfItems : <any>null;
        return data; 
    }
}

export interface IPageOfOfHotelGroupHotelData {
    items?: HotelGroupHotelData[] | null;
    totalNumberOfItems: number;
}

export class HotelGroupHotelData implements IHotelGroupHotelData {
    id?: string | null;
    name?: string | null;
    windowsTimeZoneId?: string | null;
    ianaTimeZoneId?: string | null;

    constructor(data?: IHotelGroupHotelData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.windowsTimeZoneId = _data["windowsTimeZoneId"] !== undefined ? _data["windowsTimeZoneId"] : <any>null;
            this.ianaTimeZoneId = _data["ianaTimeZoneId"] !== undefined ? _data["ianaTimeZoneId"] : <any>null;
        }
    }

    static fromJS(data: any): HotelGroupHotelData {
        data = typeof data === 'object' ? data : {};
        let result = new HotelGroupHotelData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["windowsTimeZoneId"] = this.windowsTimeZoneId !== undefined ? this.windowsTimeZoneId : <any>null;
        data["ianaTimeZoneId"] = this.ianaTimeZoneId !== undefined ? this.ianaTimeZoneId : <any>null;
        return data; 
    }
}

export interface IHotelGroupHotelData {
    id?: string | null;
    name?: string | null;
    windowsTimeZoneId?: string | null;
    ianaTimeZoneId?: string | null;
}

export class GetPageOfHotelGroupHotelsQuery extends GetPageRequest implements IGetPageOfHotelGroupHotelsQuery {
    keywords?: string | null;
    sortKey?: string | null;
    activeStatusKey?: string | null;

    constructor(data?: IGetPageOfHotelGroupHotelsQuery) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.keywords = _data["keywords"] !== undefined ? _data["keywords"] : <any>null;
            this.sortKey = _data["sortKey"] !== undefined ? _data["sortKey"] : <any>null;
            this.activeStatusKey = _data["activeStatusKey"] !== undefined ? _data["activeStatusKey"] : <any>null;
        }
    }

    static fromJS(data: any): GetPageOfHotelGroupHotelsQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetPageOfHotelGroupHotelsQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["keywords"] = this.keywords !== undefined ? this.keywords : <any>null;
        data["sortKey"] = this.sortKey !== undefined ? this.sortKey : <any>null;
        data["activeStatusKey"] = this.activeStatusKey !== undefined ? this.activeStatusKey : <any>null;
        super.toJSON(data);
        return data; 
    }
}

export interface IGetPageOfHotelGroupHotelsQuery extends IGetPageRequest {
    keywords?: string | null;
    sortKey?: string | null;
    activeStatusKey?: string | null;
}

export class PageOfOfHotelGroupData implements IPageOfOfHotelGroupData {
    items?: HotelGroupData[] | null;
    totalNumberOfItems!: number;

    constructor(data?: IPageOfOfHotelGroupData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(HotelGroupData.fromJS(item));
            }
            this.totalNumberOfItems = _data["totalNumberOfItems"] !== undefined ? _data["totalNumberOfItems"] : <any>null;
        }
    }

    static fromJS(data: any): PageOfOfHotelGroupData {
        data = typeof data === 'object' ? data : {};
        let result = new PageOfOfHotelGroupData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalNumberOfItems"] = this.totalNumberOfItems !== undefined ? this.totalNumberOfItems : <any>null;
        return data; 
    }
}

export interface IPageOfOfHotelGroupData {
    items?: HotelGroupData[] | null;
    totalNumberOfItems: number;
}

export class HotelGroupData implements IHotelGroupData {
    id!: string;
    key?: string | null;
    name?: string | null;
    isActive!: boolean;

    constructor(data?: IHotelGroupData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.key = _data["key"] !== undefined ? _data["key"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.isActive = _data["isActive"] !== undefined ? _data["isActive"] : <any>null;
        }
    }

    static fromJS(data: any): HotelGroupData {
        data = typeof data === 'object' ? data : {};
        let result = new HotelGroupData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["key"] = this.key !== undefined ? this.key : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["isActive"] = this.isActive !== undefined ? this.isActive : <any>null;
        return data; 
    }
}

export interface IHotelGroupData {
    id: string;
    key?: string | null;
    name?: string | null;
    isActive: boolean;
}

export class GetPageOfHotelGroupsQuery extends GetPageRequest implements IGetPageOfHotelGroupsQuery {
    keywords?: string | null;
    sortKey?: string | null;
    activeStatusKey?: string | null;

    constructor(data?: IGetPageOfHotelGroupsQuery) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.keywords = _data["keywords"] !== undefined ? _data["keywords"] : <any>null;
            this.sortKey = _data["sortKey"] !== undefined ? _data["sortKey"] : <any>null;
            this.activeStatusKey = _data["activeStatusKey"] !== undefined ? _data["activeStatusKey"] : <any>null;
        }
    }

    static fromJS(data: any): GetPageOfHotelGroupsQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetPageOfHotelGroupsQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["keywords"] = this.keywords !== undefined ? this.keywords : <any>null;
        data["sortKey"] = this.sortKey !== undefined ? this.sortKey : <any>null;
        data["activeStatusKey"] = this.activeStatusKey !== undefined ? this.activeStatusKey : <any>null;
        super.toJSON(data);
        return data; 
    }
}

export interface IGetPageOfHotelGroupsQuery extends IGetPageRequest {
    keywords?: string | null;
    sortKey?: string | null;
    activeStatusKey?: string | null;
}

export class PageOfOfHotelGroupUserData implements IPageOfOfHotelGroupUserData {
    items?: HotelGroupUserData[] | null;
    totalNumberOfItems!: number;

    constructor(data?: IPageOfOfHotelGroupUserData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(HotelGroupUserData.fromJS(item));
            }
            this.totalNumberOfItems = _data["totalNumberOfItems"] !== undefined ? _data["totalNumberOfItems"] : <any>null;
        }
    }

    static fromJS(data: any): PageOfOfHotelGroupUserData {
        data = typeof data === 'object' ? data : {};
        let result = new PageOfOfHotelGroupUserData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalNumberOfItems"] = this.totalNumberOfItems !== undefined ? this.totalNumberOfItems : <any>null;
        return data; 
    }
}

export interface IPageOfOfHotelGroupUserData {
    items?: HotelGroupUserData[] | null;
    totalNumberOfItems: number;
}

export class HotelGroupUserData implements IHotelGroupUserData {
    id!: string;
    firstName?: string | null;
    lastName?: string | null;
    username?: string | null;
    userSubGroupName?: string | null;
    userGroupName?: string | null;
    isSubGroupLeader!: boolean;
    isActive!: boolean;

    constructor(data?: IHotelGroupUserData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.firstName = _data["firstName"] !== undefined ? _data["firstName"] : <any>null;
            this.lastName = _data["lastName"] !== undefined ? _data["lastName"] : <any>null;
            this.username = _data["username"] !== undefined ? _data["username"] : <any>null;
            this.userSubGroupName = _data["userSubGroupName"] !== undefined ? _data["userSubGroupName"] : <any>null;
            this.userGroupName = _data["userGroupName"] !== undefined ? _data["userGroupName"] : <any>null;
            this.isSubGroupLeader = _data["isSubGroupLeader"] !== undefined ? _data["isSubGroupLeader"] : <any>null;
            this.isActive = _data["isActive"] !== undefined ? _data["isActive"] : <any>null;
        }
    }

    static fromJS(data: any): HotelGroupUserData {
        data = typeof data === 'object' ? data : {};
        let result = new HotelGroupUserData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["firstName"] = this.firstName !== undefined ? this.firstName : <any>null;
        data["lastName"] = this.lastName !== undefined ? this.lastName : <any>null;
        data["username"] = this.username !== undefined ? this.username : <any>null;
        data["userSubGroupName"] = this.userSubGroupName !== undefined ? this.userSubGroupName : <any>null;
        data["userGroupName"] = this.userGroupName !== undefined ? this.userGroupName : <any>null;
        data["isSubGroupLeader"] = this.isSubGroupLeader !== undefined ? this.isSubGroupLeader : <any>null;
        data["isActive"] = this.isActive !== undefined ? this.isActive : <any>null;
        return data; 
    }
}

export interface IHotelGroupUserData {
    id: string;
    firstName?: string | null;
    lastName?: string | null;
    username?: string | null;
    userSubGroupName?: string | null;
    userGroupName?: string | null;
    isSubGroupLeader: boolean;
    isActive: boolean;
}

export class GetPageOfHotelGroupUsersQuery extends GetPageRequest implements IGetPageOfHotelGroupUsersQuery {
    keywords?: string | null;
    sortKey?: string | null;
    activeStatusKey?: string | null;

    constructor(data?: IGetPageOfHotelGroupUsersQuery) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.keywords = _data["keywords"] !== undefined ? _data["keywords"] : <any>null;
            this.sortKey = _data["sortKey"] !== undefined ? _data["sortKey"] : <any>null;
            this.activeStatusKey = _data["activeStatusKey"] !== undefined ? _data["activeStatusKey"] : <any>null;
        }
    }

    static fromJS(data: any): GetPageOfHotelGroupUsersQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetPageOfHotelGroupUsersQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["keywords"] = this.keywords !== undefined ? this.keywords : <any>null;
        data["sortKey"] = this.sortKey !== undefined ? this.sortKey : <any>null;
        data["activeStatusKey"] = this.activeStatusKey !== undefined ? this.activeStatusKey : <any>null;
        super.toJSON(data);
        return data; 
    }
}

export interface IGetPageOfHotelGroupUsersQuery extends IGetPageRequest {
    keywords?: string | null;
    sortKey?: string | null;
    activeStatusKey?: string | null;
}

export class DeleteHotelGroupCommand implements IDeleteHotelGroupCommand {
    id!: string;

    constructor(data?: IDeleteHotelGroupCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
        }
    }

    static fromJS(data: any): DeleteHotelGroupCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteHotelGroupCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        return data; 
    }
}

export interface IDeleteHotelGroupCommand {
    id: string;
}

export class DeleteHotelGroupHotelCommand implements IDeleteHotelGroupHotelCommand {
    id?: string | null;

    constructor(data?: IDeleteHotelGroupHotelCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
        }
    }

    static fromJS(data: any): DeleteHotelGroupHotelCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteHotelGroupHotelCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        return data; 
    }
}

export interface IDeleteHotelGroupHotelCommand {
    id?: string | null;
}

export class SaveHotelGroup implements ISaveHotelGroup {
    connectionKey?: string | null;
    key?: string | null;
    name?: string | null;
    isActive!: boolean;
    connectionStringUserId?: string | null;
    connectionStringPassword?: string | null;
    connectionStringHost?: string | null;
    connectionStringPort?: string | null;
    connectionStringDatabase?: string | null;
    connectionStringPooling!: boolean;

    constructor(data?: ISaveHotelGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.connectionKey = _data["connectionKey"] !== undefined ? _data["connectionKey"] : <any>null;
            this.key = _data["key"] !== undefined ? _data["key"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.isActive = _data["isActive"] !== undefined ? _data["isActive"] : <any>null;
            this.connectionStringUserId = _data["connectionStringUserId"] !== undefined ? _data["connectionStringUserId"] : <any>null;
            this.connectionStringPassword = _data["connectionStringPassword"] !== undefined ? _data["connectionStringPassword"] : <any>null;
            this.connectionStringHost = _data["connectionStringHost"] !== undefined ? _data["connectionStringHost"] : <any>null;
            this.connectionStringPort = _data["connectionStringPort"] !== undefined ? _data["connectionStringPort"] : <any>null;
            this.connectionStringDatabase = _data["connectionStringDatabase"] !== undefined ? _data["connectionStringDatabase"] : <any>null;
            this.connectionStringPooling = _data["connectionStringPooling"] !== undefined ? _data["connectionStringPooling"] : <any>null;
        }
    }

    static fromJS(data: any): SaveHotelGroup {
        data = typeof data === 'object' ? data : {};
        let result = new SaveHotelGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["connectionKey"] = this.connectionKey !== undefined ? this.connectionKey : <any>null;
        data["key"] = this.key !== undefined ? this.key : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["isActive"] = this.isActive !== undefined ? this.isActive : <any>null;
        data["connectionStringUserId"] = this.connectionStringUserId !== undefined ? this.connectionStringUserId : <any>null;
        data["connectionStringPassword"] = this.connectionStringPassword !== undefined ? this.connectionStringPassword : <any>null;
        data["connectionStringHost"] = this.connectionStringHost !== undefined ? this.connectionStringHost : <any>null;
        data["connectionStringPort"] = this.connectionStringPort !== undefined ? this.connectionStringPort : <any>null;
        data["connectionStringDatabase"] = this.connectionStringDatabase !== undefined ? this.connectionStringDatabase : <any>null;
        data["connectionStringPooling"] = this.connectionStringPooling !== undefined ? this.connectionStringPooling : <any>null;
        return data; 
    }
}

export interface ISaveHotelGroup {
    connectionKey?: string | null;
    key?: string | null;
    name?: string | null;
    isActive: boolean;
    connectionStringUserId?: string | null;
    connectionStringPassword?: string | null;
    connectionStringHost?: string | null;
    connectionStringPort?: string | null;
    connectionStringDatabase?: string | null;
    connectionStringPooling: boolean;
}

export class InsertHotelGroupCommand extends SaveHotelGroup implements IInsertHotelGroupCommand {

    constructor(data?: IInsertHotelGroupCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): InsertHotelGroupCommand {
        data = typeof data === 'object' ? data : {};
        let result = new InsertHotelGroupCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IInsertHotelGroupCommand extends ISaveHotelGroup {
}

export class SaveHotelGroupHotelData implements ISaveHotelGroupHotelData {
    id?: string | null;
    name?: string | null;
    windowsTimeZoneId?: string | null;

    constructor(data?: ISaveHotelGroupHotelData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.windowsTimeZoneId = _data["windowsTimeZoneId"] !== undefined ? _data["windowsTimeZoneId"] : <any>null;
        }
    }

    static fromJS(data: any): SaveHotelGroupHotelData {
        data = typeof data === 'object' ? data : {};
        let result = new SaveHotelGroupHotelData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["windowsTimeZoneId"] = this.windowsTimeZoneId !== undefined ? this.windowsTimeZoneId : <any>null;
        return data; 
    }
}

export interface ISaveHotelGroupHotelData {
    id?: string | null;
    name?: string | null;
    windowsTimeZoneId?: string | null;
}

export class InsertHotelGroupHotelCommand extends SaveHotelGroupHotelData implements IInsertHotelGroupHotelCommand {

    constructor(data?: IInsertHotelGroupHotelCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): InsertHotelGroupHotelCommand {
        data = typeof data === 'object' ? data : {};
        let result = new InsertHotelGroupHotelCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IInsertHotelGroupHotelCommand extends ISaveHotelGroupHotelData {
}

export class UpdateHotelGroupCommand extends SaveHotelGroup implements IUpdateHotelGroupCommand {
    id!: string;

    constructor(data?: IUpdateHotelGroupCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
        }
    }

    static fromJS(data: any): UpdateHotelGroupCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateHotelGroupCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        super.toJSON(data);
        return data; 
    }
}

export interface IUpdateHotelGroupCommand extends ISaveHotelGroup {
    id: string;
}

export class UpdateHotelGroupHotelCommand extends SaveHotelGroupHotelData implements IUpdateHotelGroupHotelCommand {

    constructor(data?: IUpdateHotelGroupHotelCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): UpdateHotelGroupHotelCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateHotelGroupHotelCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IUpdateHotelGroupHotelCommand extends ISaveHotelGroupHotelData {
}

export class TimeZoneData implements ITimeZoneData {
    id?: string | null;
    name?: string | null;

    constructor(data?: ITimeZoneData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
        }
    }

    static fromJS(data: any): TimeZoneData {
        data = typeof data === 'object' ? data : {};
        let result = new TimeZoneData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface ITimeZoneData {
    id?: string | null;
    name?: string | null;
}

export class GetListOfWindowsTimeZonesQuery implements IGetListOfWindowsTimeZonesQuery {

    constructor(data?: IGetListOfWindowsTimeZonesQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): GetListOfWindowsTimeZonesQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetListOfWindowsTimeZonesQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IGetListOfWindowsTimeZonesQuery {
}

export class ProductListItem implements IProductListItem {
    id?: string | null;
    name?: string | null;

    constructor(data?: IProductListItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
        }
    }

    static fromJS(data: any): ProductListItem {
        data = typeof data === 'object' ? data : {};
        let result = new ProductListItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface IProductListItem {
    id?: string | null;
    name?: string | null;
}

export class GetListOfProductsQuery implements IGetListOfProductsQuery {

    constructor(data?: IGetListOfProductsQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): GetListOfProductsQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetListOfProductsQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IGetListOfProductsQuery {
}

export class ProcessResponseOfMasterUserModel extends ProcessResponse implements IProcessResponseOfMasterUserModel {
    data?: MasterUserModel | null;

    constructor(data?: IProcessResponseOfMasterUserModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.data = _data["data"] ? MasterUserModel.fromJS(_data["data"]) : <any>null;
        }
    }

    static fromJS(data: any): ProcessResponseOfMasterUserModel {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessResponseOfMasterUserModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        super.toJSON(data);
        return data; 
    }
}

export interface IProcessResponseOfMasterUserModel extends IProcessResponse {
    data?: MasterUserModel | null;
}

export class MasterUserModel implements IMasterUserModel {
    id!: string;
    email?: string | null;
    userName?: string | null;

    constructor(data?: IMasterUserModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.userName = _data["userName"] !== undefined ? _data["userName"] : <any>null;
        }
    }

    static fromJS(data: any): MasterUserModel {
        data = typeof data === 'object' ? data : {};
        let result = new MasterUserModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["userName"] = this.userName !== undefined ? this.userName : <any>null;
        return data; 
    }
}

export interface IMasterUserModel {
    id: string;
    email?: string | null;
    userName?: string | null;
}

export class UserDetailsData implements IUserDetailsData {
    id!: string;
    username?: string | null;
    email?: string | null;

    constructor(data?: IUserDetailsData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.username = _data["username"] !== undefined ? _data["username"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
        }
    }

    static fromJS(data: any): UserDetailsData {
        data = typeof data === 'object' ? data : {};
        let result = new UserDetailsData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["username"] = this.username !== undefined ? this.username : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        return data; 
    }
}

export interface IUserDetailsData {
    id: string;
    username?: string | null;
    email?: string | null;
}

export class GetUserDetailsQuery implements IGetUserDetailsQuery {
    id!: string;

    constructor(data?: IGetUserDetailsQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
        }
    }

    static fromJS(data: any): GetUserDetailsQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserDetailsQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        return data; 
    }
}

export interface IGetUserDetailsQuery {
    id: string;
}

export class PageOfOfUserGridData implements IPageOfOfUserGridData {
    items?: UserGridData[] | null;
    totalNumberOfItems!: number;

    constructor(data?: IPageOfOfUserGridData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserGridData.fromJS(item));
            }
            this.totalNumberOfItems = _data["totalNumberOfItems"] !== undefined ? _data["totalNumberOfItems"] : <any>null;
        }
    }

    static fromJS(data: any): PageOfOfUserGridData {
        data = typeof data === 'object' ? data : {};
        let result = new PageOfOfUserGridData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalNumberOfItems"] = this.totalNumberOfItems !== undefined ? this.totalNumberOfItems : <any>null;
        return data; 
    }
}

export interface IPageOfOfUserGridData {
    items?: UserGridData[] | null;
    totalNumberOfItems: number;
}

export class UserGridData implements IUserGridData {
    id!: string;
    username?: string | null;
    email?: string | null;

    constructor(data?: IUserGridData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.username = _data["username"] !== undefined ? _data["username"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
        }
    }

    static fromJS(data: any): UserGridData {
        data = typeof data === 'object' ? data : {};
        let result = new UserGridData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["username"] = this.username !== undefined ? this.username : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        return data; 
    }
}

export interface IUserGridData {
    id: string;
    username?: string | null;
    email?: string | null;
}

export class GetPageOfUsersQuery extends GetPageRequest implements IGetPageOfUsersQuery {
    keywords?: string | null;
    sortKey?: string | null;

    constructor(data?: IGetPageOfUsersQuery) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.keywords = _data["keywords"] !== undefined ? _data["keywords"] : <any>null;
            this.sortKey = _data["sortKey"] !== undefined ? _data["sortKey"] : <any>null;
        }
    }

    static fromJS(data: any): GetPageOfUsersQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetPageOfUsersQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["keywords"] = this.keywords !== undefined ? this.keywords : <any>null;
        data["sortKey"] = this.sortKey !== undefined ? this.sortKey : <any>null;
        super.toJSON(data);
        return data; 
    }
}

export interface IGetPageOfUsersQuery extends IGetPageRequest {
    keywords?: string | null;
    sortKey?: string | null;
}

export class InsertUserCommand implements IInsertUserCommand {
    email?: string | null;
    userName?: string | null;
    password?: string | null;

    constructor(data?: IInsertUserCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.userName = _data["userName"] !== undefined ? _data["userName"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
        }
    }

    static fromJS(data: any): InsertUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new InsertUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["userName"] = this.userName !== undefined ? this.userName : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        return data; 
    }
}

export interface IInsertUserCommand {
    email?: string | null;
    userName?: string | null;
    password?: string | null;
}

export class UpdateUserCommand implements IUpdateUserCommand {
    id!: string;
    email?: string | null;
    userName?: string | null;
    password?: string | null;

    constructor(data?: IUpdateUserCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.userName = _data["userName"] !== undefined ? _data["userName"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
        }
    }

    static fromJS(data: any): UpdateUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["userName"] = this.userName !== undefined ? this.userName : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        return data; 
    }
}

export interface IUpdateUserCommand {
    id: string;
    email?: string | null;
    userName?: string | null;
    password?: string | null;
}

export class DeactivateUserCommand implements IDeactivateUserCommand {
    id!: string;

    constructor(data?: IDeactivateUserCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
        }
    }

    static fromJS(data: any): DeactivateUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeactivateUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        return data; 
    }
}

export interface IDeactivateUserCommand {
    id: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}