using MediatR;
using Microsoft.AspNetCore.Http;
using Microsoft.EntityFrameworkCore;
using Npgsql;
using Planner.Application.Interfaces;
using Planner.Common.Data;
using CPSAT = Planner.CpsatCleaningCalculator;
using Planner.Domain.Entities;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Globalization;
using Planner.Application.CleaningPlans.Queries.GetCleaningPlanDetails;
using Microsoft.AspNetCore.SignalR;
using Microsoft.Extensions.DependencyInjection;
using Planner.Common.Extensions;
using Planner.Common.Enums;
using Planner.Application.Infrastructure;
using Planner.Application.Infrastructure.Signalr.Hubs;
using Planner.Application.Infrastructure.Signalr.ClientDefinitions;
using Planner.Application.Infrastructure.Signalr.Services;

namespace Planner.Application.CleaningPlans.Commands.GenerateCpsatCleaningPlan
{
	//public class CleaningPlanProgressMessage
	//{
	//	public Guid CleaningPlanId { get; set; }
	//	public string StatusKey { get; set; }
	//	public string Message { get; set; }
	//	public string DateTimeString { get; set; }
	//}

	///// <summary>
	///// This interface really describes the callable methods on the client.
	///// </summary>
	//public interface ICleaningPlanHubClient
	//{
	//	/// <summary>
	//	/// Client should implement method called "DisplayCpsatCleaningPlanProgressMessage".
	//	/// </summary>
	//	/// <param name="message"></param>
	//	/// <returns></returns>
	//	Task ReceiveCleaningPlanProgressMessage(CleaningPlanProgressMessage message);
	//	Task ReceiveCleaningPlanResult(CpsatAutogeneratedPlan plan);
	//}

	//public class CleaningPlanHub : Hub<ICleaningPlanHubClient>
	//{
	//	//public void SendCpsatCleaningPlanProgressMessage(Guid cleaningPlanId, string statusKey, string message)
	//	//{
	//	//	var data = new CleaningPlanProgressMessage
	//	//	{
	//	//		CleaningPlanId = cleaningPlanId,
	//	//		Message = message,
	//	//		StatusKey = statusKey,
	//	//	};

	//	//	this.Clients.Caller.ReceiveCleaningPlanProgressMessage(data);
	//	//}
	//}

	public class RoomCleaningStatus
	{
		public RoomWithHotelStructureView Room { get; set; }
		public bool IsClean { get; set; }
		public bool IsOccupied { get; set; }
		public bool HasArrival { get; set; }
		public bool HasDeparture { get; set; }
		public bool HasStay { get; set; }
		public bool HasVipReservation { get; set; }
		public IEnumerable<string> VipValues { get; set; }

		//public string[] StatusKeys { get; set; }
	}

	public class CleanersAndCleanings
	{

		public List<CPSAT.Cleaning> Cleanings { get; set; }
		public List<CPSAT.Attendant> Cleaners { get; set; }
		/// <summary>
		/// RoomId -> RoomCleaningStatus
		/// </summary>
		public Dictionary<Guid, RoomCleaningStatus> RoomCleaningStatusMap { get; set; }
	}


	// public class CpsatContext: CPSAT.CleaningPlannerContext
	// {
	// }

	public class CpsatAutogeneratedPlan: CPSAT.AutoGeneratedPlan
	{
		public IEnumerable<PlannedCleaningTimelineItemData> PlannedTimelineItems { get; set; }
	}

	public class CpsatPlannerCompactConfigurationData
	{
		public string CleaningPriorityKey { get; set; }
		public bool DoUsePrePlan { get; set; }
		public bool DoCompleteProposedPlanOnUsePreplan { get; set; }
		public bool ArePreferredLevelsExclusive { get; set; }

	}

	public class GenerateCpsatCleaningPlanCommand : IRequest<ProcessResponse>
	{
		public Guid CleaningPlanId { get; set; }
		public bool IsTodaysCleaningPlan { get; set; }
		public CpsatPlannerCompactConfigurationData Configuration { get; set; }
	}

	public class BackgroundCpsatCleaningPlanProcess
	{
		private readonly IDatabaseContext _databaseContext;
		private readonly Guid? _userId;
		private readonly Guid? _hotelGroupId;
		private readonly CpsatCleaningPlannerSignalrService _cleaningPlanSignalrService;


		/// <summary>
		/// This is a HORRIBLE HACK.
		/// This field is used inside the cleaning plan result event handler to get already loaded room data.
		/// </summary>
		private Dictionary<Guid, RoomCleaningStatus> _roomCleaningStatusMap;
		private Dictionary<Guid, List<CleaningTimelineItemTaskData>> _tasksMap;

		public BackgroundCpsatCleaningPlanProcess(
			Guid? userId,
			Guid? hotelGroupId,
			IDatabaseContext databaseContext,
			IHubContext<CpsatCleaningPlannerHub, ICpsatCleaningPlannerClientMethods> cpsatCleaningPlannerHub
			)
		{
			this._userId = userId;
			this._hotelGroupId = hotelGroupId;
			this._databaseContext = databaseContext;
			this._cleaningPlanSignalrService = new CpsatCleaningPlannerSignalrService(cpsatCleaningPlannerHub);
		}

		public async Task Calculate(Guid cleaningPlanId, bool isTodaysCleaningPlan, CpsatPlannerCompactConfigurationData compactConfiguration, CancellationToken cancellationToken)
		{
			var cleaningPlan = await this._databaseContext.CleaningPlans
				.Where(c => c.Id == cleaningPlanId)
				.FirstOrDefaultAsync();

			cleaningPlan.UngroupedItems = await this._databaseContext.CleaningPlanItems
				.Where(cpi => cpi.CleaningPlanId == cleaningPlan.Id && cpi.CleaningPlanGroupId == null && cpi.IsActive).ToListAsync();

			var hotelId = cleaningPlan.HotelId;
			var hotel = await this._databaseContext.Hotels.FindAsync(hotelId);

			var hotelSettings = await this._databaseContext.Settings.FirstOrDefaultAsync(s => s.HotelId == hotelId);

			var cpsatStrategy = await this._LoadHotelCleaningCpsatStrategy(hotelId, cleaningPlanId, compactConfiguration, hotelSettings);
			var cpsatCleanersAndCleanings = await this._LoadCleanersAndCleanings(cleaningPlan.UngroupedItems, hotelId, cleaningPlan.Id, cleaningPlan.Date, isTodaysCleaningPlan);

			var timeZoneId = HotelLocalDateProvider.GetAvailableTimeZoneId(hotel.WindowsTimeZoneId, hotel.IanaTimeZoneId);
			var cpsatContext = new CPSAT.CleaningPlannerContext(
				attendants: cpsatCleanersAndCleanings.Cleaners.ToArray(),
				cleanings: cpsatCleanersAndCleanings.Cleanings.ToArray(),
				hotelStrategy: cpsatStrategy,
				timeZoneId: timeZoneId,
				geoDistances: null,
				buildingDistances: CPSAT.Distances.LoadFromJSON(hotelSettings.BuildingsDistanceMatrix),
				roomDistances: CPSAT.Distances.LoadFromJSON(hotelSettings.LevelsDistanceMatrix)
			);

			var planFromDate = cleaningPlan.Date.Date;
			var planToDate = planFromDate.AddDays(1);

			this._roomCleaningStatusMap = cpsatCleanersAndCleanings.RoomCleaningStatusMap;
			this._tasksMap = await this._LoadCleaningTasks(cleaningPlan.HotelId, planFromDate, planToDate);


			var cpsatClaculator = new CPSAT.CleaningPlannerCPSAT(cpsatContext, cleaningPlan.HotelId);
			cpsatClaculator.CpsatPlannerProgressChanged += this._CpsatPlannerProgressChangedHandler;
			cpsatClaculator.CpsatPlannerResultsGenerated += this._CpsatPlannerResultsGeneratedHandler;
			cpsatClaculator.Plan();
			cpsatClaculator.CpsatPlannerProgressChanged -= this._CpsatPlannerProgressChangedHandler;
			cpsatClaculator.CpsatPlannerResultsGenerated -= this._CpsatPlannerResultsGeneratedHandler;
		}


		private async void _CpsatPlannerProgressChangedHandler(object sender, CPSAT.CleaningPlannerCPSAT.ProgressMessage e)
		{
			await this._cleaningPlanSignalrService.CpsatPlanningProgressChanged(this._userId, this._hotelGroupId, e);
		}

		private async void _CpsatPlannerResultsGeneratedHandler(object sender, CPSAT.AutoGeneratedPlan e)
		{
			// After the plan is generated, cleaning timeline items are created
			var plannedTimelineItems = new List<PlannedCleaningTimelineItemData>();
			var plan = new CpsatAutogeneratedPlan
			{
				CleaningContext = e.CleaningContext,
				PlannedCleanings = e.PlannedCleanings,
				PlannedTimelineItems = plannedTimelineItems,
				HotelId = e.HotelId,
				//CleaningDate = e.CleaningDate,
				//IsTodaysCleaningPlan = e.IsTodaysCleaningPlan,
			};

			foreach(var atttendant in e.CleaningContext.Attendants)
			{
				foreach(var cleaning in atttendant.Cleanings)
				{
					var roomId = new Guid(cleaning.Room.Id);
					var roomStatus = this._roomCleaningStatusMap[roomId];
					var tasks = this._tasksMap.ContainsKey(roomId) ? this._tasksMap[roomId] : new List<CleaningTimelineItemTaskData>();

					plannedTimelineItems.Add(new PlannedCleaningTimelineItemData
					{
						IsTaskGuestRequest = false,
						IsTaskHighPriority = false,
						IsTaskLowPriority = false,
						TaskDescription = null,
						Price = 0,
						Id = cleaning.Id.ToString(),
						CleaningPluginId = cleaning.CleaningPluginId,
						CleaningPluginName = cleaning.CleaningPluginName,
						IsActive = cleaning.IsActive,
						IsCustom = cleaning.IsCustom,
						IsPostponed = cleaning.IsPostponed,
						CleaningPlanGroupId = atttendant.CleaningGroupId?.ToString(),
						Credits = cleaning.Credits,
						End = cleaning.Plan == null ? cleaning.To : cleaning.Plan.To,
						IsClean = roomStatus.IsClean,
						IsOccupied = roomStatus.IsOccupied,
						IsDoNotDisturb = roomStatus.Room.IsDoNotDisturb,
						IsOutOfOrder = roomStatus.Room.IsOutOfOrder,
						IsRoomAssigned = roomStatus.Room.FloorId.HasValue && roomStatus.Room.BuildingId.HasValue,
						ItemTypeKey = "CLEANING",
						RoomId = roomId,
						Start = cleaning.Plan == null ? cleaning.From : cleaning.Plan.From,
						Title = roomStatus.Room.Name,
						Reservations = roomStatus.Room.Reservations.Select(r => { return this._CreateTimelineReservation(r); }).ToArray(),
						Tasks = tasks,
						IsChangeSheets = cleaning.IsChangeSheets,
						CleaningDescription = cleaning.CleaningPluginName,
						HasArrival = roomStatus.HasArrival,
						HasDeparture = roomStatus.HasDeparture,
						HasStay = roomStatus.HasStay,
						AreaId = roomStatus.Room.AreaId,
						AreaName = roomStatus.Room.AreaName,
						BuildingId = roomStatus.Room.BuildingId,
						BuildingName = roomStatus.Room.BuildingName,
						FloorId = roomStatus.Room.FloorId,
						FloorName = roomStatus.Room.FloorName,
						FloorNumber = roomStatus.Room.FloorNumber,
						FloorSectionName = roomStatus.Room.FloorSectionName,
						FloorSubSectionName = roomStatus.Room.FloorSubSectionName,
						HasVipReservation = roomStatus.HasVipReservation,
						HotelId = roomStatus.Room.HotelId,
						HotelName = roomStatus.Room.HotelName,
						RoomCategoryId = roomStatus.Room.CategoryId,
						RoomCategoryName = roomStatus.Room.CategoryName,
						VipValues = roomStatus.VipValues,
					});
				}
			}

			await this._cleaningPlanSignalrService.CpsatPlanningFinished(this._userId, this._hotelGroupId, plan);
		}

		/// <summary>
		/// TODO: THERE IS (ALMOST) A DUPLICATE FO THIS METHOD IN THE CleaningGeneratorService! DRY THIS AS SOON AS POSSIBLE.
		/// TODO: THERE IS (ALMOST) A DUPLICATE FO THIS METHOD IN THE CleaningGeneratorService! DRY THIS AS SOON AS POSSIBLE.
		/// TODO: THERE IS (ALMOST) A DUPLICATE FO THIS METHOD IN THE CleaningGeneratorService! DRY THIS AS SOON AS POSSIBLE.
		/// TODO: THERE IS (ALMOST) A DUPLICATE FO THIS METHOD IN THE CleaningGeneratorService! DRY THIS AS SOON AS POSSIBLE.
		/// </summary>
		/// <param name="r"></param>
		/// <returns></returns>
		private ExtendedCleaningTimelineItemReservationData _CreateTimelineReservation(Reservation r)
		{
			var reservationStatusesMap = new Dictionary<string, RccReservationStatus>
			{
				{ RccReservationStatus.Arrival.ToString(), RccReservationStatus.Arrival },
				{ RccReservationStatus.Canceled.ToString(), RccReservationStatus.Canceled },
				{ RccReservationStatus.Current.ToString(), RccReservationStatus.Current },
				{ RccReservationStatus.Departure.ToString(), RccReservationStatus.Departure },
				{ RccReservationStatus.Departed.ToString(), RccReservationStatus.Departed },
				{ RccReservationStatus.Arrived.ToString(), RccReservationStatus.Arrived },
				{ RccReservationStatus.Unknown.ToString(), RccReservationStatus.Unknown },
			};
			var reservation = new ExtendedCleaningTimelineItemReservationData
			{
				ReservationId = r.Id,
				ReservationStatusKey = r.RccReservationStatusKey,
				RoomId = r.RoomId.HasValue ? r.RoomId.Value : Guid.Empty,
				GuestName = r.GuestName,
				IsVip = r.Vip.IsNotNull(),
				VipTag = r.Vip,
				TypeAndTimeTag = "N/A",
				IsDayUse = r.CheckIn?.Date == r.CheckOut?.Date,
			};

			var reservationStatus = r.RccReservationStatusKey.IsNotNull() && reservationStatusesMap.ContainsKey(r.RccReservationStatusKey) ? reservationStatusesMap[r.RccReservationStatusKey] : RccReservationStatus.Unknown;
			switch (reservationStatus)
			{
				case RccReservationStatus.Arrival:
					reservation.ReservationStatus = "Arrival";
					reservation.TimeString = r.CheckIn.HasValue ? r.CheckIn.Value.ToString("HH:mm") : "";
					reservation.StyleCode = "icofont-login";
					reservation.TypeAndTimeTag = $"{Common.Enums.ReservationOccupationType.ARR.ToString()} {reservation.TimeString}";
					break;
				case RccReservationStatus.Arrived:
					reservation.ReservationStatus = "Arrived";
					reservation.TimeString = r.CheckIn.HasValue ? r.CheckIn.Value.ToString("HH:mm") : "";
					reservation.StyleCode = "icofont-login";
					reservation.TypeAndTimeTag = $"{Common.Enums.ReservationOccupationType.ARR.ToString()} {reservation.TimeString}";
					break;
				case RccReservationStatus.Current:
					reservation.ReservationStatus = "Current";
					reservation.TimeString = "";
					reservation.StyleCode = "icofont-bed";
					reservation.TypeAndTimeTag = $"{Common.Enums.ReservationOccupationType.STAY.ToString()}";
					break;
				case RccReservationStatus.Departure:
					reservation.ReservationStatus = "Departure";
					reservation.TimeString = r.CheckOut.HasValue ? r.CheckOut.Value.ToString("HH:mm") : "";
					reservation.StyleCode = "icofont-logout";
					reservation.TypeAndTimeTag = $"{Common.Enums.ReservationOccupationType.DEP.ToString()} {reservation.TimeString}";
					break;
				case RccReservationStatus.Departed:
					reservation.ReservationStatus = "Departed";
					reservation.TimeString = r.CheckOut.HasValue ? r.CheckOut.Value.ToString("HH:mm") : "";
					reservation.StyleCode = "icofont-logout";
					reservation.TypeAndTimeTag = $"{Common.Enums.ReservationOccupationType.DEP.ToString()} {reservation.TimeString}";
					break;
				case RccReservationStatus.Canceled:
					reservation.ReservationStatus = "Cancelled";
					reservation.TimeString = "";
					reservation.StyleCode = "icofont-close-line-circled";
					break;
				case RccReservationStatus.Unknown:
					reservation.ReservationStatus = "Unknown";
					reservation.TimeString = "";
					reservation.StyleCode = "icofont-question";
					break;
			}
			//var reservationStatus = reservationStatusesMap[r.RccReservationStatusKey];
			//switch (reservationStatus)
			//{
			//	case RccReservationStatus.Arrival:
			//		reservation.ReservationStatus = "Arrival";
			//		reservation.TimeString = r.ActualCheckIn.HasValue ? r.ActualCheckIn.Value.ToString("HH:mm") : r.CheckIn.HasValue ? r.CheckIn.Value.ToString("HH:mm") : "N/A";
			//		reservation.StyleCode = "icofont-login";
			//		reservation.TypeAndTimeTag = $"{Common.Enums.ReservationOccupationType.ARR.ToString()} {reservation.TimeString}";
			//		break;
			//	case RccReservationStatus.Arrived:
			//		reservation.ReservationStatus = "Arrived";
			//		reservation.TimeString = r.ActualCheckIn.HasValue ? r.ActualCheckIn.Value.ToString("HH:mm") : r.CheckIn.HasValue ? r.CheckIn.Value.ToString("HH:mm") : "N/A";
			//		reservation.StyleCode = "icofont-login";
			//		reservation.TypeAndTimeTag = $"{Common.Enums.ReservationOccupationType.ARR.ToString()} {reservation.TimeString}";
			//		break;
			//	case RccReservationStatus.Current:
			//		reservation.ReservationStatus = "Current";
			//		reservation.TimeString = "";
			//		reservation.StyleCode = "icofont-bed";
			//		reservation.TypeAndTimeTag = $"{Common.Enums.ReservationOccupationType.STAY.ToString()}";
			//		break;
			//	case RccReservationStatus.Departure:
			//		reservation.ReservationStatus = "Departure";
			//		reservation.TimeString = r.ActualCheckOut.HasValue ? r.ActualCheckOut.Value.ToString("HH:mm") : r.CheckOut.HasValue ? r.CheckOut.Value.ToString("HH:mm") : "N/A";
			//		reservation.StyleCode = "icofont-logout";
			//		reservation.TypeAndTimeTag = $"{Common.Enums.ReservationOccupationType.DEP.ToString()} {reservation.TimeString}";
			//		break;
			//	case RccReservationStatus.Departed:
			//		reservation.ReservationStatus = "Departed";
			//		reservation.TimeString = r.ActualCheckOut.HasValue ? r.ActualCheckOut.Value.ToString("HH:mm") : r.CheckOut.HasValue ? r.CheckOut.Value.ToString("HH:mm") : "N/A";
			//		reservation.StyleCode = "icofont-logout";
			//		reservation.TypeAndTimeTag = $"{Common.Enums.ReservationOccupationType.DEP.ToString()} {reservation.TimeString}";
			//		break;
			//	case RccReservationStatus.Canceled:
			//		reservation.ReservationStatus = "Canceled";
			//		reservation.TimeString = "";
			//		reservation.StyleCode = "icofont-close-line-circled";
			//		break;
			//	case RccReservationStatus.Unknown:
			//		reservation.ReservationStatus = "Unknown";
			//		reservation.TimeString = "";
			//		reservation.StyleCode = "icofont-question";
			//		break;
			//}

			return reservation;
		}

		private class _RoomsData
		{
			public Dictionary<Guid, RoomCleaningStatus> RoomCleaningStatusesMap { get; set; } = new Dictionary<Guid, RoomCleaningStatus>();
			public Dictionary<Guid, int> RoomsPerFloorMap { get; set; } = new Dictionary<Guid, int>();

			public Dictionary<Guid, Domain.Entities.Floor> FloorsMap { get; set; } = new Dictionary<Guid, Floor>();
			public Dictionary<Guid, Domain.Entities.Building> BuildingsMap { get; set; } = new Dictionary<Guid, Building>();
		}

		private async Task<_RoomsData> _LoadRoomsAndActiveReservations(string hotelId, DateTime cleaningDate, bool isTodaysCleaningPlan)
		{
			var data = new _RoomsData();
			var floorsMap = await this._databaseContext.Floors.Include(f => f.Building).Where(b => b.HotelId == hotelId).ToDictionaryAsync(b => b.Id);
			foreach(var floor in floorsMap.Values)
			{
				data.FloorsMap.Add(floor.Id, floor);
				if (!data.BuildingsMap.ContainsKey(floor.Building.Id))
				{
					data.BuildingsMap.Add(floor.Building.Id, floor.Building);
				}
			}

			var roomsMap = (await this._databaseContext.Rooms.GetRoomsWithStructureAndActiveReservationsQuery(hotelId, cleaningDate, null, null, null, null, null, true, isTodaysCleaningPlan, true).ToArrayAsync())
					.Select(room =>
					{
						room.SetReservationCheckInTimesToActualCheckInTimes(); // TODO: REMOVE THIS!!!

						if (room.FloorId.HasValue)
						{
							var floor = floorsMap[room.FloorId.Value];
							room.Floor = floor;
							room.Building = floor.Building;

							if (!data.RoomsPerFloorMap.ContainsKey(room.FloorId.Value))
							{
								data.RoomsPerFloorMap.Add(room.FloorId.Value, 0);
							}

							data.RoomsPerFloorMap[room.FloorId.Value] += 1;
						}

						return room;
					})
					.ToDictionary(r => r.Id, r => r);

			var planFromDate = cleaningDate.Date;
			foreach(var room in roomsMap.Values)
			{
				var status = room.GenerateCleaningStatus(planFromDate, isTodaysCleaningPlan);
				data.RoomCleaningStatusesMap.Add(status.Room.Id, status);
			}

			return data;
		}

		private async Task<CleanersAndCleanings> _LoadCleanersAndCleanings(IEnumerable<CleaningPlanItem> plannableCleanings, string hotelId, Guid cleaningPlanId, DateTime cleaningDate, bool isTodaysCleaningPlan)
		{
			var planGroups = await this._databaseContext
				.CleaningPlanGroups
				.Include(cpg => cpg.Cleaner)
				.Where(cpg => cpg.CleaningPlanId == cleaningPlanId)
				.ToListAsync();

			var cleaningPlanGroupIds = planGroups.Select(pg => pg.Id).ToArray();

			var planGroupItems = (await this._databaseContext
				.CleaningPlanItems
				.Where(cpg => cpg.CleaningPlanId == cleaningPlanId && cpg.CleaningPlanGroupId != null && cleaningPlanGroupIds.Contains(cpg.CleaningPlanGroupId.Value))
				.ToListAsync()).GroupBy(i => i.CleaningPlanGroupId.Value).ToDictionary(g => g.Key, g => g.ToArray());

			var availabilityIntervals = (await this._databaseContext
				.CleaningPlanGroupAvailabilityIntervals
				.Where(cpg => cleaningPlanGroupIds.Contains(cpg.CleaningPlanGroupId))
				.ToListAsync()).GroupBy(i => i.CleaningPlanGroupId).ToDictionary(g => g.Key, g => g.ToArray());

			var floorAffinities = await this._databaseContext
				.CleaningPlanGroupAffinities
				.Where(fa => cleaningPlanGroupIds.Contains(fa.CleaningPlanGroupId))
				.Select(fa => new
				{
					CleaningPlanGroupId = fa.CleaningPlanGroupId,
					AffinityType = fa.AffinityType,
					ReferenceId = fa.ReferenceId,
				})
				.ToArrayAsync();

			var roomsData = await this._LoadRoomsAndActiveReservations(hotelId, cleaningDate, isTodaysCleaningPlan);

			var cpsatCleaners = new List<CPSAT.Attendant>();

			foreach (var planGroup in planGroups)
			{
				planGroup.Items = planGroupItems.ContainsKey(planGroup.Id) ? planGroupItems[planGroup.Id] : new CleaningPlanItem[0];
				planGroup.AvailabilityIntervals = availabilityIntervals.ContainsKey(planGroup.Id) ? availabilityIntervals[planGroup.Id] : new CleaningPlanGroupAvailabilityInterval[0];

				var affinities = floorAffinities.Where(fa => fa.CleaningPlanGroupId == planGroup.Id).ToArray();
				var cleanerAffinities = new List<CPSAT.Affinity>();
				foreach(var aff in affinities)
				{
					var cleanerAffinity = new CPSAT.Affinity
					{
						CleaningType = null,
						Room = null,
						RoomType = null,
						AffinityType = CPSAT.AffinityType.UNKNOWN,
					};

					switch (aff.AffinityType)
					{
						case CleaningPlanGroupAffinityType.BUILDING:
							var building = roomsData.BuildingsMap[new Guid(aff.ReferenceId)];

							cleanerAffinity.AffinityType = CPSAT.AffinityType.BUILDING;
							cleanerAffinity.Building = building.Name;
							cleanerAffinity.Floor = null;
							cleanerAffinity.Section = null;
							cleanerAffinity.SubSection = null;
							cleanerAffinity.Level = building.Name;
							break;
						case CleaningPlanGroupAffinityType.FLOOR:
							var floor = roomsData.FloorsMap[new Guid(aff.ReferenceId)];
							var fBuilding = roomsData.BuildingsMap[floor.BuildingId];

							cleanerAffinity.AffinityType = CPSAT.AffinityType.FLOOR;
							cleanerAffinity.Building = fBuilding.Name;
							cleanerAffinity.Floor = floor.Name;
							cleanerAffinity.Section = null;
							cleanerAffinity.SubSection = null;
							cleanerAffinity.Level = $"{fBuilding.Name}:{floor.Name}";
							break;
						case CleaningPlanGroupAffinityType.FLOOR_SECTION:
							// SECTION KEY IS IN FORMAT: {floorId}|{sectionName}
							var sectionKeyParts = aff.ReferenceId.Split('|', StringSplitOptions.RemoveEmptyEntries);
							if(sectionKeyParts.Length != 2)
							{
								// Floor section reference id is not set properly.
								continue;
							}

							var sFloorId = new Guid(sectionKeyParts[0]);
							var sSection = sectionKeyParts[1];
							var sFloor = roomsData.FloorsMap[sFloorId];
							var sBuilding = roomsData.BuildingsMap[sFloor.BuildingId];

							cleanerAffinity.AffinityType = CPSAT.AffinityType.FLOOR_SECTION;
							cleanerAffinity.Building = sBuilding.Name;
							cleanerAffinity.Floor = sFloor.Name;
							cleanerAffinity.Section = sSection;
							cleanerAffinity.SubSection = null;
							cleanerAffinity.Level = $"{sBuilding.Name}:{sFloor.Name}:{sSection}";
							break;
						case CleaningPlanGroupAffinityType.FLOOR_SUB_SECTION:
							// SUBSECTION KEY IS IN FORMAT: {floorId}|{sectionName}|{subSectionName}
							var subSectionKeyParts = aff.ReferenceId.Split('|', StringSplitOptions.RemoveEmptyEntries);
							if (subSectionKeyParts.Length != 3)
							{
								// Floor sub section reference id is not set properly.
								continue;
							}

							var ssFloorId = new Guid(subSectionKeyParts[0]);
							var ssFloor = roomsData.FloorsMap[ssFloorId];
							var ssBuilding = roomsData.BuildingsMap[ssFloor.BuildingId];
							var ssSection = subSectionKeyParts[1];
							var ssSubSection = subSectionKeyParts[2];

							cleanerAffinity.AffinityType = CPSAT.AffinityType.FLOOR_SUB_SECTION;
							cleanerAffinity.Building = ssBuilding.Name;
							cleanerAffinity.Floor = ssFloor.Name;
							cleanerAffinity.Section = ssSection;
							cleanerAffinity.SubSection = ssSubSection;
							cleanerAffinity.Level = $"{ssBuilding.Name}:{ssFloor.Name}:{ssSection}:{ssSubSection}";
							break;
						case CleaningPlanGroupAffinityType.UNKNOWN:
						default:
							// The affinity is improperly configured so just skip it.
							continue;
					}

					cleanerAffinities.Add(cleanerAffinity);
				}

				var cpsatCleaner = new CPSAT.Attendant
				{
					Id = planGroup.CleanerId,
					CleaningGroupId = planGroup.Id,
					GroupName = null, // TODO: GROUPING!!!
					Name = $"{planGroup.Cleaner.FirstName ?? ""} {planGroup.Cleaner.LastName ?? ""}",
					Username = planGroup.Cleaner.UserName,
					CurrentTimeSlots = planGroup.AvailabilityIntervals.Select(ai =>
					{
						var timeSlot = new CPSAT.TimeSlot
						{
							//Affinity = new CPSAT.Affinity_OLD
							//{
							//	Buildings = "",
							//	Levels = "",
							//	Rooms = null,
							//	RoomTypes = null
							//},
							Affinities = cleanerAffinities,
							From = ai.From,
							To = ai.To,
							IsPreferred = false,
							Levels = new List<string>(),
							MaxCredits = planGroup.MaxCredits ?? 0,
							MaxDepartures = planGroup.MaxDepartures ?? 0,
							MaxLevels = 0,
							MaxStays = 0,
							noOfRooms = 0,
						};
						return timeSlot;
					}
					).ToArray(),
					Cleanings = planGroup.Items.Where(i => i.IsPlanned).Select(i => {
						var roomStatus = roomsData.RoomCleaningStatusesMap[i.RoomId];
						var cleaningType = CPSAT.CleaningType.Custom;
						if (roomStatus.HasDeparture)
						{
							cleaningType = CPSAT.CleaningType.Departure;
						}
						else if (roomStatus.HasStay)
						{
							cleaningType = CPSAT.CleaningType.Stay;
						}
						else if (!i.IsCustom)
						{
							cleaningType = CPSAT.CleaningType.Vacant;
						}

						return new CPSAT.Cleaning
						{
							Id = i.Id,
							CleaningPluginId = i.CleaningPluginId,
							CleaningPluginName = i.Description,
							IsActive = i.IsActive,
							IsCustom = i.IsCustom,
							IsPostponed = i.IsPostponed,
							IsChangeSheets = i.IsChangeSheets,

							ArrivalExpected = roomStatus.HasArrival,

							Credits = i.Credits ?? 0,
							//Credits = i.Credits ?? 30, // TODO: INVESTIGATE IF THESE i.Credits are calculated and passed correctly!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!!
							From = i.StartsAt.Value,
							To = i.EndsAt.Value,
							Label = i.Description,
							Levels = new List<string>(),
							Plan = new CPSAT.CleaningPlan
							{
								//Attendant = null,
								CreatedBy = "Unknown creator",
								From = i.StartsAt.Value,
								To = i.EndsAt.Value,
								WorkerUsername = null,
							},
							Tags = null,
							Type = cleaningType,
							Room = new CPSAT.Room
							{
								Address = roomStatus.Room.Building?.Address,
								Floor = new CPSAT.Level
								{
									FloorIndex = roomStatus.Room.Floor == null ? 0 : roomStatus.Room.Floor.Number - 1,
									LevelName = roomStatus.Room.Floor?.Name ?? "N/A",
									RoomsCount = roomStatus.Room.Floor == null ? 0 : roomsData.RoomsPerFloorMap[roomStatus.Room.FloorId.Value],
								},
								GroupName = null,
								Id = roomStatus.Room.Id.ToString(),
								IndexOnFloor = 0,
								IsDirty = !roomStatus.IsClean,
								Latitude = roomStatus.Room.Building?.Latitude?.ToString(),
								Longitude = roomStatus.Room.Building?.Longitude?.ToString(),
								PmsRoomName = roomStatus.Room.ExternalId,
								RoomName = roomStatus.Room.Name,
								RoomType = roomStatus.Room.TypeKey,
								Section = roomStatus.Room.FloorSectionName == null ? null : new CPSAT.Level
								{
									FloorIndex = 0,
									LevelName = roomStatus.Room.FloorSectionName,
									RoomsCount = 0,
								},
								Subsection = roomStatus.Room.FloorSubSectionName == null ? null : new CPSAT.Level
								{
									FloorIndex = 0,
									LevelName = roomStatus.Room.FloorSubSectionName,
									RoomsCount = 0,
								},
							},
						};
					}).ToList(),
				};

				foreach (var c in cpsatCleaner.Cleanings)
				{
					//c.Plan.Attendant = cpsatCleaner;
					c.Plan.WorkerUsername = cpsatCleaner.Name;
				}

				cpsatCleaners.Add(cpsatCleaner);
			}

			var cpsatCleanings = plannableCleanings.Select(i =>
			{
				var roomStatus = roomsData.RoomCleaningStatusesMap[i.RoomId];
				if (roomStatus.Room.Floor == null || roomStatus.Room.Building == null)
				{
					return null;
				}

				var cleaningType = CPSAT.CleaningType.Custom;
				if (roomStatus.HasDeparture)
				{
					cleaningType = CPSAT.CleaningType.Departure;
				}
				else if (roomStatus.HasStay)
				{
					cleaningType = CPSAT.CleaningType.Stay;
				}
				else if (!i.IsCustom)
				{
					cleaningType = CPSAT.CleaningType.Vacant;
				}

				var cleaning = new CPSAT.Cleaning
				{
					Id = i.Id,
					CleaningPluginId = i.CleaningPluginId,
					CleaningPluginName = i.Description,
					IsActive = i.IsActive,
					IsCustom = i.IsCustom,
					IsPostponed = i.IsPostponed,
					IsChangeSheets = i.IsChangeSheets,

					ArrivalExpected = roomStatus.HasArrival,
					Credits = i.Credits ?? 0,
					From = cleaningDate,
					To = cleaningDate.AddDays(1).AddMilliseconds(-1),
					Label = i.Description,
					Levels = new List<string>(),
					Plan = null,
					Tags = null,
					Type = cleaningType,
					Room = new CPSAT.Room
					{
						Address = roomStatus.Room.Building.Address,
						Floor = new CPSAT.Level
						{
							FloorIndex = 0,
							LevelName = roomStatus.Room.Floor.Name,
							RoomsCount = 0,
						},
						GroupName = null,
						Id = roomStatus.Room.Id.ToString(),
						IndexOnFloor = 0,
						IsDirty = !roomStatus.IsClean,
						Latitude = roomStatus.Room.Building.Latitude?.ToString(),
						Longitude = roomStatus.Room.Building.Longitude?.ToString(),
						PmsRoomName = roomStatus.Room.ExternalId,
						RoomName = roomStatus.Room.Name,
						RoomType = roomStatus.Room.TypeKey,
						Section = roomStatus.Room.FloorSectionName == null ? null : new CPSAT.Level
						{
							FloorIndex = 0,
							LevelName = roomStatus.Room.FloorSectionName,
							RoomsCount = 0,
						},
						Subsection = roomStatus.Room.FloorSubSectionName == null ? null : new CPSAT.Level
						{
							FloorIndex = 0,
							LevelName = roomStatus.Room.FloorSubSectionName,
							RoomsCount = 0,
						},
					},
				};

				return cleaning;
			}).Where(i => i != null).ToList();

			return new CleanersAndCleanings
			{
				Cleaners = cpsatCleaners,
				Cleanings = cpsatCleanings,
				RoomCleaningStatusMap = roomsData.RoomCleaningStatusesMap,
			};
		}

		private async Task<CPSAT.HotelStrategy> _LoadHotelCleaningCpsatStrategy(string hotelId, Guid cleaningPlanId, CpsatPlannerCompactConfigurationData compactConfiguration, Settings settings)
		{
			var cpsatConfiguration = await this._databaseContext.CleaningPlanCpsatConfigurations.FindAsync(cleaningPlanId);

			await this._UpdateCleaningPlanCpsatConfigurationData(cpsatConfiguration, compactConfiguration, settings);


			var cpsatHotelStrategy = this._GenerateHotelStrategy(cpsatConfiguration);
			var hotelSettings = await this._databaseContext.Settings.Where(s => s.HotelId == hotelId).FirstOrDefaultAsync();

			cpsatHotelStrategy.DefaultAttendantStartTime = TimeSpan.Parse(hotelSettings.DefaultAttendantStartTime + ":00", CultureInfo.InvariantCulture);
			cpsatHotelStrategy.DefaultAttendantEndTime = TimeSpan.Parse(hotelSettings.DefaultAttendantEndTime + ":00", CultureInfo.InvariantCulture);
			cpsatHotelStrategy.ReserveBetweenCleanings = hotelSettings.ReserveBetweenCleanings ?? cpsatHotelStrategy.ReserveBetweenCleanings;
			cpsatHotelStrategy.TravelReserve = hotelSettings.TravelReserve ?? cpsatHotelStrategy.TravelReserve;
			cpsatHotelStrategy.DefaultMaxCredits = hotelSettings.DefaultAttendantMaxCredits ?? cpsatHotelStrategy.DefaultMaxCredits;

			return cpsatHotelStrategy;
		}

		//private CleaningPlanCpsatConfiguration _GenerateCleaningPlanCpsatConfiguration(Guid cleaningPlanId, CpsatPlannerCompactConfigurationData compactConfiguration, Domain.Entities.CleaningPlanCpsatConfiguration configuration, Settings settings)
		//{
		//	var cpsatConfigurationResult = new CleaningPlanCpsatConfiguration
		//	{
		//		Id = cleaningPlanId,
		//	};

		//	return this._UpdateCleaningPlanCpsatConfigurationData(cpsatConfigurationResult, compactConfiguration, configuration, settings);
		//}

		private async Task _UpdateCleaningPlanCpsatConfigurationData(CleaningPlanCpsatConfiguration cpsatConfigurationResult, CpsatPlannerCompactConfigurationData compactConfiguration, Settings settings)
		{
			//cpsatConfigurationResult.ApplyLevelMovementCreditReductionAfterNumberOfLevels = configuration.ApplyLevelMovementCreditReductionAfterNumberOfLevels;
			cpsatConfigurationResult.ArePreferredLevelsExclusive = compactConfiguration.ArePreferredLevelsExclusive;
			//cpsatConfigurationResult.BalanceByCreditsStrictMaxCredits = configuration.BalanceByCreditsStrictMaxCredits;
			//cpsatConfigurationResult.BalanceByCreditsStrictMinCredits = configuration.BalanceByCreditsStrictMinCredits;
			//cpsatConfigurationResult.BalanceByCreditsWithAffinitiesMaxCredits = configuration.BalanceByCreditsWithAffinitiesMaxCredits;
			//cpsatConfigurationResult.BalanceByCreditsWithAffinitiesMinCredits = configuration.BalanceByCreditsWithAffinitiesMinCredits;
			//cpsatConfigurationResult.BalanceByRoomsMaxRooms = configuration.BalanceByRoomsMaxRooms;
			//cpsatConfigurationResult.BalanceByRoomsMinRooms = configuration.BalanceByRoomsMinRooms;
			cpsatConfigurationResult.BuildingAward = settings.BuildingAward;
			//cpsatConfigurationResult.BuildingMovementCreditsReduction = configuration.BuildingMovementCreditsReduction;
			cpsatConfigurationResult.BuildingsDistanceMatrix = settings.BuildingsDistanceMatrix;
			//cpsatConfigurationResult.CleaningPlan = null;
			cpsatConfigurationResult.CleaningPriorityKey = compactConfiguration.CleaningPriorityKey;
			//cpsatConfigurationResult.WeightCredits = configuration.WeightCredits;
			//cpsatConfigurationResult.DoBalanceStaysAndDepartures = configuration.DoBalanceStaysAndDepartures;
			cpsatConfigurationResult.DoCompleteProposedPlanOnUsePreplan = compactConfiguration.DoCompleteProposedPlanOnUsePreplan;
			//cpsatConfigurationResult.DoesBuildingMovementReduceCredits = configuration.DoesBuildingMovementReduceCredits;
			//cpsatConfigurationResult.DoesLevelMovementReduceCredits = configuration.DoesLevelMovementReduceCredits;
			cpsatConfigurationResult.DoUsePrePlan = compactConfiguration.DoUsePrePlan;
			cpsatConfigurationResult.LevelAward = settings.LevelAward;
			//cpsatConfigurationResult.LevelMovementCreditsReduction = configuration.LevelMovementCreditsReduction;
			cpsatConfigurationResult.LevelsDistanceMatrix = settings.LevelsDistanceMatrix;
			//cpsatConfigurationResult.MaxNumberOfBuildingsPerAttendant = configuration.MaxNumberOfBuildingsPerAttendant;
			//cpsatConfigurationResult.MaxBuildingTravelTime = configuration.MaxBuildingTravelTime;
			//cpsatConfigurationResult.MaxDeparture = configuration.MaxDeparture;
			//cpsatConfigurationResult.MaxNumberOfLevelsPerAttendant = configuration.MaxNumberOfLevelsPerAttendant;
			//cpsatConfigurationResult.MaxStay = configuration.MaxStay;
			//cpsatConfigurationResult.MaxTravelTime = configuration.MaxTravelTime;
			//cpsatConfigurationResult.PlanningStrategyTypeKey = configuration.PlanningStrategyTypeKey;
			cpsatConfigurationResult.RoomAward = settings.RoomAward;
			//cpsatConfigurationResult.SolverRunTime = configuration.SolverRunTime;
			//cpsatConfigurationResult.TargetByCreditsValue = configuration.TargetByCreditsValue;
			//cpsatConfigurationResult.TargetByRoomsValue = configuration.TargetByRoomsValue;
			//cpsatConfigurationResult.WeightTravelTime = configuration.WeightTravelTime;

			cpsatConfigurationResult.MinCreditsForMultipleCleanersCleaning = settings.MinCreditsForMultipleCleanersCleaning;
			cpsatConfigurationResult.MinutesPerCredit = settings.MinutesPerCredit;
			cpsatConfigurationResult.WeightCredits = settings.WeightCredits;
			cpsatConfigurationResult.WeightLevelChange = settings.WeightLevelChange;

			await this._databaseContext.SaveChangesAsync(CancellationToken.None);
		}

		//private async Task _InsertDefaultCpsatHotelStrategy(CPSAT.HotelStrategy cpsatHotelStrategy, Guid cleaningPlanId, string planningStrategyTypeKey)
		//{
		//	var cpsatConfiguration = this._GenerateCleaningPlanCpsatConfiguration(cleaningPlanId, planningStrategyTypeKey, cpsatHotelStrategy);
		//	await this._databaseContext.CleaningPlanCpsatConfigurations.AddAsync(cpsatConfiguration);
		//	await this._databaseContext.SaveChangesAsync(CancellationToken.None);
		//}

		private CPSAT.HotelStrategy _GenerateHotelStrategy(CleaningPlanCpsatConfiguration config)
		{

			var cpsat= new CPSAT.HotelStrategy
			{
				DefaultAttendantStartTime = TimeSpan.FromHours(8),
				DefaultAttendantEndTime = TimeSpan.FromHours(20),
				DefaultMaxCredits = 0,
				ReserveBetweenCleanings = 15,
				TravelReserve = 5,
				CPSat = new CPSAT.CPSat
				{
					awardBuilding = config.BuildingAward,
					awardLevel = config.LevelAward,
					awardRoom = config.RoomAward,
					balanceStayDepartMode = config.DoBalanceStaysAndDepartures,
					buildingMovementEquivalentCredits = config.BuildingMovementCreditsReduction,
					buildingMovementReducesCredits = config.DoesBuildingMovementReduceCredits,
					buildingsDistanceMatrix = config.BuildingsDistanceMatrix,
					cleaningPriorities = config.CleaningPriorityKey,
					CommunicatingRooms = new List<List<CPSAT.Room>>(),
					CompletePrePlan = config.DoCompleteProposedPlanOnUsePreplan,
					//epsilonCredits = -1,
					//epsilonRooms = 0,
					levelMovementEquivalentCredits = config.LevelMovementCreditsReduction,
					levelMovementReducesCredits = config.DoesLevelMovementReduceCredits,
					maxNumberOfBuildingsPerAttendant = config.MaxNumberOfBuildingsPerAttendant,
					maxBuildingToBuildingDistanceAllowed = 60,
					maxBuildingTravelTime = config.MaxBuildingTravelTime,
					//maxCredits = 300,
					maxDepartures = config.MaxDeparture,
					maxNumberOfLevelsPerAttendant = config.MaxNumberOfLevelsPerAttendant,
					//maxRooms = config.BalanceByRoomsMaxRooms,
					maxShiftFloorAllowed = 10,//config.ApplyLevelMovementCreditReductionAfterNumberOfLevels,
					maxStays = config.MaxStay,
					maxTravelTime = config.MaxTravelTime,
					//minCredits = 1,
					//minRooms = config.BalanceByRoomsMinRooms,
					otherCleaningPriorities = "",
					preferredLevelsAreExclusive = config.ArePreferredLevelsExclusive,
					SolutionResult = new CPSAT.CPSatSolutionInformation(),
					solverRunTime = config.SolverRunTime,
					targetModeMinimizeAttendants = false,
					UsePrePlan = config.DoUsePrePlan,
					useTargetMode = false,
					weightBuildingAward = config.BuildingAward,
					weightLevelAward = config.LevelAward,
					weightRoomAward = config.RoomAward,
					weightepsilonStayDepart = config.WeightEpsilonStayDeparture,
					weightCredits = config.WeightCredits,
					weightTravelTime = config.WeightTravelTime,
					weightRoomsCleaned = config.WeightRoomsCleaned,
					weightLevelChange = config.WeightLevelChange,
					//weightFloorsCompleted=config.WeightFloorsCompleted,
					maxDeparturesEquivalentCredits = config.MaxDeparturesEquivalentCredits,
					maxDeparturesReducesCredits=config.MaxDeparturesReducesCredits,
					maxDeparturesReductionThreshold=config.MaxDeparturesReductionThreshold,
					maxStaysEquivalentCredits=config.MaxStaysEquivalentCredits,
					maxStaysIncreasesCredits=config.MaxStaysIncreasesCredits,
					maxStaysIncreaseThreshold=config.MaxStaysIncreaseThreshold,
					minCreditsForMultipleCleanersCleaning=config.MinCreditsForMultipleCleanersCleaning,
					minutesPerCredit=(float)config.MinutesPerCredit


					// TODO: Jonathan, here is where you should add those values you've added from the "config" object. Everything should already be loaded there
					// TODO: Jonathan, here is where you should add those values you've added from the "config" object. Everything should already be loaded there
					// TODO: Jonathan, here is where you should add those values you've added from the "config" object. Everything should already be loaded there
					// TODO: Jonathan, here is where you should add those values you've added from the "config" object. Everything should already be loaded there
					// TODO: Jonathan, here is where you should add those values you've added from the "config" object. Everything should already be loaded there
					// TODO: Jonathan, here is where you should add those values you've added from the "config" object. Everything should already be loaded there

					// THESE FIELDS BELOW ARE THE NEW FILEDS, THEY SHOULD BE PROPERLY POPULATED FROM THE DB AND SETTINGS

					//config.WeightLevelChange, OK
					//config.WeightCredits,

					//config.MaxDeparturesEquivalentCredits,
					//config.MaxDeparturesReducesCredits,
					//config.MaxDeparturesReductionThreshold,
					//config.MaxStaysEquivalentCredits,
					//config.MaxStaysIncreasesCredits,
					//config.MaxStaysIncreaseThreshold,

					//config.MinCreditsForMultipleCleanersCleaning,
					//config.MinutesPerCredit,
				},
			};



			switch (config.PlanningStrategyTypeKey)
			{
				case "BALANCE_BY_ROOMS":
					cpsat.CPSat.strategy = "balanceByRooms";
					cpsat.CPSat.epsilonCredits = 0;
					cpsat.CPSat.epsilonRooms = -1;
					cpsat.CPSat.minRooms = config.BalanceByRoomsMinRooms;
					cpsat.CPSat.maxRooms = config.BalanceByRoomsMaxRooms;

					cpsat.CPSat.useTargetMode = false;
					cpsat.CPSat.targetModeMinimizeAttendants = false;

					break;
				case "BALANCE_BY_CREDITS_STRICT":
					cpsat.CPSat.epsilonCredits = -1;
					cpsat.CPSat.epsilonRooms = 0;
					cpsat.CPSat.strategy = "balanceByCredits";

					cpsat.CPSat.minRooms = config.BalanceByCreditsStrictMinCredits;
					cpsat.CPSat.maxRooms = config.BalanceByCreditsStrictMaxCredits;

					cpsat.CPSat.useTargetMode = false;
					cpsat.CPSat.targetModeMinimizeAttendants = false;
					break;
				case "BALANCE_BY_CREDITS_WITH_AFFINITIES":
					cpsat.CPSat.epsilonCredits = -1;
					cpsat.CPSat.epsilonRooms = 0;
					cpsat.CPSat.strategy = "balanceByCredits";

					cpsat.CPSat.minCredits = config.BalanceByCreditsWithAffinitiesMinCredits;
					cpsat.CPSat.maxCredits = config.BalanceByCreditsWithAffinitiesMaxCredits;

					cpsat.CPSat.useTargetMode = false;
					cpsat.CPSat.targetModeMinimizeAttendants = false;

					break;
				case "TARGET_BY_ROOMS":
					cpsat.CPSat.epsilonCredits = 0;
					cpsat.CPSat.epsilonRooms = -1;
					cpsat.CPSat.strategy = "targetByRooms";

					cpsat.CPSat.maxRooms = int.Parse(config.TargetByRoomsValue);

					cpsat.CPSat.useTargetMode = true;
					cpsat.CPSat.targetModeMinimizeAttendants = false;


					break;
				case "TARGET_BY_CREDITS":
					cpsat.CPSat.strategy = "targetByCredits";
					cpsat.CPSat.epsilonCredits = -1; // james proposed to use -2
					cpsat.CPSat.epsilonRooms = 0;

					cpsat.CPSat.maxCredits = int.Parse(config.TargetByCreditsValue);

					cpsat.CPSat.useTargetMode = true;
					cpsat.CPSat.targetModeMinimizeAttendants = true;

					break;
			}
			return cpsat;

		}

		//private CleaningPlanCpsatConfiguration _GenerateCleaningPlanCpsatConfiguration(Guid cleaningPlanId, string planningStrategyTypeKey, CPSAT.HotelStrategy strategy)
		//{
		//	return new CleaningPlanCpsatConfiguration
		//	{
		//		ApplyLevelMovementCreditReductionAfterNumberOfLevels = 0, //strategy.CPSat.maxShiftFloorAllowed,
		//		ArePreferredLevelsExclusive = strategy.CPSat.preferredLevelsAreExclusive,
		//		BalanceByCreditsStrictMaxCredits = 0,
		//		BalanceByCreditsStrictMinCredits = 0,
		//		BalanceByCreditsWithAffinitiesMaxCredits = 0,
		//		BalanceByCreditsWithAffinitiesMinCredits = 0,
		//		BalanceByRoomsMaxRooms = strategy.CPSat.maxRooms,
		//		BalanceByRoomsMinRooms = strategy.CPSat.minRooms,
		//		BuildingAward = strategy.CPSat.awardBuilding,
		//		BuildingMovementCreditsReduction = strategy.CPSat.buildingMovementEquivalentCredits,
		//		BuildingsDistanceMatrix = strategy.CPSat.buildingsDistanceMatrix,
		//		CleaningPlan = null,
		//		CleaningPriorityKey = strategy.CPSat.cleaningPriorities,
		//		WeightCredits = strategy.CPSat.weightCredits,
		//		DoBalanceStaysAndDepartures = strategy.CPSat.balanceStayDepartMode,
		//		DoCompleteProposedPlanOnUsePreplan = strategy.CPSat.CompletePrePlan,
		//		DoesBuildingMovementReduceCredits = strategy.CPSat.buildingMovementReducesCredits,
		//		DoesLevelMovementReduceCredits = strategy.CPSat.levelMovementReducesCredits,
		//		DoUsePrePlan = strategy.CPSat.UsePrePlan,
		//		Id = cleaningPlanId,
		//		LevelAward = strategy.CPSat.awardLevel,
		//		LevelMovementCreditsReduction = strategy.CPSat.levelMovementEquivalentCredits,
		//		LevelsDistanceMatrix = null,
		//		MaxNumberOfBuildingsPerAttendant = strategy.CPSat.maxNumberOfBuildingsPerAttendant,
		//		MaxBuildingTravelTime = strategy.CPSat.maxBuildingTravelTime,
		//		MaxDeparture = strategy.CPSat.maxDepartures,
		//		MaxNumberOfLevelsPerAttendant = strategy.CPSat.maxNumberOfLevelsPerAttendant,
		//		MaxStay = strategy.CPSat.maxStays,
		//		MaxTravelTime = strategy.CPSat.maxTravelTime,
		//		PlanningStrategyTypeKey = planningStrategyTypeKey,
		//		RoomAward = strategy.CPSat.awardRoom,
		//		SolverRunTime = strategy.CPSat.solverRunTime,
		//		TargetByCreditsValue = null,
		//		TargetByRoomsValue = null,
		//		WeightTravelTime = strategy.CPSat.weightTravelTime,
		//		WeightEpsilonStayDeparture = strategy.CPSat.weightepsilonStayDepart,
		//	};
		//}

		//private CPSAT.HotelStrategy _GetDefaultHotelStrategy()
		//{
		//	return new CPSAT.HotelStrategy
		//	{
		//		DefaultAttendantStartTime = TimeSpan.FromHours(8),
		//		DefaultAttendantEndTime = TimeSpan.FromHours(20),
		//		DefaultMaxCredits = 0,
		//		ReserveBetweenCleanings = 15,
		//		TravelReserve = 5,
		//		CPSat = new CPSAT.CPSat
		//		{
		//			awardBuilding = 1,
		//			awardLevel = 5,
		//			awardRoom = 10,
		//			balanceStayDepartMode = false,
		//			buildingMovementEquivalentCredits = 0,
		//			buildingMovementReducesCredits = false,
		//			buildingsDistanceMatrix = null,
		//			cleaningPriorities = "Departure", // ['Departure', 'Stay', 'Arrival', 'ChangeSheet', 'Others'];
		//			CommunicatingRooms = new List<List<CPSAT.Room>>(),
		//			CompletePrePlan = false,
		//			epsilonCredits = -1,
		//			epsilonRooms = 0,
		//			levelMovementEquivalentCredits = 0,
		//			levelMovementReducesCredits = false,
		//			maxNumberOfBuildingsPerAttendant = 10,
		//			maxBuildingToBuildingDistanceAllowed = 60,
		//			maxBuildingTravelTime = 100,
		//			maxCredits = 300,
		//			maxDepartures = 0,
		//			maxNumberOfLevelsPerAttendant = 10,
		//			maxRooms = 10,
		//			maxShiftFloorAllowed = 10,
		//			maxStays = 0,
		//			maxTravelTime = 1000,
		//			minCredits = 1,
		//			minRooms = 1,
		//			otherCleaningPriorities = "",
		//			preferredLevelsAreExclusive = false,
		//			SolutionResult = new CPSAT.CPSatSolutionInformation(),
		//			solverRunTime = 60,
		//			targetModeMinimizeAttendants = false,
		//			UsePrePlan = true,
		//			useTargetMode = false,
		//			weightBuildingAward = 1,
		//			weightCredits = 1,
		//			weightepsilonStayDepart = 0,
		//			weightLevelAward = 1,
		//			weightRoomAward = 1,
		//			weightRoomsCleaned = 1,
		//			weightTravelTime = -1,
		//		},
		//	};
		//}


		/// <summary>
		/// TODO: THERE IS (ALMOST) A DUPLICATE FO THIS METHOD IN THE CleaningGeneratorService! DRY THIS AS SOON AS POSSIBLE.
		/// TODO: THERE IS (ALMOST) A DUPLICATE FO THIS METHOD IN THE CleaningGeneratorService! DRY THIS AS SOON AS POSSIBLE.
		/// TODO: THERE IS (ALMOST) A DUPLICATE FO THIS METHOD IN THE CleaningGeneratorService! DRY THIS AS SOON AS POSSIBLE.
		/// TODO: THERE IS (ALMOST) A DUPLICATE FO THIS METHOD IN THE CleaningGeneratorService! DRY THIS AS SOON AS POSSIBLE.
		/// </summary>
		/// <param name="r"></param>
		/// <returns></returns>
		private async Task<Dictionary<Guid, List<CleaningTimelineItemTaskData>>> _LoadCleaningTasks(string hotelId, DateTime planFromDate, DateTime planToDate)
		{
			var tasks = await this._databaseContext.SystemTasks.Include(st => st.User).Where(t =>
				(t.FromHotelId == hotelId || t.ToHotelId == hotelId) &&
				t.EventKey == EventTaskType.CLEANING.ToString() &&
				(
					(t.EventTimeKey == TaskEventTimeType.ON_NEXT.ToString()) ||
					(t.EventTimeKey == TaskEventTimeType.ON_DATE.ToString() && planFromDate <= t.StartsAt && planToDate >= t.StartsAt) ||
					(t.EventTimeKey == TaskEventTimeType.EVERY_TIME.ToString() && t.StartsAt <= planToDate)
				)
			).ToArrayAsync();

			var tasksMap = new Dictionary<Guid, List<CleaningTimelineItemTaskData>>();

			foreach (var task in tasks)
			{
				var taskItem = this._CreateTimelineItemTaskData(task);

				if (task.FromRoomId.HasValue)
				{
					if (!tasksMap.ContainsKey(task.FromRoomId.Value))
					{
						tasksMap.Add(task.FromRoomId.Value, new List<CleaningTimelineItemTaskData>());
					}

					tasksMap[task.FromRoomId.Value].Add(taskItem);
				}

				if (task.ToRoomId.HasValue)
				{
					if (!tasksMap.ContainsKey(task.ToRoomId.Value))
					{
						tasksMap.Add(task.ToRoomId.Value, new List<CleaningTimelineItemTaskData>());
					}

					if (!tasksMap[task.FromRoomId.Value].Any(t => t.TaskId == taskItem.TaskId))
					{
						tasksMap[task.FromRoomId.Value].Add(taskItem);
					}
				}
			}

			return tasksMap;
		}

		/// <summary>
		/// TODO: THERE IS (ALMOST) A DUPLICATE FO THIS METHOD IN THE CleaningGeneratorService! DRY THIS AS SOON AS POSSIBLE.
		/// TODO: THERE IS (ALMOST) A DUPLICATE FO THIS METHOD IN THE CleaningGeneratorService! DRY THIS AS SOON AS POSSIBLE.
		/// TODO: THERE IS (ALMOST) A DUPLICATE FO THIS METHOD IN THE CleaningGeneratorService! DRY THIS AS SOON AS POSSIBLE.
		/// TODO: THERE IS (ALMOST) A DUPLICATE FO THIS METHOD IN THE CleaningGeneratorService! DRY THIS AS SOON AS POSSIBLE.
		/// </summary>
		/// <param name="r"></param>
		/// <returns></returns>
		private CleaningTimelineItemTaskData _CreateTimelineItemTaskData(SystemTask t)
		{
			var item = new CleaningTimelineItemTaskData
			{
				Actions = t.Actions.Select(a => new CleaningTimelineItemTaskActionData
				{
					ActionName = a.ActionName,
					AssetName = a.AssetName,
					AssetQuantity = a.AssetQuantity.ToString(),
				}).ToArray(),
				DurationMinutes = 0,
				TaskId = t.Id.ToString(),
				IsCompleted = t.StatusKey == TaskStatusType.FINISHED.ToString() || t.StatusKey == TaskStatusType.VERIFIED.ToString(),
				StatusKey = t.StatusKey,
				IsForPlannedAttendant = t.IsForPlannedAttendant,
				UserId = t.UserId,
				UserFullName = t.User == null ? "N/A" : $"{t.User.FirstName} {t.User.LastName}",
				FromReferenceId = null,
				FromReferenceName = "",
				FromReferenceTypeKey = "NONE",
				ToReferenceId = null,
				ToReferenceName = "",
				ToReferenceTypeKey = "NONE",
			};

			if(t.User == null && t.UserId == null && t.IsForPlannedAttendant)
			{
				item.UserFullName = "Planned attendant";
			}

			if (t.FromWarehouseId.HasValue)
			{
				item.FromReferenceId = t.FromWarehouseId.Value.ToString();
				item.FromReferenceTypeKey = "WAREHOUSE";
				item.FromReferenceName = t.FromName;
			}
			else if (t.FromReservationId.IsNotNull())
			{
				item.FromReferenceId = t.FromReservationId;
				item.FromReferenceTypeKey = "RESERVATION";
				item.FromReferenceName = t.FromName;
			}
			else if (t.FromRoomId.HasValue)
			{
				item.FromReferenceId = t.FromRoomId.Value.ToString();
				item.FromReferenceTypeKey = "ROOM";
				item.FromReferenceName = t.FromName;
			}

			if (t.ToWarehouseId.HasValue)
			{
				item.ToReferenceId = t.ToWarehouseId.Value.ToString();
				item.ToReferenceTypeKey = "WAREHOUSE";
				item.ToReferenceName = t.ToName;
			}
			else if (t.ToReservationId.IsNotNull())
			{
				item.ToReferenceId = t.ToReservationId;
				item.ToReferenceTypeKey = "RESERVATION";
				item.ToReferenceName = t.ToName;
			}
			else if (t.ToRoomId.HasValue)
			{
				item.ToReferenceId = t.ToRoomId.Value.ToString();
				item.ToReferenceTypeKey = "ROOM";
				item.ToReferenceName = t.ToName;
			}

			return item;
		}

	}

	public class GenerateCpsatCleaningPlanCommandHandler : IRequestHandler<GenerateCpsatCleaningPlanCommand, ProcessResponse>, IAmWebApplicationHandler
	{
		private readonly IHttpContextAccessor _httpContextAccessor;
		private readonly IServiceScopeFactory _serviceScopeFactory;

		public GenerateCpsatCleaningPlanCommandHandler(
			IHttpContextAccessor httpContextAccessor,
			IServiceScopeFactory serviceScopeFactory
			)
		{
			this._httpContextAccessor = httpContextAccessor;
			this._serviceScopeFactory = serviceScopeFactory;
		}

		public async Task<ProcessResponse> Handle(GenerateCpsatCleaningPlanCommand request, CancellationToken cancellationToken)
		{
			var userId = this._httpContextAccessor.UserId();
			var hotelGroupId = this._httpContextAccessor.HotelGroupId();

			_ = Task.Run(async () =>
			{
				using (var scope = this._serviceScopeFactory.CreateScope())
				{
					var innerHotelGroupId = hotelGroupId;
					var databaseContext = scope.ServiceProvider.GetRequiredService<IDatabaseContext>();
					databaseContext.SetTenantId(innerHotelGroupId);

					var cleaningPlanHubContext = scope.ServiceProvider.GetRequiredService<IHubContext<CpsatCleaningPlannerHub, ICpsatCleaningPlannerClientMethods>>();

					//var cleaningPlan = await databaseContext.CleaningPlans.FindAsync(request.CleaningPlanId);
					//var hotelSettings = await databaseContext.Settings.FirstOrDefaultAsync(s => s.HotelId == cleaningPlan.HotelId);
					//var cpsatSettings = await databaseContext.CleaningPlanCpsatConfigurations


					var calculator = new BackgroundCpsatCleaningPlanProcess(userId, hotelGroupId, databaseContext, cleaningPlanHubContext);
					await calculator.Calculate(request.CleaningPlanId, request.IsTodaysCleaningPlan, request.Configuration, cancellationToken);
				}
			});

			return new ProcessResponse
			{
				IsSuccess = true,
				HasError = false,
				Message = "Cleaning plan calculation initiated",
			};
		}
	}
}
