import { HttpClient, HttpHeaders } from '@angular/common/http';
import { Injectable } from '@angular/core';
import jwtDecode from 'jwt-decode';
import { Profile, User, UserManager, UserManagerSettings, WebStorageStateStore } from 'oidc-client';
import { BehaviorSubject, concat, from, interval, Observable, of, Subscription } from 'rxjs';
import { catchError, filter, first, flatMap, map, mergeMap, take, tap } from 'rxjs/operators';
import { AuthorizationClient } from '../app/core/autogenerated-clients/api-client';
import { environment } from '../environments/environment';
import { ApplicationPaths, ApplicationName } from './api-authorization.constants';

export type IAuthenticationResult =
  SuccessAuthenticationResult |
  FailureAuthenticationResult |
  RedirectAuthenticationResult;

export interface SuccessAuthenticationResult {
  status: AuthenticationResultStatus.Success;
  state: any;
}

export interface FailureAuthenticationResult {
  status: AuthenticationResultStatus.Fail;
  message: string;
}

export interface RedirectAuthenticationResult {
  status: AuthenticationResultStatus.Redirect;
}

export enum AuthenticationResultStatus {
  Success,
  Redirect,
  Fail
}

export interface IUser {
  name?: string;
}





export interface AuthStateModel {
  tokens?: AuthTokenModel;
  profile?: ProfileModel;
  authReady?: boolean;
}
export interface AuthTokenModel {
  access_token: string;
  refresh_token: string;
  id_token: string;
  expires_in: number;
  token_type: string;
  expiration_date: string;
}
export interface LoginModel {
  hotelGroupKey: string;
  username: string;
  password: string;
  returnUrl: string;
}
export interface ProfileModel {
  sub: string;
  jti: string;
  useage: string;
  at_hash: string;
  nbf: number;
  exp: number;
  iat: number;
  iss: string;

  unique_name: string;
  email_confirmed: boolean;
  role: string[];
}
export interface RefreshGrantModel {
  refresh_token: string;
}



@Injectable({
  providedIn: 'root'
})
export class AuthorizeService {
  private _userManager: UserManager;
  private _userSubject: BehaviorSubject<IUser | null> = new BehaviorSubject(null);

  public isAuthenticated(): Observable<boolean> {
    return this.getUser().pipe(map(u => {
      return !!u;
    }));
  }

  public getUser(): Observable<IUser | null> {
    return concat(
      this._userSubject.pipe(take(1), filter(u => !!u)),
      this._getUserFromStorage().pipe(filter(u => !!u), tap(u => this._userSubject.next(u))),
      this._userSubject.asObservable()
    );
  }

  public getAccessToken(): Observable<string> {
    return from(this._ensureUserManagerInitialized())
      .pipe(mergeMap(() => from(this._userManager.getUser())),
        map(user => user && user.access_token));
  }

  hasClaim(claimType: any): boolean {
    let ret = false;
    const user = this._userSubject.value as Profile;

    // See if an array of values was passed in.
    if (typeof claimType === 'string') {
      if (user != null) {
        ret = user[claimType] !== undefined;
      }
    } else {
      const claims: string[] = claimType;
      if (claims) {
        for (let index = 0; index < claims.length; index++) {
          if (user != null) {
            ret = user[claims[index]] !== undefined;
          }
          // If one is successful, then let them in
          if (ret) {
            break;
          }
        }
      }
    }
    return ret;
  }

  // We try to authenticate the user in three different ways:
  // 1) We try to see if we can authenticate the user silently. This happens
  //    when the user is already logged in on the IdP and is done using a hidden iframe
  //    on the client.
  // 2) If the method above fail, we redirect the browser to the IdP to perform a traditional
  //    redirect flow.
  public async signIn(state: any): Promise<IAuthenticationResult> {
    await this._ensureUserManagerInitialized();

    let user: User = null;

    try {
      // userManager.signInSilent will trigger a silent request (via an iframe or refresh token if available) to the authorization endpoint
      // it throws silentError if the authorization failed
      user = await this._userManager.signinSilent(this._createArguments(state));

      // userManager managed to silently sign in the user
      this._userSubject.next(user.profile);

      // Return the success with 'state' as a query parameter.
      return this._success(state);
    }
    catch (silentError) {
      // User is not authenticated, authenticate via redirect
      try {
        // userManager.signinRedirect will trigger a redirect of the current window to the authorization endpoint
        await this._userManager.signinRedirect(this._createArguments(state));

        // Return the redirect
        return this._redirect();
      }
      catch (redirectError) {
        return this._error(redirectError);
      }
    }
  }

  public async completeSignIn(url: string): Promise<IAuthenticationResult> {
    try {
      await this._ensureUserManagerInitialized();
      const user = await this._userManager.signinCallback(url);
      this._userSubject.next(user && user.profile);
      return this._success(user && user.state);
    } catch (error) {
      return this._error('There was an error signing in.');
    }
  }

  public async signOut(state: any): Promise<IAuthenticationResult> {
      await this._userManager.signoutRedirect(this._createArguments(state));
      return this._redirect();
  }

  public async completeSignOut(url: string): Promise<IAuthenticationResult> {
    await this._ensureUserManagerInitialized();
    try {
      const response = await this._userManager.signoutCallback(url);
      this._userSubject.next(null);
      return this._success(response && response.state);
    } catch (error) {
      return this._error(error);
    }
  }










  private _createArguments(state?: any): any {
    return { useReplaceToNavigate: true, data: state };
  }

  private _error(message: string): IAuthenticationResult {
    return { status: AuthenticationResultStatus.Fail, message };
  }

  private _success(state: any): IAuthenticationResult {
    return { status: AuthenticationResultStatus.Success, state };
  }

  private _redirect(): IAuthenticationResult {
    return { status: AuthenticationResultStatus.Redirect };
  }

  private async _ensureUserManagerInitialized(): Promise<void> {
    if (this._userManager !== undefined) {
      return;
    }

    try {
      const response = await fetch(ApplicationPaths.ApiAuthorizationClientConfigurationUrl);
      if (!response.ok) {
        throw new Error(`Could not load settings for '${ApplicationName}'`);
      }

      const settings: any = await response.json();
      settings.automaticSilentRenew = false;
      settings.includeIdTokenInSilentRenew = true;
      this._userManager = new UserManager(settings);

      this._userManager.events.addUserSignedOut(async () => {
        await this._userManager.removeUser();
        this._userSubject.next(null);
      });
    }
    catch (error) {
      await this._userManager.removeUser();
      this._userSubject.next(null);
    }
  }

  private _getUserFromStorage(): Observable<IUser> {
    return from(this._ensureUserManagerInitialized())
      .pipe(
        mergeMap(() => this._userManager.getUser()),
        map(u => u && u.profile));
  }







  //private initalState: AuthStateModel = { profile: null, tokens: null, authReady: false };
  //private authReady$ = new BehaviorSubject<boolean>(false);
  //public state: BehaviorSubject<AuthStateModel>;
  //private refreshSubscription$: Subscription;

  //state$: Observable<AuthStateModel>;
  //tokens$: Observable<AuthTokenModel>;
  //profile$: Observable<ProfileModel>;
  //loggedIn$: Observable<boolean>;

  //isAuthenticated$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(false);

  //constructor(
  //  private http: HttpClient,
  //  private authorizationClient: AuthorizationClient,
  //) {
  //  this.state = new BehaviorSubject<AuthStateModel>(this.initalState);
  //  this.state$ = this.state.asObservable();

  //  this.tokens$ = this.state.pipe(
  //    filter(state => state.authReady),
  //    map(state => state.tokens)
  //  );

  //  this.profile$ = this.state.pipe(
  //    filter(state => state.authReady),
  //    map(state => state.profile)
  //  );

  //  this.loggedIn$ = this.tokens$.pipe(
  //    map(tokens => !!tokens)
  //  );
  //}

  //init(): Observable<AuthTokenModel> {
  //  return this.startupTokenRefresh()
  //    .pipe(
  //      tap(() => this.scheduleRefresh())
  //    );
  //}

  //hasClaim(claimType: any): boolean {
  //   let ret = false;
  //  const user = this.state.value?.profile as ProfileModel;

  //  // See if an array of values was passed in.
  //  if (typeof claimType === 'string') {
  //    if (user != null) {
  //      ret =  user[claimType] !== undefined;
  //    }
  //  } else {
  //    const claims: string[] = claimType;
  //    if (claims) {
  //      for (let index = 0; index < claims.length; index++) {
  //        if (user != null) {
  //          ret = user[claims[index]] !== undefined;
  //        }
  //        // If one is successful, then let them in
  //        if (ret) {
  //          break;
  //        }
  //      }
  //    }
  //  }
  //  return ret;
  //}


  ////register(data: RegisterModel): Observable<Response> {
  ////  return this.http.post(`${environment.baseApiUrl}/account/register`, data)
  ////    .pipe(
  ////      catchError(res => Observable.throw(res.json()))
  ////    );
  ////}

  //login(user: LoginModel): Observable<any> {
  //  return this.getTokens(user, 'client_credentials')
  //    .pipe(
  //      catchError(res => Observable.throw(res.error.error + ": " + res.error.error_description)),
  //      tap(res => this.scheduleRefresh())
  //    );
  //}

  //logout(): void {
  //  this.isAuthenticated$.next(false);
  //  this.updateState({ profile: null, tokens: null });
  //  if (this.refreshSubscription$) {
  //    this.refreshSubscription$.unsubscribe();
  //  }
  //  this.removeToken();
  //}

  //refreshTokens(): Observable<AuthTokenModel> {
  //  return this.state
  //    .pipe(
  //      first(),
  //      map(state => state.tokens),
  //      flatMap(tokens => this.getTokens({ refresh_token: tokens.refresh_token }, 'refresh_token')),
  //      catchError(error => Observable.throw('Session Expired'))
  //    );
  //}

  //private storeToken(tokens: AuthTokenModel): void {
  //  const previousTokens = this.retrieveTokens();
  //  if (previousTokens != null && tokens.refresh_token == null) {
  //    tokens.refresh_token = previousTokens.refresh_token;
  //  }

  //  localStorage.setItem('auth-tokens', JSON.stringify(tokens));
  //}

  //private retrieveTokens(): AuthTokenModel {
  //  const tokensString = localStorage.getItem('auth-tokens');
  //  const tokensModel: AuthTokenModel = tokensString == null ? null : JSON.parse(tokensString);
  //  return tokensModel;
  //}

  //private removeToken(): void {
  //  localStorage.removeItem('auth-tokens');
  //}

  //private updateState(newState: AuthStateModel): void {
  //  const previousState = this.state.getValue();
  //  this.state.next(Object.assign({}, previousState, newState));
  //}

  //private getTokens(data: RefreshGrantModel | LoginModel, grantType: string): Observable<AuthTokenModel> {
  //  const headers = new HttpHeaders({ 'Content-Type': 'application/x-www-form-urlencoded' });
  //  const options = { headers: headers };

  //  Object.assign(data, { grant_type: grantType, scope: 'openid api', client_id: "console-client", client_secret: "console-client-secret" });

  //  const params = new URLSearchParams();

  //  Object.keys(data)
  //    .forEach(key => params.append(key, data[key]));

  //  return this.http.post<AuthTokenModel>(`${environment.baseApiUrl}/connect/token`, params.toString(), options)
  //    .pipe(
  //      tap((tokens: AuthTokenModel) => {
  //          //const tokens: AuthTokenModel = res.json();
  //        const now = new Date();
  //        tokens.expiration_date = new Date(now.getTime() + tokens.expires_in * 1000).getTime().toString();

  //        const profile: ProfileModel = jwtDecode(tokens.id_token);

  //        this.storeToken(tokens);
  //        this.updateState({ authReady: true, tokens, profile });

  //        // ADDED!!
  //        this.isAuthenticated$.next(true);
  //      })
  //    );
  //}
  //private startupTokenRefresh(): Observable<AuthTokenModel> {

  //  return of(this.retrieveTokens())
  //    .pipe(
  //    flatMap((tokens: AuthTokenModel) => {
  //      if (!tokens) {
  //        this.updateState({ authReady: true });
  //        return Observable.throw('No token in Storage');
  //      }
  //      const profile: ProfileModel = jwtDecode(tokens.id_token);
  //      this.updateState({ tokens, profile });

  //      if (+tokens.expiration_date > new Date().getTime()) {
  //        this.updateState({ authReady: true });
  //        this.isAuthenticated$.next(true);
  //      }
  //      else {
  //        this.isAuthenticated$.next(false);
  //      }

  //      return this.refreshTokens();
  //    }),
  //    catchError(error => {
  //      this.logout();
  //      this.updateState({ authReady: true });
  //      return Observable.throw(error);
  //    })
  //    );
  //}

  //private scheduleRefresh(): void {
  //  this.refreshSubscription$ = this.tokens$
  //    .pipe(
  //      first(),
  //      // refresh every half the total expiration time
  //      flatMap(tokens => interval(tokens.expires_in / 2 * 1000)),
  //      flatMap(() => this.refreshTokens())
  //    )
  //    .subscribe();
  //}
























  ////// By default pop ups are disabled because they don't work properly on Edge.
  ////// If you want to enable pop up authentication simply set this flag to false.

  ////private popUpDisabled = true;
  ////private userManager: UserManager;
  ////private userSubject: BehaviorSubject<IUser | null> = new BehaviorSubject(null);

  ////public isAuthenticated(): Observable<boolean> {
  ////  return this.getUser().pipe(map(u => !!u));
  ////}

  ////public getUser(): Observable<IUser | null> {
  ////  return concat(
  ////    this.userSubject.pipe(take(1), filter(u => !!u)),
  ////    this.getUserFromStorage().pipe(filter(u => !!u), tap(u => this.userSubject.next(u))),
  ////    this.userSubject.asObservable());
  ////}

  ////public getAccessToken(): Observable<string> {
  ////  return from(this.ensureUserManagerInitialized())
  ////    .pipe(mergeMap(() => from(this.userManager.getUser())),
  ////      map(user => user && user.access_token));
  ////}

  ////hasClaim(claimType: any): boolean {
  ////   let ret = false;
  ////  const user =  this.userSubject.value as  Profile;

  ////  // See if an array of values was passed in.
  ////  if (typeof claimType === 'string') {
  ////    if (user != null) {
  ////      ret =  user[claimType] !== undefined;
  ////    }
  ////  } else {
  ////    const claims: string[] = claimType;
  ////    if (claims) {
  ////      for (let index = 0; index < claims.length; index++) {
  ////        if (user != null) {
  ////          ret = user[claims[index]] !== undefined;
  ////        }
  ////        // If one is successful, then let them in
  ////        if (ret) {
  ////          break;
  ////        }
  ////      }
  ////    }
  ////  }
  ////  return ret;
  ////}

  ////// We try to authenticate the user in three different ways:
  ////// 1) We try to see if we can authenticate the user silently. This happens
  //////    when the user is already logged in on the IdP and is done using a hidden iframe
  //////    on the client.
  ////// 2) We try to authenticate the user using a PopUp Window. This might fail if there is a
  //////    Pop-Up blocker or the user has disabled PopUps.
  ////// 3) If the two methods above fail, we redirect the browser to the IdP to perform a traditional
  //////    redirect flow.
  ////public async signIn(state: any): Promise<IAuthenticationResult> {
  ////  await this.ensureUserManagerInitialized();
  ////  let user: User = null;
  ////  try {
  ////    user = await this.userManager.signinSilent(this.createArguments());
  ////    this.userSubject.next(user.profile);
  ////    return this.success(state);
  ////  } catch (silentError) {
  ////    // User might not be authenticated, fallback to popup authentication

  ////    try {
  ////      if (this.popUpDisabled) {
  ////        throw new Error('Popup disabled. Change \'authorize.service.ts:AuthorizeService.popupDisabled\' to false to enable it.');
  ////      }
  ////      user = await this.userManager.signinPopup(this.createArguments());
  ////      this.userSubject.next(user.profile);
  ////      return this.success(state);
  ////    } catch (popupError) {
  ////      if (popupError.message === 'Popup window closed') {
  ////        // The user explicitly cancelled the login action by closing an opened popup.
  ////        return this.error('The user closed the window.');
  ////      } else if (!this.popUpDisabled) {
  ////      }

  ////      // PopUps might be blocked by the user, fallback to redirect
  ////      try {
  ////        await this.userManager.signinRedirect(this.createArguments(state));
  ////        return this.redirect();
  ////      } catch (redirectError) {
  ////        return this.error(redirectError);
  ////      }
  ////    }
  ////  }
  ////}

  ////public async completeSignIn(url: string): Promise<IAuthenticationResult> {
  ////  try {
  ////    await this.ensureUserManagerInitialized();
  ////    const user = await this.userManager.signinCallback(url);
  ////    this.userSubject.next(user && user.profile);
  ////    return this.success(user && user.state);
  ////  } catch (error) {
  ////    return this.error('There was an error signing in.');
  ////  }
  ////}

  ////public async signOut(state: any): Promise<IAuthenticationResult> {
  ////  try {
  ////    if (this.popUpDisabled) {
  ////      throw new Error('Popup disabled. Change \'authorize.service.ts:AuthorizeService.popupDisabled\' to false to enable it.');
  ////    }

  ////    await this.ensureUserManagerInitialized();
  ////    await this.userManager.signoutPopup(this.createArguments());
  ////    this.userSubject.next(null);
  ////    return this.success(state);
  ////  } catch (popupSignOutError) {
  ////    try {
  ////      await this.userManager.signoutRedirect(this.createArguments(state));
  ////      return this.redirect();
  ////    } catch (redirectSignOutError) {
  ////      return this.error(redirectSignOutError);
  ////    }
  ////  }
  ////}

  ////public async completeSignOut(url: string): Promise<IAuthenticationResult> {
  ////  await this.ensureUserManagerInitialized();
  ////  try {
  ////    const response = await this.userManager.signoutCallback(url);
  ////    this.userSubject.next(null);
  ////    return this.success(response && response.state);
  ////  } catch (error) {
  ////    return this.error(error);
  ////  }
  ////}

  ////private createArguments(state?: any): any {
  ////  return { useReplaceToNavigate: true, data: state };
  ////}

  ////private error(message: string): IAuthenticationResult {
  ////  return { status: AuthenticationResultStatus.Fail, message };
  ////}

  ////private success(state: any): IAuthenticationResult {
  ////  return { status: AuthenticationResultStatus.Success, state };
  ////}

  ////private redirect(): IAuthenticationResult {
  ////  return { status: AuthenticationResultStatus.Redirect };
  ////}

  ////private async ensureUserManagerInitialized(): Promise<void> {
  ////  if (this.userManager !== undefined) {
  ////    return;
  ////  }

  ////  const response = await fetch(ApplicationPaths.ApiAuthorizationClientConfigurationUrl);
  ////  if (!response.ok) {
  ////    throw new Error(`Could not load settings for '${ApplicationName}'`);
  ////  }

  ////  const settings: any = await response.json();
  ////  settings.automaticSilentRenew = true;
  ////  settings.includeIdTokenInSilentRenew = true;
  ////  this.userManager = new UserManager(settings);

  ////  this.userManager.events.addUserSignedOut(async () => {
  ////    await this.userManager.removeUser();
  ////    this.userSubject.next(null);
  ////  });
  ////}

  ////private getUserFromStorage(): Observable<IUser> {
  ////  return from(this.ensureUserManagerInitialized())
  ////    .pipe(
  ////      mergeMap(() => this.userManager.getUser()),
  ////      map(u => u && u.profile));
  ////}
}
