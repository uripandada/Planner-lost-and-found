import { Component, EventEmitter, Input, OnInit, Output } from '@angular/core';
import { FormArray, FormBuilder, FormGroup, Validators } from '@angular/forms';
import { ToastrService } from 'ngx-toastr';
import { BehaviorSubject, Observable } from 'rxjs';
import { map, startWith } from 'rxjs/operators';
import { BalancedTaskOptions, SaveMonthlyRecurringTaskItemOptions, SaveWeeklyRecurringTaskItemOptions, CancelTasksByConfigurationCommand, DailyRecurringTaskOptions, EnumData, EventTaskOptions, ExtendedTaskActionData, GetTaskConfigurationCancelPreviewQuery, GetTaskConfigurationSavePreviewQuery, InsertTaskConfigurationCommand, MonthlyRecurringTaskItemOptions, MonthlyRecurringTaskOptions, ProcessResponse, ProcessResponseOfInsertTaskConfigurationResult, ProcessResponseOfUpdateTaskConfigurationResult, SaveBalancedTaskOptions, SaveDailyRecurringTaskOptions, SaveEventTaskOptions, SaveMonthlyRecurringTaskOptions, SaveSingleTaskOptions, SaveSpecificTimesRecurringTaskOptions, SaveTaskFileData, SaveTaskWhatData, SaveWeeklyRecurringTaskOptions, SingleTaskOptions, SpecificTimesRecurringTaskOptions, TaskActionData, TaskConfigurationCancelPreview, TaskConfigurationDetailsData, TaskConfigurationSavePreview, TaskFileData, TasksManagementClient, TaskWhatData, TaskWhereData, TaskWhoData, UpdateTaskConfigurationCommand, WeeklyRecurringTaskItemOptions, WeeklyRecurringTaskOptions } from '../../core/autogenerated-clients/api-client';
import { LoadingService } from '../../core/services/loading.service';
import { FileDetails, FilesChangedData } from '../../shared/components/file-upload/file-upload.component';
import { DateHelper } from '../../shared/helpers/date.helper';
import moment, { Moment } from 'moment';
import { MomentDateHelper } from '../../shared/helpers/moment-date.helper';
import { AutocompleteSingleSelectRequiredValidator, SingleSelectWhereRequiredValidator } from '../../core/validators/autocomplete-single-select-required.validator';

@Component({
  selector: 'app-task-configuration',
  templateUrl: './task-configuration.component.html',
  styleUrls: ['./task-configuration.component.scss']
})
export class TaskConfigurationComponent implements OnInit {
  @Input() taskConfiguration: TaskConfigurationDetailsData;
  @Input() allTaskActions: Array<ExtendedTaskActionData>;
  @Input() allWhos: Array<TaskWhoData>;
  @Input() allWheres: Array<TaskWhereData>;
  @Input() allTaskTypes: Array<EnumData>;
  @Input() allRecurringTaskTypes: Array<EnumData>;
  @Input() allEventTaskTypes: Array<EnumData>;
  @Input() allEventTaskModifierTypes: Array<EnumData>;
  

  @Input() currentlyUploadingFiles: Array<FileDetails> = [];
  @Input() temporaryUploadedFiles: Array<FileDetails> = [];
  @Input() uploadedFiles: Array<FileDetails> = [];

  @Output() cancelled: EventEmitter<boolean> = new EventEmitter<boolean>();
  @Output() saved: EventEmitter<boolean> = new EventEmitter<boolean>();

  
  filteredTaskActions$: BehaviorSubject<ExtendedTaskActionData[]> = new BehaviorSubject<ExtendedTaskActionData[]>([]);
  showMultiselectWheres$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(true);
  showFromToWhere$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(false);

  showTaskConfigSavePreview$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(false);
  showTaskConfigCancelPreview$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(false);
  isLoadingTaskConfigSavePreview$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(false);
  isLoadingTaskConfigCancelPreview$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(false);
  taskConfigSavePreview$: BehaviorSubject<TaskConfigurationSavePreview> = new BehaviorSubject<TaskConfigurationSavePreview>(null);
  taskConfigCancelPreview$: BehaviorSubject<TaskConfigurationCancelPreview> = new BehaviorSubject<TaskConfigurationCancelPreview>(null);
  
  public isCreateNew: boolean = true;

  public taskConfigurationForm: FormGroup;

  get whatsFormArray(): FormArray {
    return this.taskConfigurationForm.controls.whats as FormArray;
  }

  public files: Array<FilesChangedData> = [];

  constructor(private _formBuilder: FormBuilder, private _toastr: ToastrService, private _taskManagementClient: TasksManagementClient, private loading: LoadingService) {
  }

  ngOnInit(): void {
    if (this.taskConfiguration.id) {
      this.isCreateNew = false;
    }

    this.taskConfigurationForm = this._formBuilder.group({
      typeKey: [{ value: this.taskConfiguration.taskTypeKey, disabled: !this.isCreateNew }, Validators.required],
      comment: [this.taskConfiguration.comment],
      mustBeFinishedByAllWhos: [this.taskConfiguration.mustBeFinishedByAllWhos, [Validators.required]],
      taskSingleForm: this._generateTaskSingleForm(this.taskConfiguration.singleTaskOptions),
      taskRecurringForm: this._generateTaskRecurringForm(this.taskConfiguration),
      taskEventForm: this._generateTaskEventForm(this.taskConfiguration.eventTaskOptions),
      taskBalancedForm: this._generateTaskBalancedForm(this.taskConfiguration.balancedTaskOptions),
      whats: this._generateWhatsFormArray(this.taskConfiguration.whats),
      whos: [this.taskConfiguration.whos],
      wheres: [this.taskConfiguration.wheres],
      credits: [this.taskConfiguration.credits, Validators.required],
      price: [this.taskConfiguration.price, Validators.required],
      priorityKey: [this.taskConfiguration.priorityKey, Validators.required],
      isBlockingCleaningUntilFinished: [this.taskConfiguration.isBlockingCleaningUntilFinished, Validators.required],
      isGuestRequest: [this.taskConfiguration.isGuestRequest, Validators.required],
      isMajorNotificationRaisedWhenFinished: [this.taskConfiguration.isMajorNotificationRaisedWhenFinished, Validators.required],
      isRescheduledEveryDayUntilFinished: [this.taskConfiguration.isRescheduledEveryDayUntilFinished, Validators.required],
      isShownInNewsFeed: [this.taskConfiguration.isShownInNewsFeed, Validators.required],

      whatsTypeKey: [this.taskConfiguration.whatsTypeKey],

      whereFrom: this._formBuilder.control({
        value: {
          referenceId: this.taskConfiguration.fromReferenceId,
          referenceName: this.taskConfiguration.fromReferenceName,
          typeKey: this.taskConfiguration.fromReferenceTypeKey,
        }
      }),
      whereTo: this._formBuilder.control({
        value: {
          referenceId: this.taskConfiguration.toReferenceId,
          referenceName: this.taskConfiguration.toReferenceName,
          typeKey: this.taskConfiguration.toReferenceTypeKey,
        }
      }),
    });

    this.showFromToWhere$.next(this.taskConfiguration && this.taskConfiguration.whatsTypeKey === "FROM_TO");
    this.filteredTaskActions$.next(this.allTaskActions);
    this.whatsFormArray.valueChanges.subscribe((whats) => {

      if (whats.length === 0) {
        this.showMultiselectWheres$.next(true);
        this.showFromToWhere$.next(false);
        this._filterTaskActionsByActionIdentifier(null);
      }
      else if (whats.length === 1) {
        this._filterTaskActionsByActionIdentifier(whats[0].systemDefinedActionIdentifierKey);
      }
    });

    this.taskConfigurationForm.controls.whatsTypeKey.valueChanges.subscribe((typeKey: string) => {
      if (typeKey === "LIST") {

        this.taskConfigurationForm.controls.whereFrom.clearValidators();
        this.taskConfigurationForm.controls.whereFrom.updateValueAndValidity();
        this.taskConfigurationForm.controls.whereFrom.markAsUntouched();
        this.taskConfigurationForm.controls.whereFrom.markAsPristine();

        this.taskConfigurationForm.controls.whereTo.clearValidators();
        this.taskConfigurationForm.controls.whereTo.updateValueAndValidity();
        this.taskConfigurationForm.controls.whereTo.markAsUntouched();
        this.taskConfigurationForm.controls.whereTo.markAsPristine();

        this.showMultiselectWheres$.next(true);
        this.showFromToWhere$.next(false);
      }
      else if (typeKey === "FROM_TO") {
        this.taskConfigurationForm.controls.whereFrom.setValidators(SingleSelectWhereRequiredValidator);
        this.taskConfigurationForm.controls.whereFrom.updateValueAndValidity();
        this.taskConfigurationForm.controls.whereFrom.markAsUntouched();
        this.taskConfigurationForm.controls.whereFrom.markAsPristine();

        this.taskConfigurationForm.controls.whereTo.setValidators(SingleSelectWhereRequiredValidator);
        this.taskConfigurationForm.controls.whereTo.updateValueAndValidity();
        this.taskConfigurationForm.controls.whereTo.markAsUntouched();
        this.taskConfigurationForm.controls.whereTo.markAsPristine();

        this.showMultiselectWheres$.next(false);
        this.showFromToWhere$.next(true);
      }
    });
  }

  private _filterTaskActionsByActionIdentifier(actionIdentifierKey: string) {
    if (!actionIdentifierKey) {
      this.filteredTaskActions$.next(this.allTaskActions);
      this.taskConfigurationForm.controls.whatsTypeKey.setValue("LIST");
    }
    else if (actionIdentifierKey === "NONE") {
      this.filteredTaskActions$.next(this.allTaskActions.filter(a => a.systemDefinedActionIdentifierKey === actionIdentifierKey));
      this.taskConfigurationForm.controls.whatsTypeKey.setValue("LIST");
    }
    else {
      this.filteredTaskActions$.next(this.allTaskActions.filter(a => a.systemDefinedActionIdentifierKey === actionIdentifierKey));
      this.taskConfigurationForm.controls.whatsTypeKey.setValue("FROM_TO");
    }
  }

  private _lockInterfaceForAssetActionType() {
    let whats = this.whatsFormArray.getRawValue()[0];
  }

  private _resetInterfaceForAssetActionTypeLock() {

  }

  private _generateWhatsFormArray(whats: TaskWhatData[]): FormArray {
    return this._formBuilder.array(whats.map(what => this._formBuilder.group({
      assetId: [what.assetId],
      assetName: [what.assetName],
      actionName: [what.actionName],
      assetQuantity: [what.assetQuantity],
      assetGroupId: [what.assetGroupId],
      assetGroupName: [what.assetGroupName],
      isActionSystemDefined: [what.isActionSystemDefined],
      systemDefinedActionIdentifierKey: [what.systemDefinedActionIdentifierKey],
      systemDefinedActionTypeKey: [what.systemDefinedActionTypeKey],
    })));
  }

  private _generateTaskSingleForm(options: SingleTaskOptions): FormGroup {
    //if (!options) {
    //  options = this._createNewSingleTaskOptions();
    //}

    let startsAtMoment: Moment = moment(options.startsAt);

    return this._formBuilder.group({
      date: [startsAtMoment, Validators.required],
      time: [DateHelper.getMomentTime(startsAtMoment)]
    });
  }

  private _generateTaskEventForm(options: EventTaskOptions): FormGroup {
    //if (!options) {
    //  options = this._createNewEventTaskOptions();
    //}

    let startsAtMoment: Moment = moment(options.startsAt);
    let repeatsUntilTimeMoment: Moment = moment(options.repeatsUntilTime);

    return this._formBuilder.group({
      typeKey: [options.eventKey, Validators.required],
      modifierTypeKey: [options.eventModifierKey, Validators.required],
      whenKey: [options.eventTimeKey, Validators.required],
      onEventAtDate: [startsAtMoment, Validators.required],
      onEventAtTime: [DateHelper.getMomentTime(startsAtMoment)],
      repeatsForKey: [options.repeatsForKey],
      repeatsForNrDays: [options.repeatsForNrDays],
      repeatsForNrOccurences: [options.repeatsForNrOccurences],
      repeatsUntilDate: [repeatsUntilTimeMoment],
      repeatsUntilTime: [DateHelper.getMomentTime(repeatsUntilTimeMoment)],
    });
  }

  private _generateTaskBalancedForm(options: BalancedTaskOptions): FormGroup {
    let startsAtMoment: Moment = moment(options.startsAt);
    let endsAtMoment: Moment = moment(options.endsAt);

    return this._formBuilder.group({
      startsAtDate: [startsAtMoment, Validators.required],
      endsAtDate: [endsAtMoment, Validators.required],
      excludeHolidays: [options.excludeHolidays],
      excludeWeekends: [options.excludeWeekends],
      postponeWhenRoomIsOccupied: [options.postponeWhenRoomIsOccupied],
    });
  }

  private _generateTaskRecurringForm(taskConfiguration: TaskConfigurationDetailsData): FormGroup {
    //[{ value: this.taskConfiguration.recurringTaskTypeKey, disabled: !this.isCreateNew }, Validators.required],
    return this._formBuilder.group({
      recurringTaskTypeKey: [{ value: taskConfiguration.recurringTaskTypeKey ? taskConfiguration.recurringTaskTypeKey : this.allRecurringTaskTypes[0].key, disabled: !this.isCreateNew }],
      repeatsForKey: ["NUMBER_OF_DAYS", Validators.required],
      taskRecurringDailyForm: this._generateTaskRecurringDailyForm(taskConfiguration.dailyRecurringTaskOptions),
      taskRecurringWeeklyForm: this._generateTaskRecurringWeeklyForm(taskConfiguration.weeklyRecurringTaskOptions),
      taskRecurringMonthlyForm: this._generateTaskRecurringMonthlyForm(taskConfiguration.monthlyRecurringTaskOptions),
      taskRecurringSpecificTimeForm: this._generateTaskRecurringSpecificTimeForm(taskConfiguration.specificTimesRecurringTaskOptions),
    });
  }

  private _generateTaskRecurringDailyForm(options: DailyRecurringTaskOptions): FormGroup {
    let startsAtMoment: Moment = moment(options.startsAt);
    let repeatsUntilTimeMoment: Moment = moment(options.repeatsUntilTime);

    return this._formBuilder.group({
      repeatsForKey: [options.repeatsForKey],
      repeatsForNrDays: [options.repeatsForNrDays],
      repeatsForNrOccurences: [options.repeatsForNrOccurences],
      repeatsUntilDate: [repeatsUntilTimeMoment],
      repeatsUntilTime: [DateHelper.getMomentTime(repeatsUntilTimeMoment)],
      startsAtDate: [startsAtMoment, Validators.required],
      startsAtTime: [DateHelper.getMomentTime(startsAtMoment), Validators.required],
      startsAtTimesArray: new FormArray(
        options.repeatTimes.map(rt => this._formBuilder.group({
          id: null,
          time: rt
        })))
    });
  }

  private _generateTaskRecurringWeeklyForm(options: WeeklyRecurringTaskOptions): FormGroup {
    //if (!options) {
    //  options = this._createNewWeeklyRecurringTaskOptions();
    //}
    let startsAtMoment: Moment = moment(options.startsAt);
    let repeatsUntilTimeMoment: Moment = moment(options.repeatsUntilTime);

    return this._formBuilder.group({
      repeatsForKey: [options.repeatsForKey],
      repeatsForNrDays: [options.repeatsForNrDays],
      repeatsForNrOccurences: [options.repeatsForNrOccurences],
      repeatsUntilDate: [repeatsUntilTimeMoment],
      repeatsUntilTime: [DateHelper.getMomentTime(repeatsUntilTimeMoment)],
      startsAtDate: [startsAtMoment, Validators.required],
      startsAtTime: [DateHelper.getMomentTime(startsAtMoment), Validators.required],
      weekDaysArray: new FormArray(
        ["MON", "TUE", "WED", "THU", "FRI", "SAT", "SUN"].map(dayKey => {
          let dayRecurrence = options.weeklyRecurrences.find(wr => wr.dayKey === dayKey);
          if (dayRecurrence) {
            return this._formBuilder.group({
              id: null,
              dayKey: dayKey,
              startsAtTimesArray: new FormArray(dayRecurrence.repeatTimes.map(rt => this._formBuilder.group({
                id: null,
                time: rt
              })))
            });
          }
          else {
            return this._formBuilder.group({
              id: null,
              dayKey: dayKey,
              startsAtTimesArray: new FormArray([])
            });
          }
        })
      )
    });
  }

  private _generateTaskRecurringMonthlyForm(options: MonthlyRecurringTaskOptions): FormGroup {
    //if (!options) {
    //  options = this._createNewMonthlyRecurringTaskOptions();
    //}
    let startsAtMoment: Moment = moment(options.startsAt);
    let repeatsUntilTimeMoment: Moment = moment(options.repeatsUntilTime);

    let monthlyRecurrences: FormGroup[] = [];
    for (let monthlyRecurrence of options.monthlyRecurrences) {
      for (let dailyRecurrence of monthlyRecurrence.repeatTimes) {
        monthlyRecurrences.push(this._formBuilder.group({
          id: null,
          nthOfMonth: [monthlyRecurrence.nthOfMonth, Validators.required],
          startsAtTime: [dailyRecurrence, Validators.required]
        }));
      }
    }

    return this._formBuilder.group({
      repeatsForKey: [options.repeatsForKey],
      repeatsForNrDays: [options.repeatsForNrDays],
      repeatsForNrOccurences: [options.repeatsForNrOccurences],
      repeatsUntilDate: [repeatsUntilTimeMoment],
      repeatsUntilTime: [DateHelper.getMomentTime(repeatsUntilTimeMoment)],
      startsAtDate: [startsAtMoment, Validators.required],
      startsAtTime: [DateHelper.getMomentTime(startsAtMoment), Validators.required],
      startsAtMonthDaysArray: new FormArray(monthlyRecurrences)
    });
  }

  private _generateTaskRecurringSpecificTimeForm(options: SpecificTimesRecurringTaskOptions): FormGroup {
    //if (!options) {
    //  options = this._createNewSpecificTimesRecurringTaskOptions();
    //}

    return this._formBuilder.group({
      startsAtDatesArray: new FormArray(
        options.startsAt.map(sa => {
          let saMoment: Moment = moment(sa);

          return this._formBuilder.group({
            id: null,
            date: [saMoment, Validators.required],
            time: [DateHelper.getMomentTime(saMoment), Validators.required]
          });
        })
      ),
    });
  }

  public displayTaskAction(action: TaskActionData): string {
    if (action) {
      return action.actionName + " " + action.assetName;
    }

    return '';
  }

  private _selectTaskAction(action: ExtendedTaskActionData): void {
    this.taskConfigurationForm.controls.credits.setValue(action.defaultCredits);
    this.taskConfigurationForm.controls.price.setValue(action.defaultPrice);
    this.taskConfigurationForm.controls.priorityKey.setValue(action.defaultPriorityKey);
  }

  //private _filterTaskActions(value: string): TaskActionData[] {
  //  let valueParam: string = value.toLowerCase();
  //  return this.allTaskActions.filter(a => a.actionName.toLowerCase().indexOf(valueParam) > -1 || a.assetName.toLowerCase().indexOf(valueParam) > -1);
  //}

  public uploadedFilesChanged(filesChanges: Array<FilesChangedData>) {
    this.files = filesChanges;
  }

  public cancel() {
    this.cancelled.next(true);
  }

  private _insertRequest: InsertTaskConfigurationCommand = null;
  private _updateRequest: UpdateTaskConfigurationCommand = null;

  public save() {
    if (!this.taskConfigurationForm.valid) {
      this.taskConfigurationForm.markAllAsTouched();
      this._toastr.error("Fix form errors before submitting.");
      return;
    }

    if (this.isCreateNew) {
      let insertRequest: InsertTaskConfigurationCommand = this._createInsertTaskConfigurationRequest();

      if (insertRequest.taskTypeKey === "SINGLE" && insertRequest.whos.length === 1 && insertRequest.wheres.length === 1 && insertRequest.whos[0].typeKey === "USER" && (insertRequest.wheres[0].typeKey === "ROOM" || insertRequest.wheres[0].typeKey === "RESERVATION")) {
        this._insertRequest = insertRequest;
        this.confirmSaveTaskConfiguration(false);
      }
      else {
        this.loading.start();
        this.isLoadingTaskConfigSavePreview$.next(true);
        this._taskManagementClient.getTaskSavePreview(new GetTaskConfigurationSavePreviewQuery({ ...insertRequest, isConfigurationInsert: true })).subscribe(
          (savePreview: TaskConfigurationSavePreview) => {
            this.taskConfigSavePreview$.next(savePreview);
            this.showTaskConfigSavePreview$.next(true);
            this._insertRequest = insertRequest;
          },
          (error: Error) => {
            this._toastr.error(error.message);
          },
          () => {
            this.loading.stop();
            this.isLoadingTaskConfigSavePreview$.next(false);
          }
        );
      }

    }
    else {
      let updateRequest: UpdateTaskConfigurationCommand = this._createUpdateTaskConfigurationRequest();
      this.isLoadingTaskConfigSavePreview$.next(true);
      this._taskManagementClient.getTaskSavePreview(new GetTaskConfigurationSavePreviewQuery({ ...updateRequest, isConfigurationInsert: false, taskConfigurationId: this.taskConfiguration.id })).subscribe(
        (savePreview: TaskConfigurationSavePreview) => {
          this.taskConfigSavePreview$.next(savePreview);
          this.showTaskConfigSavePreview$.next(true);
          this._updateRequest = updateRequest;
        },
        (error: Error) => {
          this._toastr.error(error.message);
        },
        () => {
          this.loading.stop();
          this.isLoadingTaskConfigSavePreview$.next(false);
        }
      );
    }
  }

  private _createInsertTaskConfigurationRequest(): InsertTaskConfigurationCommand {
    let formValues = this.taskConfigurationForm.getRawValue();

    let insertRequest = new InsertTaskConfigurationCommand({
      mustBeFinishedByAllWhos: formValues.mustBeFinishedByAllWhos,
      comment: formValues.comment,
      taskTypeKey: formValues.typeKey,
      recurringTaskTypeKey: formValues.taskRecurringForm.recurringTaskTypeKey,
      credits: +formValues.credits,
      price: +formValues.price,
      priorityKey: formValues.priorityKey,
      isBlockingCleaningUntilFinished: formValues.isBlockingCleaningUntilFinished,
      isGuestRequest: formValues.isGuestRequest,
      isMajorNotificationRaisedWhenFinished: formValues.isMajorNotificationRaisedWhenFinished,
      isRescheduledEveryDayUntilFinished: formValues.isRescheduledEveryDayUntilFinished,
      isShownInNewsFeed: formValues.isShownInNewsFeed,

      whatsTypeKey: formValues.whatsTypeKey,
      fromReferenceId: formValues.whereFrom.referenceId,
      fromReferenceName: formValues.whereFrom.referenceName,
      fromReferenceTypeKey: formValues.whereFrom.typeKey,
      toReferenceId: formValues.whereTo.referenceId,
      toReferenceName: formValues.whereTo.referenceName,
      toReferenceTypeKey: formValues.whereTo.typeKey,
      
      whats: formValues.whats.map(what => new SaveTaskWhatData({
        assetId: what.assetId,
        actionName: what.actionName,
        assetName: what.assetName,
        assetQuantity: +what.assetQuantity,
        assetGroupId: what.assetGroupId,
        assetGroupName: what.assetGroupName,
        isActionSystemDefined: what.isActionSystemDefined,
        systemDefinedActionIdentifierKey: what.systemDefinedActionIdentifierKey,
        systemDefinedActionTypeKey: what.systemDefinedActionTypeKey,
      })),
      wheres: formValues.wheres,
      whos: formValues.whos,
      files: this.files.map(f => new SaveTaskFileData({ isNew: f.isNewlyUploaded, fileName: f.fileName })),
      eventTaskOptions: new SaveEventTaskOptions({
        id: "00000000-0000-0000-0000-000000000000",
        startsAtString: MomentDateHelper.getIsoDateTimeWithTime(formValues.taskEventForm.onEventAtDate, formValues.taskEventForm.onEventAtTime),
        eventKey: formValues.taskEventForm.typeKey,
        eventModifierKey: formValues.taskEventForm.modifierTypeKey,
        eventTimeKey: formValues.taskEventForm.whenKey,
        repeatsForKey: formValues.taskEventForm.repeatsForKey,
        repeatsForNrDays: +formValues.taskEventForm.repeatsForNrDays,
        repeatsForNrOccurences: +formValues.taskEventForm.repeatsForNrOccurences,
        repeatsUntilTimeString: MomentDateHelper.getIsoDateTimeWithTime(formValues.taskEventForm.repeatsUntilDate, formValues.taskEventForm.repeatsUntilTime)
      }),
      singleTaskOptions: new SaveSingleTaskOptions({
        id: "00000000-0000-0000-0000-000000000000",
        startsAtString: MomentDateHelper.getIsoDateTimeWithTime(formValues.taskSingleForm.date, formValues.taskSingleForm.time)
      }),
      dailyRecurringTaskOptions: new SaveDailyRecurringTaskOptions({
        id: "00000000-0000-0000-0000-000000000000",
        startsAtString: MomentDateHelper.getIsoDateTimeWithTime(formValues.taskRecurringForm.taskRecurringDailyForm.startsAtDate, formValues.taskRecurringForm.taskRecurringDailyForm.startsAtTime),
        repeatsForKey: formValues.taskRecurringForm.taskRecurringDailyForm.repeatsForKey,
        repeatsForNrDays: +formValues.taskRecurringForm.taskRecurringDailyForm.repeatsForNrDays,
        repeatsForNrOccurences: +formValues.taskRecurringForm.taskRecurringDailyForm.repeatsForNrOccurences,
        repeatsUntilTimeString: MomentDateHelper.getIsoDateTimeWithTime(formValues.taskRecurringForm.taskRecurringDailyForm.repeatsUntilDate, formValues.taskRecurringForm.taskRecurringDailyForm.repeatsUntilTime),
        repeatTimes: formValues.taskRecurringForm.taskRecurringDailyForm.startsAtTimesArray.map(sa => sa.time)
      }),
      weeklyRecurringTaskOptions: new SaveWeeklyRecurringTaskOptions({
        id: "00000000-0000-0000-0000-000000000000",
        startsAtString: MomentDateHelper.getIsoDateTimeWithTime(formValues.taskRecurringForm.taskRecurringWeeklyForm.startsAtDate, formValues.taskRecurringForm.taskRecurringWeeklyForm.startsAtTime),
        repeatsForKey: formValues.taskRecurringForm.taskRecurringWeeklyForm.repeatsForKey,
        repeatsForNrDays: +formValues.taskRecurringForm.taskRecurringWeeklyForm.repeatsForNrDays,
        repeatsForNrOccurences: +formValues.taskRecurringForm.taskRecurringWeeklyForm.repeatsForNrOccurences,
        repeatsUntilTimeString: MomentDateHelper.getIsoDateTimeWithTime(formValues.taskRecurringForm.taskRecurringWeeklyForm.repeatsUntilDate, formValues.taskRecurringForm.taskRecurringWeeklyForm.repeatsUntilTime),
        weeklyRecurrences: formValues.taskRecurringForm.taskRecurringWeeklyForm.weekDaysArray.map(w => new SaveWeeklyRecurringTaskItemOptions({
          id: "00000000-0000-0000-0000-000000000000",
          dayKey: w.dayKey,
          repeatTimes: w.startsAtTimesArray.map(sa => sa.time)
        })),
      }),
      monthlyRecurringTaskOptions: new SaveMonthlyRecurringTaskOptions({
        id: "00000000-0000-0000-0000-000000000000",
        startsAtString: MomentDateHelper.getIsoDateTimeWithTime(formValues.taskRecurringForm.taskRecurringMonthlyForm.startsAtDate, formValues.taskRecurringForm.taskRecurringMonthlyForm.startsAtTime),
        repeatsForKey: formValues.taskRecurringForm.taskRecurringMonthlyForm.repeatsForKey,
        repeatsForNrDays: +formValues.taskRecurringForm.taskRecurringMonthlyForm.repeatsForNrDays,
        repeatsForNrOccurences: +formValues.taskRecurringForm.taskRecurringMonthlyForm.repeatsForNrOccurences,
        repeatsUntilTimeString: MomentDateHelper.getIsoDateTimeWithTime(formValues.taskRecurringForm.taskRecurringMonthlyForm.repeatsUntilDate, formValues.taskRecurringForm.taskRecurringMonthlyForm.repeatsUntilTime),
        monthlyRecurrences: formValues.taskRecurringForm.taskRecurringMonthlyForm.startsAtMonthDaysArray.map(da => new SaveMonthlyRecurringTaskItemOptions({
          id: "00000000-0000-0000-0000-000000000000",
          nthOfMonth: +da.nthOfMonth,
          repeatTimes: [da.startsAtTime]
        }))
      }),
      specificTimesRecurringTaskOptions: new SaveSpecificTimesRecurringTaskOptions({
        id: "00000000-0000-0000-0000-000000000000",
        startsAtStrings: formValues.taskRecurringForm.taskRecurringSpecificTimeForm.startsAtDatesArray.map(sa => MomentDateHelper.getIsoDateTimeWithTime(sa.date, sa.time)),
      }),
      balancedTaskOptions: new SaveBalancedTaskOptions({
        id: "00000000-0000-0000-0000-000000000000",
        startsAtString: MomentDateHelper.getIsoDate(formValues.taskBalancedForm.startsAtDate),
        endsAtString: MomentDateHelper.getIsoDate(formValues.taskBalancedForm.endsAtDate),
        excludeHolidays: formValues.taskBalancedForm.excludeHolidays,
        excludeWeekends: formValues.taskBalancedForm.excludeWeekends,
        postponeWhenRoomIsOccupied: formValues.taskBalancedForm.postponeWhenRoomIsOccupied,
      }),
    });

    return insertRequest;
  }
  private _createUpdateTaskConfigurationRequest(): UpdateTaskConfigurationCommand {
    let formValues = this.taskConfigurationForm.getRawValue();

    let updateRequest = new UpdateTaskConfigurationCommand({
      id: this.taskConfiguration.id,
      mustBeFinishedByAllWhos: formValues.mustBeFinishedByAllWhos,
      comment: formValues.comment,
      taskTypeKey: formValues.typeKey,
      recurringTaskTypeKey: formValues.taskRecurringForm.recurringTaskTypeKey,
      credits: +formValues.credits,
      price: +formValues.price,
      priorityKey: formValues.priorityKey,
      isBlockingCleaningUntilFinished: formValues.isBlockingCleaningUntilFinished,
      isGuestRequest: formValues.isGuestRequest,
      isMajorNotificationRaisedWhenFinished: formValues.isMajorNotificationRaisedWhenFinished,
      isRescheduledEveryDayUntilFinished: formValues.isRescheduledEveryDayUntilFinished,
      isShownInNewsFeed: formValues.isShownInNewsFeed,

      whatsTypeKey: formValues.whatsTypeKey,
      fromReferenceId: formValues.whereFrom.referenceId,
      fromReferenceName: formValues.whereFrom.referenceName,
      fromReferenceTypeKey: formValues.whereFrom.typeKey,
      toReferenceId: formValues.whereTo.referenceId,
      toReferenceName: formValues.whereTo.referenceName,
      toReferenceTypeKey: formValues.whereTo.typeKey,

      whats: formValues.whats.map(what => new SaveTaskWhatData({
        assetId: what.assetId,
        actionName: what.actionName,
        assetName: what.assetName,
        assetQuantity: +what.assetQuantity,
        assetGroupId: what.assetGroupId,
        assetGroupName: what.assetGroupName,
        isActionSystemDefined: what.isActionSystemDefined,
        systemDefinedActionIdentifierKey: what.systemDefinedActionIdentifierKey,
        systemDefinedActionTypeKey: what.systemDefinedActionTypeKey,
      })),
      wheres: formValues.wheres,
      whos: formValues.whos,
      files: this.files.map(f => new SaveTaskFileData({ isNew: f.isNewlyUploaded, fileName: f.fileName })),
      eventTaskOptions: new SaveEventTaskOptions({
        id: "00000000-0000-0000-0000-000000000000",
        startsAtString: MomentDateHelper.getIsoDateTimeWithTime(formValues.taskEventForm.onEventAtDate, formValues.taskEventForm.onEventAtTime),
        eventKey: formValues.taskEventForm.typeKey,
        eventModifierKey: formValues.taskEventForm.modifierTypeKey,
        eventTimeKey: formValues.taskEventForm.whenKey,
        repeatsForKey: formValues.taskEventForm.repeatsForKey,
        repeatsForNrDays: +formValues.taskEventForm.repeatsForNrDays,
        repeatsForNrOccurences: +formValues.taskEventForm.repeatsForNrOccurences,
        repeatsUntilTimeString: MomentDateHelper.getIsoDateTimeWithTime(formValues.taskEventForm.repeatsUntilDate, formValues.taskEventForm.repeatsUntilTime)
      }),
      singleTaskOptions: new SaveSingleTaskOptions({
        id: "00000000-0000-0000-0000-000000000000",
        startsAtString: MomentDateHelper.getIsoDateTimeWithTime(formValues.taskSingleForm.date, formValues.taskSingleForm.time)
      }),
      dailyRecurringTaskOptions: new SaveDailyRecurringTaskOptions({
        id: "00000000-0000-0000-0000-000000000000",
        startsAtString: MomentDateHelper.getIsoDateTimeWithTime(formValues.taskRecurringForm.taskRecurringDailyForm.startsAtDate, formValues.taskRecurringForm.taskRecurringDailyForm.startsAtTime),
        repeatsForKey: formValues.taskRecurringForm.taskRecurringDailyForm.repeatsForKey,
        repeatsForNrDays: +formValues.taskRecurringForm.taskRecurringDailyForm.repeatsForNrDays,
        repeatsForNrOccurences: +formValues.taskRecurringForm.taskRecurringDailyForm.repeatsForNrOccurences,
        repeatsUntilTimeString: MomentDateHelper.getIsoDateTimeWithTime(formValues.taskRecurringForm.taskRecurringDailyForm.repeatsUntilDate, formValues.taskRecurringForm.taskRecurringDailyForm.repeatsUntilTime),
        repeatTimes: formValues.taskRecurringForm.taskRecurringDailyForm.startsAtTimesArray.map(sa => sa.time)
      }),
      weeklyRecurringTaskOptions: new SaveWeeklyRecurringTaskOptions({
        id: "00000000-0000-0000-0000-000000000000",
        startsAtString: MomentDateHelper.getIsoDateTimeWithTime(formValues.taskRecurringForm.taskRecurringWeeklyForm.startsAtDate, formValues.taskRecurringForm.taskRecurringWeeklyForm.startsAtTime),
        repeatsForKey: formValues.taskRecurringForm.taskRecurringWeeklyForm.repeatsForKey,
        repeatsForNrDays: +formValues.taskRecurringForm.taskRecurringWeeklyForm.repeatsForNrDays,
        repeatsForNrOccurences: +formValues.taskRecurringForm.taskRecurringWeeklyForm.repeatsForNrOccurences,
        repeatsUntilTimeString: MomentDateHelper.getIsoDateTimeWithTime(formValues.taskRecurringForm.taskRecurringWeeklyForm.repeatsUntilDate, formValues.taskRecurringForm.taskRecurringWeeklyForm.repeatsUntilTime),
        weeklyRecurrences: formValues.taskRecurringForm.taskRecurringWeeklyForm.weekDaysArray.map(w => new SaveWeeklyRecurringTaskItemOptions({
          id: "00000000-0000-0000-0000-000000000000",
          dayKey: w.dayKey,
          repeatTimes: w.startsAtTimesArray.map(sa => sa.time)
        })),
      }),
      monthlyRecurringTaskOptions: new SaveMonthlyRecurringTaskOptions({
        id: "00000000-0000-0000-0000-000000000000",
        startsAtString: MomentDateHelper.getIsoDateTimeWithTime(formValues.taskRecurringForm.taskRecurringMonthlyForm.startsAtDate, formValues.taskRecurringForm.taskRecurringMonthlyForm.startsAtTime),
        repeatsForKey: formValues.taskRecurringForm.taskRecurringMonthlyForm.repeatsForKey,
        repeatsForNrDays: +formValues.taskRecurringForm.taskRecurringMonthlyForm.repeatsForNrDays,
        repeatsForNrOccurences: +formValues.taskRecurringForm.taskRecurringMonthlyForm.repeatsForNrOccurences,
        repeatsUntilTimeString: MomentDateHelper.getIsoDateTimeWithTime(formValues.taskRecurringForm.taskRecurringMonthlyForm.repeatsUntilDate, formValues.taskRecurringForm.taskRecurringMonthlyForm.repeatsUntilTime),
        monthlyRecurrences: formValues.taskRecurringForm.taskRecurringMonthlyForm.startsAtMonthDaysArray.map(da => new SaveMonthlyRecurringTaskItemOptions({
          id: "00000000-0000-0000-0000-000000000000",
          nthOfMonth: +da.nthOfMonth,
          repeatTimes: [da.startsAtTime]
        }))
      }),
      specificTimesRecurringTaskOptions: new SaveSpecificTimesRecurringTaskOptions({
        id: "00000000-0000-0000-0000-000000000000",
        startsAtStrings: formValues.taskRecurringForm.taskRecurringSpecificTimeForm.startsAtDatesArray.map(sa => MomentDateHelper.getIsoDateTimeWithTime(sa.date, sa.time)),
      }),
      balancedTaskOptions: new SaveBalancedTaskOptions({
        id: "00000000-0000-0000-0000-000000000000",
        startsAtString: MomentDateHelper.getIsoDate(formValues.taskBalancedForm.startsAtDate),
        endsAtString: MomentDateHelper.getIsoDate(formValues.taskBalancedForm.endsAtDate),
        excludeHolidays: formValues.taskBalancedForm.excludeHolidays,
        excludeWeekends: formValues.taskBalancedForm.excludeWeekends,
        postponeWhenRoomIsOccupied: formValues.taskBalancedForm.postponeWhenRoomIsOccupied,
      }),
    });

    return updateRequest;
  }

  public backToTaskConfigurationEdit() {
    this.showTaskConfigSavePreview$.next(false);
  }

  public confirmSaveTaskConfiguration(doContinue: boolean) {
    this.loading.start();

    if (this.isCreateNew) {
      this._taskManagementClient.insertTaskConfiguration(this._insertRequest).subscribe(
        (response: ProcessResponseOfInsertTaskConfigurationResult) => {
          if (response.hasError) {
            this._toastr.error(response.message);
            return;
          }

          this.taskConfiguration.id = response.data.id;
          this._toastr.success(response.message);

          if (doContinue) {
            this.showTaskConfigSavePreview$.next(false);
            this.saved.next(false);
          }
          else {
            this.saved.next(true);
          }
        },
        (error: Error) => {
          this._toastr.error(error.message);
        },
        () => {
          this.loading.stop();
        }
      );
    }
    else {
      this._taskManagementClient.updateTaskConfiguration(this._updateRequest).subscribe(
        (response: ProcessResponseOfUpdateTaskConfigurationResult) => {
          if (response.hasError) {
            this._toastr.error(response.message);
            return;
          }

          this._toastr.success(response.message);
          if (doContinue) {
            this.saved.next(false);
          }
          else {
            this.saved.next(true);
          }
        },
        (error: Error) => {
          this._toastr.error(error.message);
        },
        () => {
          this.loading.stop();
        }
      );
    }
  }

  public showCancelTasksPreview() {
    this.loading.start();

    let previewQuery: GetTaskConfigurationCancelPreviewQuery = new GetTaskConfigurationCancelPreviewQuery({ taskConfigurationId: this.taskConfiguration.id });
    this.isLoadingTaskConfigCancelPreview$.next(true);

    this._taskManagementClient.getTaskConfigurationCancelPreview(previewQuery).subscribe(
      (cancelPreview: TaskConfigurationCancelPreview) => {

        this.taskConfigCancelPreview$.next(cancelPreview);
        this.showTaskConfigCancelPreview$.next(true);

      },
      (error: Error) => {
        this._toastr.error(error.message);
      },
      () => {
        this.loading.stop();
        this.isLoadingTaskConfigCancelPreview$.next(false);
      }
    );
  }


  public confirmCancelTasks() {
    this.loading.start();

    let cancelRequest: CancelTasksByConfigurationCommand = new CancelTasksByConfigurationCommand({ taskConfigurationId: this.taskConfiguration.id });

    this._taskManagementClient.cancelTasksByConfiguration(cancelRequest).subscribe(
      (response: ProcessResponse) => {
        if (response.hasError) {
          this._toastr.error(response.message);
          return;
        }

        this._toastr.success(response.message);
        this.saved.next(true);
      },
      (error: Error) => {
        this._toastr.error(error.message);
      },
      () => {
        this.loading.stop();
      }
    );
  }
}
