import { EventEmitter, Injectable } from "@angular/core";
import { FormArray, FormBuilder, FormGroup, Validators } from '@angular/forms';
import { ToastrService } from 'ngx-toastr';
import { BehaviorSubject } from "rxjs";
import { AffinityData, CleanerData, CleaningPlanClient, CleaningTimelineGroupData, ICleaningTimelineGroupData, ITimeIntervalData, ProcessResponseOfUpdateCleaningPlanGroupResult, TimeIntervalData, UpdateCleaningPlanGroupAvailabilityInterval, UpdateCleaningPlanGroupCommand } from '../../core/autogenerated-clients/api-client';
import { HotelService } from '../../core/services/hotel.service';
import { LoadingService } from '../../core/services/loading.service';
import { DateHelper } from '../../shared/helpers/date.helper';

@Injectable({ providedIn: 'root' })
export class EditCleaningGroupService {
  cleaningGroup$: BehaviorSubject<ICleaningTimelineGroupData> = new BehaviorSubject<ICleaningTimelineGroupData>(null);
  isPopupShown$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(false);

  cleaningGroupSavedSuccess: EventEmitter<ICleaningTimelineGroupData> = new EventEmitter<ICleaningTimelineGroupData>();

  editForm: FormGroup;

  get availabilityIntervalsFormArray(): FormArray {
    return this.editForm.get("availabilityIntervals") as FormArray;
  }

  get affinitiesFormArray(): FormArray {
    return this.editForm.get("affinities") as FormArray;
  }

  constructor(
    private _formBuilder: FormBuilder,
    private _cleaningPlanClient: CleaningPlanClient,
    private _loading: LoadingService,
    private _hotelService: HotelService,
    private _toastr: ToastrService
  ) {

    let emptyGroup = this._createEmptyTimelineGroup();
    this.editForm = this._createEditCleanerForm(emptyGroup);
    this.cleaningGroup$.next(emptyGroup);
  }

  setCleaningGroup(cleaningGroup: ICleaningTimelineGroupData) {
    this.cleaningGroup$.next(cleaningGroup);
    this._setEditCleanerFormValues(cleaningGroup);
  }

  addNewAvailabilityInterval() {
    let intervals = this.availabilityIntervalsFormArray.value;
    let lastInterval = "00:00";

    for (let interval of intervals) {
      if (interval.to > lastInterval) {
        lastInterval = interval.to;
      }
    }

    let fromDate = DateHelper.addTime(DateHelper.today, lastInterval);
    let toDate = DateHelper.addHours(fromDate, 1);

    let fromTime = "00:00";
    let toTime = "00:00";
    if (toDate.getDate() === fromDate.getDate()) {
      fromTime = DateHelper.getTime(fromDate);
      toTime = DateHelper.getTime(toDate);
    }

    let nextIntervalFormGroup = this._createAvailabilityIntervalsFormGroup({
      id: null,
      fromTimeString: fromTime,
      toTimeString: toTime
    });

    this.availabilityIntervalsFormArray.push(nextIntervalFormGroup);
  }

  addAvailabilityInterval(timeInterval: ITimeIntervalData) {
    this.availabilityIntervalsFormArray.push(this._createAvailabilityIntervalsFormGroup(timeInterval));
  }

  removeAvailabilityInterval(index: number) {
    this.availabilityIntervalsFormArray.removeAt(index);
  }

  addAffinity(affinity: AffinityData) {
    this.affinitiesFormArray.push(this._createAffinityFormGroup(affinity));
  }

  removeAffinity(index: number) {
    this.affinitiesFormArray.removeAt(index);
  }

  resetEditForm(): void {
    let emptyGroup = this._createEmptyTimelineGroup();
    this._setEditCleanerFormValues(emptyGroup);
  }

  saveChanges(): void {
    this._loading.start();

    let v = this.editForm.getRawValue();

    let editedCleaningGroupData: ICleaningTimelineGroupData = {
      id: this.cleaningGroup$.value.id,
      hasSecondaryCleaner: v.secondaryCleanerId !== "-1",
      cleaner: new CleanerData({
        id: this.cleaningGroup$.value.cleaner.id,
        mustFillAllCredits: v.mustFillAllCredits,
        maxCredits: v.maxCredits ? +v.maxCredits : null,
        maxDepartures: v.maxDepartures ? +v.maxDepartures : null,
        maxTwins: v.maxTwins ? +v.maxTwins : null,
        weekHours: v.weeklyHours ? +v.weeklyHours : null,
        name: this.cleaningGroup$.value.cleaner.name,
        username: this.cleaningGroup$.value.cleaner.username,
        availabilityIntervals: v.availabilityIntervals.map(i => new TimeIntervalData({
          id: i.id,
          fromTimeString: i.from,
          toTimeString: i.to
        })),
        affinities: v.affinities.map(a => new AffinityData({
          type: a.type,
          referenceDescription: a.referenceDescription,
          referenceId: a.referenceId,
          referenceName: a.referenceName,
        }))
      }),
      secondaryCleaner: null,
      secondaryCleanerId: v.secondaryCleanerId === "-1" ? null : v.secondaryCleanerId
    };

    this._cleaningPlanClient
      .updateCleaningPlanGroup(new UpdateCleaningPlanGroupCommand({
        id: editedCleaningGroupData.id,
        mustFillAllCredits: editedCleaningGroupData.cleaner.mustFillAllCredits,
        affinities: editedCleaningGroupData.cleaner.affinities,
        availabilityIntervals: editedCleaningGroupData.cleaner.availabilityIntervals.map(i => new UpdateCleaningPlanGroupAvailabilityInterval({
          id: i.id,
          fromTimeString: i.fromTimeString,
          toTimeString: i.toTimeString
        })),
        maxCredits: editedCleaningGroupData.cleaner.maxCredits,
        maxDepartures: editedCleaningGroupData.cleaner.maxDepartures,
        maxTwins: editedCleaningGroupData.cleaner.maxTwins,
        secondaryCleanerId: editedCleaningGroupData.secondaryCleanerId,
        weeklyHours: editedCleaningGroupData.cleaner.weekHours
      }))
      .subscribe((response: ProcessResponseOfUpdateCleaningPlanGroupResult) => {
        if (response.hasError) {
          this._toastr.error(response.message);
          return;
        }

        // remove all availability intervals with null ID
        // append all availability intervals with not null ID

        let intervals = editedCleaningGroupData.cleaner.availabilityIntervals.filter(ai => ai.id !== null);
        intervals = [...response.data.intervals.map(i => new TimeIntervalData({ id: i.id, fromTimeString: i.fromTimeString, toTimeString: i.toTimeString }))];

        editedCleaningGroupData.cleaner.availabilityIntervals = intervals;
        editedCleaningGroupData.secondaryCleaner = response.data.secondaryCleaner;

        this.cleaningGroup$.next(editedCleaningGroupData);
        //this.cleaningGroup$.next(new CleaningTimelineGroupData({
        //  id: editedCleaningGroupData.id,
        //  hasSecondaryCleaner: false,
        //  cleaner: new CleanerData({
        //    id: editedCleaningGroupData.
        //  }),
        //  secondaryCleanerId: null,
        //  secondaryCleaner: null
        //}));

        this._toastr.success(response.message);
        this.cleaningGroupSavedSuccess.next(editedCleaningGroupData);
        this.hideEditCleanerPopup();
      },
        (error: Error) => { this._toastr.error(error.message); },
        () => {
          this._loading.stop();
        });    
  }

  showEditCleanerPopup(cleaningGroup: ICleaningTimelineGroupData) {
    this.setCleaningGroup(cleaningGroup);
    this.isPopupShown$.next(true);
  }

  hideEditCleanerPopup() {
    this.isPopupShown$.next(false);
  }

  private _createEmptyTimelineGroup(): ICleaningTimelineGroupData {
    return <ICleaningTimelineGroupData>{
      id: null,
      hasSecondaryCleaner: false,
      secondaryCleaner: null,
      secondaryCleanerId: "-1",
      cleaner: new CleanerData({
        id: null,
        mustFillAllCredits: false,
        affinities: [],
        maxCredits: null,
        maxDepartures: null,
        maxTwins: null,
        name: 'not-set',
        availabilityIntervals: [],
        username: 'not-set',
        weekHours: null
      }),
    };
  }

  private _createEditCleanerForm(data: ICleaningTimelineGroupData): FormGroup {
    return this._formBuilder.group({
      weeklyHours: [data.cleaner.weekHours],
      affinities: this._createAffinitiesFormArray(data.cleaner.affinities),
      maxCredits: [data.cleaner.maxCredits],
      maxDepartures: [data.cleaner.maxDepartures],
      maxTwins: [data.cleaner.maxTwins],
      mustFillAllCredits: [data.cleaner.mustFillAllCredits],
      secondaryCleanerId: [data.secondaryCleanerId],
      availabilityIntervals: this._createAvailabilityIntervalsFormArray(data.cleaner.availabilityIntervals)
    });
  }

  private _setEditCleanerFormValues(data: ICleaningTimelineGroupData): void {
    this.editForm.controls.weeklyHours.setValue(data.cleaner.weekHours);
    this.editForm.controls.affinities = this._createAffinitiesFormArray(data.cleaner.affinities);
    this.editForm.controls.maxCredits.setValue(data.cleaner.maxCredits);
    this.editForm.controls.maxDepartures.setValue(data.cleaner.maxDepartures);
    this.editForm.controls.maxTwins.setValue(data.cleaner.maxTwins);
    this.editForm.controls.mustFillAllCredits.setValue(data.cleaner.mustFillAllCredits);
    this.editForm.controls.secondaryCleanerId.setValue(data.hasSecondaryCleaner ? data.secondaryCleanerId : "-1");
    this.editForm.controls.availabilityIntervals = this._createAvailabilityIntervalsFormArray(data.cleaner.availabilityIntervals);
  }

  private _createAffinitiesFormArray(affinities: Array<AffinityData>): FormArray {
    return new FormArray(this._createAffinityFormGroups(affinities));
  }

  private _createAffinityFormGroups(affinities: Array<AffinityData>): Array<FormGroup> {
    return affinities.map(a => this._createAffinityFormGroup(a));
  }

  private _createAffinityFormGroup(a: AffinityData): FormGroup {
    return this._formBuilder.group({
      referenceDescription: a.referenceDescription,
      referenceId: a.referenceId,
      referenceName: a.referenceName,
      type: a.type,
    });
  }

  private _createAvailabilityIntervalsFormArray(timeIntervals: Array<ITimeIntervalData>): FormArray {
    return new FormArray(this._createAvailabilityIntervalsFormGroups(timeIntervals));
  }

  private _createAvailabilityIntervalsFormGroups(timeIntervals: Array<ITimeIntervalData>): Array<FormGroup> {
    return timeIntervals.map(i => this._createAvailabilityIntervalsFormGroup(i));
  }

  private _createAvailabilityIntervalsFormGroup(timeInterval: ITimeIntervalData): FormGroup {
    return this._formBuilder.group({
      id: timeInterval.id,
      from: [timeInterval.fromTimeString, [Validators.required, Validators.pattern('^(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]$')]],
      to: [timeInterval.toTimeString, [Validators.required, Validators.pattern('^(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]$')]]
    });
  }
}
