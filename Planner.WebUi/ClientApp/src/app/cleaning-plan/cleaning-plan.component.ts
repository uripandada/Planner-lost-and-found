import { ChangeDetectionStrategy, Component, EventEmitter, OnInit } from '@angular/core';
import { FormBuilder, FormGroup } from '@angular/forms';
import { MAT_MOMENT_DATE_ADAPTER_OPTIONS, MAT_MOMENT_DATE_FORMATS } from '@angular/material-moment-adapter';
import { DateAdapter, MAT_DATE_FORMATS, MAT_DATE_LOCALE } from '@angular/material/core';
import moment, { Moment } from 'moment';
import { ToastrService } from 'ngx-toastr';
import { BehaviorSubject, forkJoin } from 'rxjs';
import { debounceTime } from 'rxjs/operators';
import { AffinityData, AffinityGroup, CleanerListItemData, CleaningPlanClient, CleaningPlanData, GetCleaningPlanDetailsQuery, GetListOfAffinityGroupsQuery, GetListOfCleanersQuery, HotelItemData, UserManagementClient } from '../core/autogenerated-clients/api-client';
import { CustomDateAdapter } from '../core/custom-date-adapter';
import { CleaningTimelineService } from '../core/services/cleaning-timeline.service';
import { HotelService } from '../core/services/hotel.service';
import { LoadingService } from '../core/services/loading.service';
import { MomentDateHelper } from '../shared/helpers/moment-date.helper';

// See the Moment.js docs for the meaning of these formats:
// https://momentjs.com/docs/#/displaying/format/
export const MY_FORMATS = {
  parse: {
    dateInput: 'LL',
  },
  display: {
    dateInput: 'dddd[,] Do MMM YYYY',
    monthYearLabel: 'MMM YYYY',
    dateA11yLabel: 'LL',
    monthYearA11yLabel: 'MMMM YYYY',
  },
};

@Component({
  selector: 'app-cleaning-plan',
  templateUrl: './cleaning-plan.component.html',
  styleUrls: ['./cleaning-plan.component.scss'],
  changeDetection: ChangeDetectionStrategy.OnPush,
  providers: [
    { provide: DateAdapter, useClass: CustomDateAdapter, deps: [MAT_DATE_LOCALE] },
    { provide: MAT_DATE_FORMATS, useValue: MY_FORMATS },
    /*{ provide: MAT_DATE_FORMATS, useValue: MAT_MOMENT_DATE_FORMATS },*/
    { provide: MAT_MOMENT_DATE_ADAPTER_OPTIONS, useValue: { useUtc: true } },
  ],
})
export class CleaningPlanComponent implements OnInit {

  hotels: Array<HotelItemData> = [];
  isPlanLoaded$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(false);
  cleaningPlan$: BehaviorSubject<CleaningPlanData> = new BehaviorSubject<CleaningPlanData>(null);
  affinityGroups$: BehaviorSubject<AffinityGroup[]> = new BehaviorSubject<AffinityGroup[]>([]);
  cleaners$: BehaviorSubject<CleanerListItemData[]> = new BehaviorSubject<CleanerListItemData[]>([]);

  isCpsatConfigPopupShown$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(false);

  selectPlanForm: FormGroup;
  filterCleaningsForm: FormGroup;

  cleaningGroupsSaved: EventEmitter<string> = new EventEmitter<string>();

  constructor(
    private _cleaningPlanClient: CleaningPlanClient,
    private _usersClient: UserManagementClient,
    private _timelineService: CleaningTimelineService,
    private _toastr: ToastrService,
    private _formBuilder: FormBuilder,
    public loading: LoadingService,
    public hotelService: HotelService) {
  }

  ngOnInit(): void {
    this.loading.reset();
    this.selectPlanForm = this._createSelectPlanForm();
    this.loadPlan(true);
  }

  loadPlan(reloadEverything: boolean) {
    this.loading.start();

    let hotelId: string = this.selectPlanForm.controls.hotelId.value;
    let date: Moment = MomentDateHelper.getDateAtMidnight(this.selectPlanForm.controls.date.value);
    let isToday: boolean = date.isSame(moment(), "day");

    let getPlanDetailsRequest = new GetCleaningPlanDetailsQuery({
      hotelId: hotelId,
      cleaningDateString: MomentDateHelper.getIsoDate(this.selectPlanForm.controls.date.value),
      id: null,
      isTodaysCleaningPlan: isToday,
    });
    let cleaningPlanResponse$ = this._cleaningPlanClient.getDetails(getPlanDetailsRequest);

    if (reloadEverything) {
      let getCleanersRequest = new GetListOfCleanersQuery({ hotelId: hotelId });
      let allCleaners$ = this._usersClient.getListOfCleaners(getCleanersRequest);

      let getListOfAffinitiesQuery = new GetListOfAffinityGroupsQuery({ hotelId: hotelId });
      let allAffinityGroups$ = this._cleaningPlanClient.getListOfAffinityGroups(getListOfAffinitiesQuery);

      forkJoin([allCleaners$, allAffinityGroups$, cleaningPlanResponse$]).subscribe(arrayOfResults => {
        this.cleaners$.next(arrayOfResults[0]);
        this.affinityGroups$.next(arrayOfResults[1]);

        this._setPlanDetailsState(arrayOfResults[2]);
      },
        (error: Error) => {
          this._toastr.error(error.message);
        },
        () => {
          this.loading.stop();
        }
      );
    }
    else {
      forkJoin([cleaningPlanResponse$]).subscribe(arrayOfResults => {
        this._setPlanDetailsState(arrayOfResults[0]);
      },
        (error: Error) => {
          this._toastr.error(error.message);
        },
        () => {
          this.loading.stop();
        }
      );
    }
  }

  showCpsatConfigPopup() {
    this.isCpsatConfigPopupShown$.next(true);
  }

  private _createSelectPlanForm(): FormGroup {
    let form: FormGroup = this._formBuilder.group({
      date: [{ value: MomentDateHelper.nowDate(), disabled: true }],
      hotelId: [this.hotelService.getSelectedHotelId()]
    });

    form.controls.hotelId.valueChanges.subscribe((hotelId: string) => {
      this.hotelService.selectHotelId(hotelId);
      this.loadPlan(true);
    });

    form.controls.date.valueChanges
      .pipe(
        debounceTime(250),
      )
      .subscribe((value) => {
        if (value) {
          this.loadPlan(false);
        }
      }
    );

    return form;
  }

  private _setPlanDetailsState(plan: CleaningPlanData) {
    for (let group of plan.plannedGroups) {
      for (let a of group.cleaner.affinities) {
        let found = false;

        for (let ag of this.affinityGroups$.value) {
          if (ag.affinityType === a.type) {
            for (let aff of ag.affinities) {
              if (aff.referenceId === a.referenceId) {
                a.referenceName = aff.referenceName;
                a.referenceDescription = aff.referenceDescription;
                found = true;
                break;
              }
            }
          }

          if (found) {
            break;
          }
        }
      }
    }

    this.cleaningPlan$.next(plan);
    this.isPlanLoaded$.next(true);
    this._timelineService.setPlanId(plan.id);
  }
}
