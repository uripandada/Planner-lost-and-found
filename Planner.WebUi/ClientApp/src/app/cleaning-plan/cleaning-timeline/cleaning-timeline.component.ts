import { AfterViewInit, ApplicationRef, ChangeDetectionStrategy, ChangeDetectorRef, Component, ComponentFactoryResolver, ElementRef, Injector, Input, NgZone, OnChanges, OnDestroy, OnInit, SimpleChanges, ViewChild, ViewContainerRef } from '@angular/core';
import { FormBuilder, FormGroup } from '@angular/forms';
import { ActivatedRoute } from '@angular/router';
import moment, { Moment } from 'moment';
import { SelectContainerComponent } from 'ngx-drag-to-select';
import { ToastrService } from 'ngx-toastr';
import { TimelineOptions, VisTimelineService } from 'ngx-vis';
import { BehaviorSubject, Subject, Subscription } from 'rxjs';
import { debounceTime } from 'rxjs/operators';
import { ActivatePlannableCleaningsCommand, AddCleaningPlanItem, AddCleaningPlanItemsCommand, AddRemoveCleaningPlanGroupsCommand, AffinityGroup, CancelPlannableCleaningsCommand, CleanerData, CleanerListItemData, CleaningPlanClient, CleaningPlanData, CleaningTimelineItemData, CleaningTimelineItemReservationData, CleaningTimelineItemTaskActionData, CleaningTimelineItemTaskData, CpsatAutogeneratedPlan, CpsatPlannerConfigurationData, DeleteAndReloadCleaningPlanCommand, ExtendedWhereData, GenerateCpsatCleaningPlanCommand, ICleaningTimelineGroupData, ICleaningTimelineItemData, PlannedCleaningTimelineItemData, PostponePlannableCleaningsCommand, ProcessResponse, ProcessResponseOfAddRemoveCleaningPlanGroupsResult, ProcessResponseOfDeleteAndReloadCleaningPlanResult, ProcessResponseOfIEnumerableOfCleaningTimelineItemData, ProcessResponseOfSendCleaningPlanResponse, RealTimeCleaningPlannerCleaningChangedMessage, RealTimeCpsatCleaningPlanningFinishedMessage, RealTimeCpsatCleaningPlanningProgressChangedMessage, ResetCleaningPlanCommand, SaveCpsatConfigurationCommand, SendCleaningPlanCommand, UndoPostponePlannableCleaningsCommand } from '../../core/autogenerated-clients/api-client';
import { CleaningTimelineTooltipService } from '../../core/services/cleaning-timeline-tooltip.service';
import { CleaningTimelineGroup, CleaningTimelineItem, CleaningTimelineService, ItemsAddedEventData } from '../../core/services/cleaning-timeline.service';
import { HotelService } from '../../core/services/hotel.service';
import { LoadingService } from '../../core/services/loading.service';
import { RealTimeCleaningsService, RealTimeCpsatCleaningPlannerService } from '../../core/services/signalr.service';
import { CleaningTimelineFilterGroup, CleaningTimelineFilterOption } from '../../shared/components/cleaning-timeline-filter/cleaning-timeline-filter.component';
import { SpecificFilterOption, SpecificFilterValue } from '../../shared/components/filter-multiselect/filter-multiselect.component';
import { QuickCreateAttendantResult } from '../../shared/components/quick-create-attendant/quick-create-attendant-result';
import { DateHelper } from '../../shared/helpers/date.helper';
import { MomentDateHelper } from '../../shared/helpers/moment-date.helper';
import { EditCleaningGroupService } from '../_services/edit-cleaning-group.service';
import { SelectCleanersService } from '../_services/select-cleaners.service';

export class CleaningCount {
  count: number;
  description: string;
}

@Component({
  selector: 'app-cleaning-timeline',
  templateUrl: './cleaning-timeline.component.html',
  styleUrls: ['./cleaning-timeline.component.scss'],
  changeDetection: ChangeDetectionStrategy.OnPush
})
export class CleaningTimelineComponent implements OnInit, AfterViewInit, OnChanges, OnDestroy {

  @ViewChild("cleaningPlanner", { static: true }) timelineElement: ElementRef;
  @ViewChild("cleaningItemTooltipContainer", { read: ViewContainerRef, static: true }) tooltipContainer: ViewContainerRef;
  @ViewChild(SelectContainerComponent) selectCleaningsContainer: SelectContainerComponent;

  @Input() cleaningPlan: CleaningPlanData;
  @Input() affinityGroups: AffinityGroup[];
  @Input() cleaners: CleanerListItemData[];
  @Input() calculatedCleanings: CleaningTimelineItemData[];

  @Input() isCpsatConfigPopupShown$: BehaviorSubject<boolean>; // = new BehaviorSubject<boolean>(false);

  selectedFilterKeywords: Array<SpecificFilterValue> = [];

  timelineId = 'cleaning-planner-timeline';
  timelineOptions: TimelineOptions;

  cleanersData: CleanerData[] = [];
  allWheres: Array<ExtendedWhereData> = [];
  hotelWheres$: BehaviorSubject<Array<ExtendedWhereData>> = new BehaviorSubject<Array<ExtendedWhereData>>([]);

  // Cleaning timeline groups - groups displayed on the timeline on the left.
  plannedGroups$: BehaviorSubject<Array<CleaningTimelineGroup>> = new BehaviorSubject<Array<CleaningTimelineGroup>>([]);

  // Cleaning timeline items - what is displayed on the timeline. Includes background items, tasks, cleanings, everything.
  items$: BehaviorSubject<Array<CleaningTimelineItem>> = new BehaviorSubject<Array<CleaningTimelineItem>>([]);

  // Planned cleanings are all the cleanings added to the timeline
  plannedCleanings$: BehaviorSubject<PlannedCleaningTimelineItemData[]> = new BehaviorSubject<PlannedCleaningTimelineItemData[]>([]);

  // All cleanings that are not added to the timeline
  plannableCleanings$: BehaviorSubject<CleaningTimelineItemData[]> = new BehaviorSubject<CleaningTimelineItemData[]>([]);

  // Filtered plannable cleanings to hold display plannable cleanings after filtering
  filteredPlannableCleanings$: BehaviorSubject<CleaningTimelineItemData[]> = new BehaviorSubject<CleaningTimelineItemData[]>([]);

  // Used to store selected cleaner IDs in order to pass them to the select attendant modal popup
  plannedCleanerIds$: BehaviorSubject<Array<string>> = new BehaviorSubject<Array<string>>([]);

  isCleaningPlanSent$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(false);
  cleaningPlanSentAt$: BehaviorSubject<Date> = new BehaviorSubject<Date>(null);

  selectedPlannableCleanings$: BehaviorSubject<CleaningTimelineItemData[]> = new BehaviorSubject<CleaningTimelineItemData[]>([]);
  numberOfSelectedCleanings$: BehaviorSubject<number> = new BehaviorSubject<number>(0);
  numberOfActiveSelectedCleanings$: BehaviorSubject<number> = new BehaviorSubject<number>(0);
  numberOfInactiveSelectedCleanings$: BehaviorSubject<number> = new BehaviorSubject<number>(0);
  numberOfPostponedSelectedCleanings$: BehaviorSubject<number> = new BehaviorSubject<number>(0);
  numberOfNotPostponedSelectedCleanings$: BehaviorSubject<number> = new BehaviorSubject<number>(0);
  showCreateCustomCleaningsForm$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(false);
  showChangeCreditsForm$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(false);

  cpsatConfiguration$: BehaviorSubject<CpsatPlannerConfigurationData> = new BehaviorSubject<CpsatPlannerConfigurationData>(null);
  isLoadingCpsatCleaningPlan$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(false);
  isCpsatConfigurationFormShown$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(true);
  isCpsatResultShown$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(false);
  isCpsatResultSucess$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(false);

  areSentItemsLocked$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(true);

  filteredNumberOfCleanCleanings$: BehaviorSubject<number> = new BehaviorSubject<number>(0);
  filteredNumberOfDirtyCleanings$: BehaviorSubject<number> = new BehaviorSubject<number>(0);
  filteredNumberOfInspectedCleanings$: BehaviorSubject<number> = new BehaviorSubject<number>(0);
  filteredNumberOfVacantCleanings$: BehaviorSubject<number> = new BehaviorSubject<number>(0);
  filteredNumberOfOccupiedCleanings$: BehaviorSubject<number> = new BehaviorSubject<number>(0);
  filteredNumberOfDoNotDisturbCleanings$: BehaviorSubject<number> = new BehaviorSubject<number>(0);
  filteredNumberOfOutOfServiceCleanings$: BehaviorSubject<number> = new BehaviorSubject<number>(0);
  filteredNumberOfPostponedCleanings$: BehaviorSubject<number> = new BehaviorSubject<number>(0);
  filteredNumberOfActiveCleanings$: BehaviorSubject<number> = new BehaviorSubject<number>(0);
  filteredNumberOfInactiveCleanings$: BehaviorSubject<number> = new BehaviorSubject<number>(0);
  filteredNumberOfStayCleanings$: BehaviorSubject<number> = new BehaviorSubject<number>(0);
  filteredNumberOfCheckInCleanings$: BehaviorSubject<number> = new BehaviorSubject<number>(0);
  filteredNumberOfCheckOutCleanings$: BehaviorSubject<number> = new BehaviorSubject<number>(0);
  filteredNumberOfVipCleanings$: BehaviorSubject<number> = new BehaviorSubject<number>(0);

  cleaningCounts$: BehaviorSubject<CleaningCount[]> = new BehaviorSubject<CleaningCount[]>([]);

  plannedNumberOfArrivals$: BehaviorSubject<number> = new BehaviorSubject<number>(0);
  plannedNumberOfStays$: BehaviorSubject<number> = new BehaviorSubject<number>(0);
  plannedNumberOfDepartures$: BehaviorSubject<number> = new BehaviorSubject<number>(0);
  plannedNumberOfTasks$: BehaviorSubject<number> = new BehaviorSubject<number>(0);
  plannedTotalCredits$: BehaviorSubject<number> = new BehaviorSubject<number>(0);

  _allItems: Array<CleaningTimelineItem> = [];

  pixelsPerMinute$: BehaviorSubject<number> = new BehaviorSubject<number>(0);
  filterCleaningsForm: FormGroup;

  cpsatCleaningPlanProgressSubscription: Subscription;
  cpsatCleaningPlanProgressMessages$: BehaviorSubject<RealTimeCpsatCleaningPlanningProgressChangedMessage[]> = new BehaviorSubject<RealTimeCpsatCleaningPlanningProgressChangedMessage[]>([]);

  cpsatCleaningPlanResultSubscription: Subscription;
  cpsatCleaningPlanResult$: BehaviorSubject<CpsatAutogeneratedPlan> = new BehaviorSubject<CpsatAutogeneratedPlan>(null);

  showQuickAttendant$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(false);
  showCpsatConfigurationDrawer$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(false);

  availableCleaningsKeywordsFilterOptions: Array<SpecificFilterOption> = [
    new SpecificFilterOption("BUILDING", "In buildings", "Building"),
    new SpecificFilterOption("FLOOR", "In floors", "Floor"),
    new SpecificFilterOption("ROOM", "In rooms", "Room"),
    new SpecificFilterOption("FLOOR_SECTION", "In floor sections", "Section"),
    new SpecificFilterOption("FLOOR_SUB_SECTION", "In floor sub sections", "Sub section"),
    new SpecificFilterOption("CLEANING_NAME", "In cleanings", "Cleaning"),
    new SpecificFilterOption("ROOM_CATEGORY", "In room categories", "Room category"),
    new SpecificFilterOption("VIP", "In VIPs", "VIP"),
  ];

  cleaningFilterGroups: Array<CleaningTimelineFilterGroup> = [];
  selectedFilterOptions: Array<CleaningTimelineFilterOption> = [];

  private _itemComponentsMap: any = {};
  private _itemTooltipComponentsMap: any = {};
  private _groupComponentsMap: any = {};

  private _isTimelineInitilized = false;
  private _isDestroying = false;

  private _filterCleanersSubscription: Subscription;

  private _planChangedSubscription: Subscription;

  private _subscriptions: Subscription[] = [];

  private _scrollEvent$: Subject<boolean> = new Subject<boolean>();

  private _realTimeCpsatCleaningPlannerService: RealTimeCpsatCleaningPlannerService;
  private _realTimeCleaningsService: RealTimeCleaningsService;
  private _cleaningsChangedSubscription: Subscription;

  public loading: LoadingService;

  constructor(
    public editCleaningGroupService: EditCleaningGroupService,
    public selectCleanersService: SelectCleanersService,
    private _formBuilder: FormBuilder,
    private _cleaningPlanClient: CleaningPlanClient,
    private _hotelService: HotelService,
    private _visTimelineService: VisTimelineService,
    private _componentFactoryResolver: ComponentFactoryResolver,
    private _injector: Injector,
    private _applicationRef: ApplicationRef,
    private _tooltipService: CleaningTimelineTooltipService,
    public cleaningTimelineService: CleaningTimelineService,
    private cdRef: ChangeDetectorRef,
    private ngZone: NgZone,
    private _route: ActivatedRoute,
    private _toastr: ToastrService) {

    // Manually created on purpose.
    this._realTimeCpsatCleaningPlannerService = new RealTimeCpsatCleaningPlannerService();
    this._realTimeCleaningsService = new RealTimeCleaningsService();
    this.loading = new LoadingService();
  }

  ngOnInit(): void {
    this._connectToSignalREndpoints();

    this.allWheres = this._route.snapshot.data.allWheres;
    this.filterCleaningsForm = this._createFilterCleaningsForm();
    this.cpsatConfiguration$.next(this.cleaningPlan?.cpsatConfiguration);

    this._setFilteredWheres();

    this._loadCleaningPlanServiceData(true);

    this._subscriptions.push(this.editCleaningGroupService.cleaningGroupSavedSuccess.subscribe((editedGroup: ICleaningTimelineGroupData) =>
    {
      let groups = [...this.plannedGroups$.value];
      let groupIndex = groups.findIndex(g => g.id === editedGroup.id);

      let newGroup = this._createTimelineGroup(editedGroup);
      groups.splice(groupIndex, 1, newGroup);

      this.plannedGroups$.next(groups);
      this.cleaningTimelineService.setPlannedGroups(groups);
    }));

    this._subscriptions.push(this.cleaningTimelineService.itemsMovedSuccess.subscribe((items: Array<PlannedCleaningTimelineItemData>) => {
      let plannedCleanings = [...this.plannedCleanings$.value];
      for (let i of items) {
        let plannedCleaning = plannedCleanings.find(pc => pc.id == i.id);
        if (!!plannedCleaning) {
          plannedCleaning.cleaningPlanGroupId = i.cleaningPlanGroupId;
        }
      }
      this.plannedCleanings$.next(plannedCleanings);

      this._recalculateCleaningGroupSummaries();
    }));

    this._subscriptions.push(this.cleaningTimelineService.itemsAddedSuccess.subscribe((data: ItemsAddedEventData) => {
      let cleaningIds = data.cleaningsToAdd.map(c => c.id);
      let availableCleanings = this.plannableCleanings$.value.filter(c => cleaningIds.indexOf(c.id) < 0);
      this.plannableCleanings$.next(availableCleanings);
      this.filteredPlannableCleanings$.next(availableCleanings);

      this.plannedCleanings$.next([...this.plannedCleanings$.value, ...data.cleaningsToAdd]);
      this.items$.next([...this.items$.value, ...data.cleaningsToAdd.map(c => this._createPlannedCleaning(c, this.plannedGroups$.value.find(g => g.id === c.cleaningPlanGroupId)))]);
      this._recalculateCleaningGroupSummaries();
      this._filterAvailableCleanings();
    }));

    this._subscriptions.push(this.cleaningTimelineService.itemsRemovedSuccess.subscribe((items: Array<PlannedCleaningTimelineItemData>) => {
      let plannableCleanings: CleaningTimelineItemData[] = [];

      let timelineItems = [...this.items$.value];
      let plannedItems = [...this.plannedCleanings$.value];
      for (let i of items) {
        let piIndex = plannedItems.findIndex(pi => pi.id === i.id);
        if (piIndex >= 0) {
          plannedItems.splice(piIndex, 1);
        }

        let tiIndex = timelineItems.findIndex(ti => ti.id === i.id);
        if (tiIndex >= 0) {
          timelineItems.splice(tiIndex, 1);
        }

        plannableCleanings.push(new CleaningTimelineItemData({
          isActive: i.isActive,
          isClean: i.isClean,
          isCustom: i.isCustom,
          isDoNotDisturb: i.isDoNotDisturb,
          isOccupied: i.isOccupied,
          isOutOfOrder: i.isOutOfOrder,
          isPostponed: i.isPostponed,
          isRoomAssigned: i.isRoomAssigned,
          isTaskGuestRequest: i.isTaskGuestRequest,
          isTaskHighPriority: i.isTaskHighPriority,
          isTaskLowPriority: i.isTaskLowPriority,
          price: i.price,
          roomId: i.roomId,
          cleaningPluginId: i.cleaningPluginId,
          cleaningPluginName: i.cleaningPluginName,
          credits: i.credits,
          id: i.id,
          itemTypeKey: i.itemTypeKey,
          reservations: (i.reservations || []).map(r => new CleaningTimelineItemReservationData(r)),
          taskDescription: i.taskDescription,
          tasks: i.tasks,
          title: i.title,
          cleaningDescription: i.cleaningDescription,
          isChangeSheets: i.isChangeSheets,
          buildingId: i.buildingId,
          floorId: i.floorId,
          buildingName: i.buildingName,
          floorName: i.floorName,
          floorSectionName: i.floorSectionName,
          floorSubSectionName: i.floorSubSectionName,
          areaId: i.areaId,
          areaName: i.areaName,
          floorNumber: i.floorNumber,
          hotelId: i.hotelId,
          hotelName: i.hotelName,
          hasArrival: i.hasArrival,
          hasDeparture: i.hasDeparture,
          hasStay: i.hasStay,
          hasVipReservation: i.hasVipReservation,
          roomCategoryId: i.roomCategoryId,
          roomCategoryName: i.roomCategoryName,
          cleaningStatus: i.cleaningStatus,
          isInspected: i.isInspected,
          isInspectionRequired: i.isInspectionRequired,
          isInspectionSuccess: i.isInspectionSuccess,
          isReadyForInspection: i.isReadyForInspection,
          isSent: i.isSent,
          inspectedByFullName: i.inspectedByFullName,
          inspectedById: i.inspectedById,
          bedId: i.bedId,
          isPriority: i.isPriority,
          plannedAttendantTasks: i.plannedAttendantTasks.map(t => new CleaningTimelineItemTaskData({ ...t, actions: t.actions.map(a => new CleaningTimelineItemTaskActionData(a)) })),
          isFilteredOut: false,
        }));
      }

      let sortedCleanings = [...this.plannableCleanings$.value, ...plannableCleanings].sort((a, b) => this.sortPlannableCleanings(a, b));
      this.plannableCleanings$.next(sortedCleanings);
      this.filteredPlannableCleanings$.next(sortedCleanings);
      this.plannedCleanings$.next(plannedItems);
      this.items$.next(timelineItems);
      this._recalculateCleaningGroupSummaries();
      this._filterAvailableCleanings();
    }));


    window.addEventListener('scroll', this.scroll, true);

    this._scrollEvent$.pipe(
      debounceTime(500)
    ).subscribe(() => {
      if (this.selectCleaningsContainer) {
        this.selectCleaningsContainer.update();
      }
    });
  }

  ngOnChanges(changes: SimpleChanges): void {
    if (changes.cleaningPlan.firstChange) {
      return;
    }
    this._loadCleaningPlanServiceData(false);
    this._setFilteredWheres();
    this.cpsatConfiguration$.next(this.cleaningPlan?.cpsatConfiguration);
    //this._setCpsatConfigurationFormData(this.cpsatConfigurationForm, this.cleaningPlan.cpsatConfiguration);
  }

  ngAfterViewInit(): void {
  }

  ngOnDestroy(): void {
    try {
      this._isDestroying = true;

      this.cleaningTimelineService.destroy();

      for (let s of this._subscriptions) {
        s.unsubscribe();
      }

      for (const key in this._itemComponentsMap) {
        this._itemComponentsMap[key].destroy();
      }
      for (const key in this._groupComponentsMap) {
        this._groupComponentsMap[key].destroy();
      }
      for (const key in this._itemTooltipComponentsMap) {
        this._itemTooltipComponentsMap[key].destroy();
      }
    }
    finally {
      this._isDestroying = false;
    }

    this._disposeSignalRConnections();
  }

  scroll = (event): void => {
    this._scrollEvent$.next(true);
  }

  selectCleanings(cleanings: CleaningTimelineItemData[]) {
    let numberOfActiveSelectedCleanings: number = 0;
    let numberOfInactiveSelectedCleanings: number = 0;
    let numberOfPostponedSelectedCleanings: number = 0;
    let numberOfNotPostponedSelectedCleanings: number = 0;
    for (let cleaning of cleanings) {
      if (cleaning.isPostponed) {
        numberOfPostponedSelectedCleanings++;
      }
      else {
        numberOfNotPostponedSelectedCleanings++;
      }
      if (cleaning.isActive) {
        numberOfActiveSelectedCleanings++;
      }
      else {
        numberOfInactiveSelectedCleanings++;
      }
    }

    this.numberOfSelectedCleanings$.next(cleanings.length);
    this.numberOfActiveSelectedCleanings$.next(numberOfActiveSelectedCleanings);
    this.numberOfInactiveSelectedCleanings$.next(numberOfInactiveSelectedCleanings);
    this.numberOfNotPostponedSelectedCleanings$.next(numberOfNotPostponedSelectedCleanings);
    this.numberOfPostponedSelectedCleanings$.next(numberOfPostponedSelectedCleanings);
    this.selectedPlannableCleanings$.next(cleanings);
  }

  saveSelectedCleaners(): void {

    let request = new AddRemoveCleaningPlanGroupsCommand({
      planId: this.cleaningPlan.id,
      cleanerIds: this.selectCleanersService.cleanersFormArray.getRawValue().filter(i => i.isSelected).map(i => i.id)
    });

    // if the cleaning group is newly added, the server should return the fully formed new group, including floor affinities and availability intervals
    // It is important to load the tasks for the newly added cleaners also!
    this._cleaningPlanClient.addRemoveCleaningPlanGroups(request).subscribe((response: ProcessResponseOfAddRemoveCleaningPlanGroupsResult) => {
      if (response.hasError) {
        this._toastr.error(response.message);
        return;
      }

      if (response.data.hasAnyChanges) {
        //let selectedCleaners = this.cleaningPlan.allCleaners.filter(c => cleanerIds.indexOf(c.id) >= 0);
        let selectedGroups = [];
        let existingGroupsMap = {};

        // 1. Filter only already selected cleaning plan groups (cleaners)
        for (let existingGroup of this.plannedGroups$.value) {
          if (request.cleanerIds.findIndex(cleanerId => cleanerId === existingGroup.groupData.cleaner.id) >= 0) {
            existingGroupsMap[existingGroup.id] = existingGroup;
            selectedGroups.push(existingGroup);
          }
        }

        // 2. append newly selected groups
        for (let g of response.data.insertedGroups) {
          let group = this._createTimelineGroup(g);
          existingGroupsMap[group.id] = group;
          selectedGroups.push(group);
        }

        this.selectCleanersService.hidePopup();
        this.plannedCleanerIds$.next(request.cleanerIds);

        let nonBackgroundItems = this.items$.value.filter(i => i.type !== "background" && existingGroupsMap[i.group]).map(i => {
          return i;
        });

        let addedPlannedNonEventTasks = response.data.plannedNonEventTasks.map(i => {
          let selectedGroup = selectedGroups.find(g => g.groupData.id === i.cleaningPlanGroupId);
          selectedGroup.numberOfTasks$.next(selectedGroup.numberOfTasks$.value + 1);
          return this._createPlannedTask(i, selectedGroup);
        })
        let availabilityBackgroundTimelineItems = this._createAvailabilityBackgroundItems(this.cleaningPlan.date, selectedGroups);
        this.plannedGroups$.next(selectedGroups);
        this.items$.next([...availabilityBackgroundTimelineItems, ...addedPlannedNonEventTasks, ...nonBackgroundItems]);
        this.cleaningTimelineService.setData(this.cleaningPlan.date, this.plannedGroups$.value, this.items$.value);

        //this._toastr.success(response.message);

        this._scrollEvent$.next(true); // to refresh the select container
      }
      //  else {
      //    this._toastr.info("No changes.");
      //  }
    },
      (error: Error) => { this._toastr.error(error.message); },
      () => { }
    );

  }

  private _incrementGroupSummaryForCleaning(cleaning: ICleaningTimelineItemData, group: CleaningTimelineGroup) {
    if (cleaning.credits) {
      group.totalCredits$.next(group.totalCredits$.value + cleaning.credits);
      this.plannedTotalCredits$.next(this.plannedTotalCredits$.value + cleaning.credits);
    }

    if (cleaning.hasArrival) {
      group.numberOfArrivals$.next(group.numberOfArrivals$.value + 1);
      this.plannedNumberOfArrivals$.next(this.plannedNumberOfArrivals$.value + 1);
    }

    if (cleaning.hasStay) {
      group.numberOfStays$.next(group.numberOfStays$.value + 1);
      this.plannedNumberOfStays$.next(this.plannedNumberOfStays$.value + 1);
    }

    if (cleaning.hasDeparture) {
      group.numberOfDepartures$.next(group.numberOfDepartures$.value + 1);
      this.plannedNumberOfDepartures$.next(this.plannedNumberOfDepartures$.value + 1);
    }
  }
  private _decrementGroupSummaryForCleaning(cleaning: ICleaningTimelineItemData, group: CleaningTimelineGroup) {
    if (cleaning.credits) {
      group.totalCredits$.next(group.totalCredits$.value - cleaning.credits);
      this.plannedTotalCredits$.next(this.plannedTotalCredits$.value - cleaning.credits);
    }

    if (cleaning.hasArrival) {
      group.numberOfArrivals$.next(group.numberOfArrivals$.value - 1);
      this.plannedNumberOfArrivals$.next(this.plannedNumberOfArrivals$.value - 1);
    }

    if (cleaning.hasStay) {
      group.numberOfStays$.next(group.numberOfStays$.value - 1);
      this.plannedNumberOfStays$.next(this.plannedNumberOfStays$.value - 1);
    }

    if (cleaning.hasDeparture) {
      group.numberOfDepartures$.next(group.numberOfDepartures$.value - 1);
      this.plannedNumberOfDepartures$.next(this.plannedNumberOfDepartures$.value - 1);
    }
  }
  private _incrementGroupSummaryForTask(cleaning: ICleaningTimelineItemData, group: CleaningTimelineGroup) {
    group.numberOfTasks$.next(group.numberOfTasks$.value + 1);
    this.plannedNumberOfTasks$.next(this.plannedNumberOfTasks$.value + 1);
  }

  private _resetCleaningGroupSummaries() {
    this.plannedTotalCredits$.next(0);
    this.plannedNumberOfArrivals$.next(0);
    this.plannedNumberOfDepartures$.next(0);
    this.plannedNumberOfStays$.next(0);


    let groups = this.plannedGroups$.value;
    for (let group of groups) {
      group.totalCredits$.next(0);
      group.numberOfArrivals$.next(0);
      group.numberOfDepartures$.next(0);
      group.numberOfStays$.next(0);
    }
  }

  private _recalculateCleaningGroupSummaries() {
    this._resetCleaningGroupSummaries();

    let plannedTotalCredits: number = 0;
    let plannedNumberOfArrivals: number = 0;
    let plannedNumberOfDepartures: number = 0;
    let plannedNumberOfStays: number = 0;


    let groups = this.plannedGroups$.value;
    for (let group of groups) {
      let totalCredits : number = 0;
      let numberOfArrivals : number = 0;
      let numberOfDepartures : number = 0;
      let numberOfStays: number = 0;

      for (let cleaning of this.plannedCleanings$.value) {
        if (cleaning.cleaningPlanGroupId === group.id) {
          plannedTotalCredits += cleaning.credits;
          totalCredits += cleaning.credits;

          if (cleaning.hasArrival) {
            plannedNumberOfArrivals++;
            numberOfArrivals++;
          }
          else if (cleaning.hasStay) {
            plannedNumberOfStays++;
            numberOfStays++;
          }
          else if (cleaning.hasDeparture) {
            plannedNumberOfDepartures++;
            numberOfDepartures++;
          }
        }
      }

      group.totalCredits$.next(totalCredits);
      group.numberOfArrivals$.next(numberOfArrivals);
      group.numberOfStays$.next(numberOfStays);
      group.numberOfDepartures$.next(numberOfDepartures);
    }

    this.plannedTotalCredits$.next(plannedTotalCredits);
    this.plannedNumberOfArrivals$.next(plannedNumberOfArrivals);
    this.plannedNumberOfDepartures$.next(plannedNumberOfDepartures);
    this.plannedNumberOfStays$.next(plannedNumberOfStays);
  }

  private _connectToSignalREndpoints() {

    this._realTimeCpsatCleaningPlannerService.connect()
      .catch(() => { this._toastr.error("Error happened while connecting to the Cleaning Plan SignalR endpoint."); })
      .finally(() => { /*this._toastr.success("Successfully connected to the Cleaning Plan SignalR endpoint.");*/ });

    this.cpsatCleaningPlanProgressSubscription = this._realTimeCpsatCleaningPlannerService.progressChanged.subscribe((data: RealTimeCpsatCleaningPlanningProgressChangedMessage) => {
      this.cpsatCleaningPlanProgressMessages$.next([...this.cpsatCleaningPlanProgressMessages$.value, data]);
      if (data.statusKey.indexOf("FINISHED") === 0) {
        this.isCpsatResultShown$.next(true);
      }
      if (data.statusKey === "FINISHED") {
        this.isCpsatResultSucess$.next(true);
      }
    });

    this.cpsatCleaningPlanResultSubscription = this._realTimeCpsatCleaningPlannerService.finished.subscribe((data: RealTimeCpsatCleaningPlanningFinishedMessage) => {
      this.cpsatCleaningPlanResult$.next(data.plan);
    });


    this._realTimeCleaningsService.connect()
      .catch(() => { this._toastr.error("Error happened while connecting to the Cleanings SignalR endpoint."); })
      .finally(() => { /*this._toastr.success("Successfully connected to the Cleanings SignalR endpoint.");*/ });

    this._cleaningsChangedSubscription = this._realTimeCleaningsService.cleaningsChanged.subscribe((messages: Array<RealTimeCleaningPlannerCleaningChangedMessage>) => {
      if (!messages || messages.length === 0)
        return;

      this.cleaningTimelineService.onRealTimeCleaningsChanged(messages);
    });
  }

  private _disposeSignalRConnections() {
    this.cpsatCleaningPlanProgressSubscription.unsubscribe();
    this.cpsatCleaningPlanResultSubscription.unsubscribe();
    this._realTimeCpsatCleaningPlannerService.disconnect();

    this._cleaningsChangedSubscription.unsubscribe();
    this._realTimeCleaningsService.disconnect();
  }

  private _loadCleaningPlanServiceData(initializeTimeline: boolean) {

    this.plannedNumberOfArrivals$.next(0);
    this.plannedNumberOfDepartures$.next(0);
    this.plannedNumberOfStays$.next(0);
    this.plannedNumberOfTasks$.next(0);
    this.plannedTotalCredits$.next(0);

    this.isCleaningPlanSent$.next(this.cleaningPlan.isSent);
    this.cleaningPlanSentAt$.next(this.cleaningPlan.sentAt ? this.cleaningPlan.sentAt.toDate() : null);

    let timelineGroups = this.cleaningPlan.plannedGroups.map(g => this._createTimelineGroup(g));
    let availabilityBackgroundTimelineItems = this._createAvailabilityBackgroundItems(this.cleaningPlan.date, timelineGroups);
    let timelineCleanings = this.cleaningPlan.plannedCleanings.map(c => {
      let group = timelineGroups.find(g => g.groupData.id === c.cleaningPlanGroupId);
      this._incrementGroupSummaryForCleaning(c, group);

      return this._createPlannedCleaning(c, group);
    });

    let timelineTasks = this.cleaningPlan.plannedNonEventTasks.map(pc => {
      let group = timelineGroups.find(g => g.groupData.id === pc.cleaningPlanGroupId);
      this._incrementGroupSummaryForTask(pc, group);
      return this._createPlannedTask(pc, group);
    });

    this.plannedGroups$.next(timelineGroups);
    this.plannedCleanings$.next([...this.cleaningPlan.plannedCleanings]);
    this.items$.next([...availabilityBackgroundTimelineItems, ...timelineCleanings, ...timelineTasks]);
    this.plannableCleanings$.next(this.cleaningPlan.plannableCleanings); // The difference between current state and calculated state should be made here.
    //this.filteredAvailableCleanings$.next(this.cleaningPlan.plannableCleanings);

    this.cleanersData = this.cleaners.map(c => new CleanerData({
      id: c.id,
      avatarUrl: c.avatarImageUrl,
      fullNameInitials: c.fullNameInitials,
      mustFillAllCredits: false,
      availabilityIntervals: [],
      affinities: [],
      groupName: c.groupName,
      maxCredits: 0,
      maxDepartures: 0,
      maxTwins: 0,
      name: c.firstName + ' ' + c.lastName,
      subGroupName: c.subGroupName,
      username: c.userName,
      weekHours: 0
    }));


    if (initializeTimeline) {
      let minutesPerCredit: number = 1;
      if ((this.cleaningPlan?.cpsatConfiguration?.minutesPerCredit ?? 0) !== 0) {
        minutesPerCredit = this.cleaningPlan?.cpsatConfiguration?.minutesPerCredit;
      }

      this.cleaningTimelineService.initialize(this.timelineElement.nativeElement, timelineGroups, this.items$.value, minutesPerCredit);
      this._tooltipService.setRootViewContainerRef(this.tooltipContainer);
    }
    else {
      this.cleaningTimelineService.setData(this.cleaningPlan.date, timelineGroups, this.items$.value);
      //this.cleaningPlan = cleaningPlan;
    }

    //this.selectCleanersService.setCleaners();
    this.plannedCleanerIds$.next(timelineGroups.map(g => g.groupData.cleaner.id));

    this._filterAvailableCleanings();

    this.selectCleanersService.setCleaners(this.cleanersData, this.plannedCleanerIds$.value);

    this.cleaningFilterGroups = this._generateCleaningFilterValues(this.plannableCleanings$.value, this.plannedCleanings$.value);

    this.cleaningCounts$.next(this._generateCleaningCounts(this.plannableCleanings$.value, this.plannedCleanings$.value));
  }

  private _createAvailabilityBackgroundItems(cleaningPlanDate: Moment, groups: CleaningTimelineGroup[]): CleaningTimelineItem[] {
    let backgroundIdIndex: number = -1;
    let plannedGroupsAvailabilities: Array<CleaningTimelineItem> = [];
    for (let group of groups) {
      if (!group.groupData.cleaner.availabilityIntervals || group.groupData.cleaner.availabilityIntervals.length === 0)
        continue;

      let sortedIntervals = group.groupData.cleaner.availabilityIntervals.filter(i => i.fromTimeString < i.toTimeString || i.toTimeString === "00:00").sort((a, b) => { return a.fromTimeString > b.fromTimeString ? 1 : -1; });
      if (sortedIntervals.length === 0)
        continue;

      for (let i = 0; i < sortedIntervals.length; i++) {
        let start: Moment = null;
        let end: Moment = null;

        if (i === 0) {
          if (sortedIntervals[i].fromTimeString === "00:00")
            continue;

          start = DateHelper.addMomentTime(cleaningPlanDate, "00:00");
          end = DateHelper.addMomentTime(cleaningPlanDate, sortedIntervals[i].fromTimeString);
        }
        else {
          start = DateHelper.addMomentTime(cleaningPlanDate, sortedIntervals[i - 1].toTimeString);
          end = DateHelper.addMomentTime(cleaningPlanDate, sortedIntervals[i].fromTimeString);
        }

        plannedGroupsAvailabilities.push(<CleaningTimelineItem>{
          cleaning: null,
          id: backgroundIdIndex.toString(),
          start: start.toDate(),
          end: end.toDate(),
          className: "disabled-vis-background-item",
          group: group.id,
          type: "background",
          content: "<div></div>"
        });
        backgroundIdIndex--;
      }

      let lastInterval = sortedIntervals[sortedIntervals.length - 1];
      if (lastInterval.toTimeString !== "00:00") {
        let start = DateHelper.addMomentTime(cleaningPlanDate, lastInterval.toTimeString);
        let end = DateHelper.addMomentTime(cleaningPlanDate, "23:59");
        plannedGroupsAvailabilities.push(<CleaningTimelineItem>{
          //cleaning: null,
          id: backgroundIdIndex.toString(),
          start: start.toDate(),
          end: end.toDate(),
          className: "disabled-vis-background-item",
          editable: false,
          group: group.id,
          selectable: false,
          title: null,
          align: "auto",
          style: null,
          type: "background"
        });
        backgroundIdIndex--;
      }
    }

    return plannedGroupsAvailabilities;
  }

  private _createTimelineGroup(groupData: ICleaningTimelineGroupData): CleaningTimelineGroup {
    return <CleaningTimelineGroup>{
      groupData: groupData,
      id: groupData.id,
      treeLevel: 0,
      content: null,
      numberOfArrivals$: new BehaviorSubject<number>(0),
      numberOfDepartures$: new BehaviorSubject<number>(0),
      numberOfStays$: new BehaviorSubject<number>(0),
      numberOfTasks$: new BehaviorSubject<number>(0),
      totalCredits$: new BehaviorSubject<number>(0),
    };
  }

  private _createPlannedCleaning(itemData: PlannedCleaningTimelineItemData, group: CleaningTimelineGroup): CleaningTimelineItem {
    let cleaning = <CleaningTimelineItem>{
      content: itemData,
      //content: null,
      id: itemData.id,
      type: "range",
      start: itemData.start.toDate(),
      align: "auto",
      end: itemData.end.toDate(),
      group: group.id,
      editable: true,
    };
    return <any>cleaning;
  }

  private _createPlannedTask(itemData: PlannedCleaningTimelineItemData, group: CleaningTimelineGroup): CleaningTimelineItem {
    let task = <CleaningTimelineItem>{
      content: itemData,
      //content: null,
      id: itemData.id,
      type: "point",
      start: itemData.start.toDate(),
      align: "auto",
      end: itemData.end.toDate(),
      group: group.id,
      editable: false
    };

    return task;
  }

  showPlannableTooltip(event: MouseEvent) {
    let id = ((<any>event.target).attributes as NamedNodeMap).getNamedItem("data-plannable-item-id").value;
    let cleaning = this.filteredPlannableCleanings$.value.find(c => c.id === id);
    this._tooltipService.showPlannableTooltip(cleaning, event.srcElement);
  }

  hidePlannableTooltip(event: MouseEvent) {
    this._tooltipService.hideTooltip();
  }

  dragStartItemFromList(event: DragEvent, plannableItem: CleaningTimelineItem) {
    this.hidePlannableTooltip(null);

    let clientX = event.clientX - (<any>event.currentTarget).getBoundingClientRect().x;

    var item = {
      id: "MULTI-DROP",
      type: 'range',
      clientX: clientX,
      content: this.selectedPlannableCleanings$.value,
      doInsertItem: true,
    };
    event.dataTransfer.setData("text", JSON.stringify(item));
  }

  selectItemFromList(plannableItem: CleaningTimelineItem) {
  }

  toggleClean() {
    this.filterCleaningsForm.controls.filterOnlyClean.setValue(!this.filterCleaningsForm.controls.filterOnlyClean.value);
  }
  toggleDirty() {
    this.filterCleaningsForm.controls.filterOnlyDirty.setValue(!this.filterCleaningsForm.controls.filterOnlyDirty.value);
  }
  toggleInspected() {
    this.filterCleaningsForm.controls.filterOnlyInspected.setValue(!this.filterCleaningsForm.controls.filterOnlyInspected.value);
  }
  toggleOccupied() {
    this.filterCleaningsForm.controls.filterOnlyOccupied.setValue(!this.filterCleaningsForm.controls.filterOnlyOccupied.value);
  }
  toggleVacant() {
    this.filterCleaningsForm.controls.filterOnlyVacant.setValue(!this.filterCleaningsForm.controls.filterOnlyVacant.value);
  }
  toggleDoNotDisturb() {
    this.filterCleaningsForm.controls.filterOnlyDoNotDisturb.setValue(!this.filterCleaningsForm.controls.filterOnlyDoNotDisturb.value);
  }
  toggleOutOfService() {
    this.filterCleaningsForm.controls.filterOnlyOutOfService.setValue(!this.filterCleaningsForm.controls.filterOnlyOutOfService.value);
  }
  togglePostponed() {
    this.filterCleaningsForm.controls.filterOnlyPostponed.setValue(!this.filterCleaningsForm.controls.filterOnlyPostponed.value);
  }
  toggleActive() {
    this.filterCleaningsForm.controls.filterOnlyActive.setValue(!this.filterCleaningsForm.controls.filterOnlyActive.value);
  }
  toggleInactive() {
    this.filterCleaningsForm.controls.filterOnlyInactive.setValue(!this.filterCleaningsForm.controls.filterOnlyInactive.value);
  }
  toggleStay() {
    this.filterCleaningsForm.controls.filterOnlyStay.setValue(!this.filterCleaningsForm.controls.filterOnlyStay.value);
  }
  toggleCheckIn() {
    this.filterCleaningsForm.controls.filterOnlyCheckIn.setValue(!this.filterCleaningsForm.controls.filterOnlyCheckIn.value);
  }
  toggleCheckOut() {
    this.filterCleaningsForm.controls.filterOnlyCheckOut.setValue(!this.filterCleaningsForm.controls.filterOnlyCheckOut.value);
  }
  toggleVip() {
    this.filterCleaningsForm.controls.filterOnlyVip.setValue(!this.filterCleaningsForm.controls.filterOnlyVip.value);
  }

  cancelSelectedCleanings() {
    this.loading.start();

    let selectedPlannableCleaningIds: string[] = this.selectedPlannableCleanings$.value.map(c => c.id);
    let request: CancelPlannableCleaningsCommand = new CancelPlannableCleaningsCommand({
      ids: selectedPlannableCleaningIds
    });

    this._cleaningPlanClient.cancelPlannableCleanings(request).subscribe(
      (response: ProcessResponse) => {
        if (response.hasError) {
          this._toastr.error(response.message);
          return;
        }

        this._setCleaningActiveStatusVisuals(false);
        this.selectedPlannableCleanings$.next([]);
        //this._toastr.success(response.message);
      },
      (error: Error) => {
        this._toastr.error(error.message);
      },
      () => {
        this.loading.stop();
      });
  }

  activateSelectedCleanings() {
    this.loading.start();

    let selectedPlannableCleaningIds: string[] = this.selectedPlannableCleanings$.value.map(c => c.id);
    let request: ActivatePlannableCleaningsCommand = new ActivatePlannableCleaningsCommand({
      ids: selectedPlannableCleaningIds
    });

    this._cleaningPlanClient.activatePlannableCleanings(request).subscribe(
      (response: ProcessResponse) => {
        if (response.hasError) {
          this._toastr.error(response.message);
          return;
        }

        this._setCleaningActiveStatusVisuals(true);
        this.selectedPlannableCleanings$.next([]);
        //this._toastr.success(response.message);
      },
      (error: Error) => {
        this._toastr.error(error.message);
      },
      () => {
        this.loading.stop();
      });
  }

  postponeSelectedCleanings() {
    this.loading.start();

    let selectedPlannableCleaningIds: string[] = this.selectedPlannableCleanings$.value.map(c => c.id);
    let request: PostponePlannableCleaningsCommand = new PostponePlannableCleaningsCommand({
      ids: selectedPlannableCleaningIds,
      cleaningPlanId: this.cleaningPlan.id,
    });

    this._cleaningPlanClient.postponePlannableCleanings(request).subscribe(
      (response: ProcessResponse) => {
        if (response.hasError) {
          this._toastr.error(response.message);
          return;
        }

        this._setCleaningPostponedStatusVisuals(true);
        this.selectedPlannableCleanings$.next([]);
        //this._toastr.success(response.message);
      },
      (error: Error) => {
        this._toastr.error(error.message);
      },
      () => {
        this.loading.stop();
      });

  }

  undoPostponeSelectedCleanings() {
    this.loading.start();

    let selectedPlannableCleaningIds: string[] = this.selectedPlannableCleanings$.value.map(c => c.id);
    let request: UndoPostponePlannableCleaningsCommand = new UndoPostponePlannableCleaningsCommand({
      ids: selectedPlannableCleaningIds,
    });

    this._cleaningPlanClient.undoPostponePlannableCleanings(request).subscribe(
      (response: ProcessResponse) => {
        if (response.hasError) {
          this._toastr.error(response.message);
          return;
        }

        this._setCleaningPostponedStatusVisuals(false);
        this.selectedPlannableCleanings$.next([]);
        //this._toastr.success(response.message);
      },
      (error: Error) => {
        this._toastr.error(error.message);
      },
      () => {
        this.loading.stop();
      });

  }

  showCreateCustomCleaningsForm() {
    this.showCreateCustomCleaningsForm$.next(true);
  }

  showChangeCreditsForm() {
    this.showChangeCreditsForm$.next(true);
  }

  onCreateCustomCleaningsCancelled() {
    this.showCreateCustomCleaningsForm$.next(false);
  }

  onCreateCustomCleaningsSaved(cleanings: CleaningTimelineItemData[]) {
    this.plannableCleanings$.next([...this.plannableCleanings$.value, ...cleanings].sort((a, b) => this.sortPlannableCleanings(a, b)));

    this._filterAvailableCleanings();

    this.showCreateCustomCleaningsForm$.next(false);
  }

  onChangeCreditsSaved(eventData: { cleaningIds: string[], credits: number }) {
    let cleanings: CleaningTimelineItemData[] = [...this.plannableCleanings$.value];
    for (let c of cleanings) {
      if (eventData.cleaningIds.indexOf(c.id) > -1) {
        c.credits = eventData.credits;
      }
    }

    this.plannableCleanings$.next(cleanings);
    this.showChangeCreditsForm$.next(false);
  }

  onChangeCreditsCancelled() {
    this.showChangeCreditsForm$.next(false);
  }

  openQuickCreateAttendant() {
    this.showQuickAttendant$.next(true);
  }

  closeQuickAttendant() {
    this.showQuickAttendant$.next(false);
  }

  hideCpsatCofigPopup() {
    this.isCpsatConfigPopupShown$.next(false);
  }

  generateCpsatCleaningPlan(cpsatConfiguration: CpsatPlannerConfigurationData) {
    this.isLoadingCpsatCleaningPlan$.next(true);
    this.isCpsatConfigurationFormShown$.next(false);
    this.isCpsatResultShown$.next(false);
    //return;

    //this.cpsatCleaningPlanProgressMessages$.next([...this.cpsatCleaningPlanProgressMessages$.value, new CleaningPlanProgressMessage({
    //  cleaningPlanId: this.cleaningPlan.id,
    //  message: "Calculation started",
    //  statusKey: "STARTED",
    //})]);

    let request: GenerateCpsatCleaningPlanCommand = new GenerateCpsatCleaningPlanCommand({
      cleaningPlanId: this.cleaningPlan.id,
      isTodaysCleaningPlan: MomentDateHelper.isDateToday(this.cleaningPlan.date),
      configuration: cpsatConfiguration,
    });
    this._cleaningPlanClient.generateCpsatCleaningPlan(request).subscribe((response: ProcessResponse) => {
      if (response.isSuccess) {
        //this._toastr.success(response.message);
        this.cpsatConfiguration$.next(new CpsatPlannerConfigurationData(cpsatConfiguration));
      }
      else {
        this._toastr.error(response.message);
      }
    });
  }

  saveCpsatConfiguration(config: CpsatPlannerConfigurationData) {

    this.loading.start();

    let request: SaveCpsatConfigurationCommand = new SaveCpsatConfigurationCommand({
      cleaningPlanId: this.cleaningPlan.id,
      applyLevelMovementCreditReductionAfterNumberOfLevels: config.applyLevelMovementCreditReductionAfterNumberOfLevels,
      balanceByCreditsStrictMaxCredits: config.balanceByCreditsStrictMaxCredits,
      balanceByCreditsStrictMinCredits: config.balanceByCreditsStrictMinCredits,
      balanceByCreditsWithAffinitiesMaxCredits: config.balanceByCreditsWithAffinitiesMaxCredits,
      balanceByCreditsWithAffinitiesMinCredits: config.balanceByCreditsWithAffinitiesMinCredits,
      balanceByRoomsMaxRooms: config.balanceByRoomsMaxRooms,
      balanceByRoomsMinRooms: config.balanceByRoomsMinRooms,
      buildingMovementCreditsReduction: config.buildingMovementCreditsReduction,
      doesBuildingMovementReduceCredits: config.doesBuildingMovementReduceCredits,
      doesLevelMovementReduceCredits: config.doesLevelMovementReduceCredits,
      levelMovementCreditsReduction: config.levelMovementCreditsReduction,
      maxBuildingTravelTime: config.maxBuildingTravelTime,
      maxNumberOfBuildingsPerAttendant: config.maxNumberOfBuildingsPerAttendant,
      maxNumberOfLevelsPerAttendant: config.maxNumberOfLevelsPerAttendant,
      solverRunTime: config.solverRunTime,
      planningStrategyTypeKey: config.planningStrategyTypeKey,
      targetByCreditsValue: config.targetByCreditsValue,
      targetByRoomsValue: config.targetByRoomsValue,

      doBalanceStaysAndDepartures: config.doBalanceStaysAndDepartures,
      maxDeparture: config.maxDeparture,
      maxDeparturesEquivalentCredits: config.maxDeparturesEquivalentCredits,
      maxDeparturesReducesCredits: config.maxDeparturesReducesCredits,
      maxDeparturesReductionThreshold: config.maxDeparturesReductionThreshold,
      maxStay: config.maxStay,
      maxStaysEquivalentCredits: config.maxStaysEquivalentCredits,
      maxStaysIncreasesCredits: config.maxStaysIncreasesCredits,
      maxStaysIncreaseThreshold: config.maxStaysIncreaseThreshold,
      weightEpsilonStayDeparture: config.weightEpsilonStayDeparture,
    });

    this._cleaningPlanClient.saveCpsatConfiguration(request).subscribe(
      (response: ProcessResponse) => {
        if (response.hasError) {
          this._toastr.error(response.message);
          return;
        }

        //this._toastr.success(response.message);
        this.toggleShowCpsatConfigurationDrawer();
      },
      (error: Error) => { this._toastr.error(error.message); this.loading.stop(); },
      () => { this.loading.stop(); }
    )

    //this.isLoadingCpsatCleaningPlan$.next(true);
    //this.isCpsatConfigurationFormShown$.next(false);
    //this.isCpsatResultShown$.next(false);
    ////return;

    ////this.cpsatCleaningPlanProgressMessages$.next([...this.cpsatCleaningPlanProgressMessages$.value, new CleaningPlanProgressMessage({
    ////  cleaningPlanId: this.cleaningPlan.id,
    ////  message: "Calculation started",
    ////  statusKey: "STARTED",
    ////})]);

    //let request: GenerateCpsatCleaningPlanCommand = new GenerateCpsatCleaningPlanCommand({
    //  cleaningPlanId: this.cleaningPlan.id,
    //  isTodaysCleaningPlan: MomentDateHelper.isDateToday(this.cleaningPlan.date),
    //  configuration: cpsatConfiguration,
    //});
    //this._cleaningPlanClient.generateCpsatCleaningPlan(request).subscribe((response: ProcessResponse) => {
    //  if (response.isSuccess) {
    //    this._toastr.success(response.message);
    //    this.cpsatConfiguration$.next(new CpsatPlannerConfigurationData(cpsatConfiguration));
    //  }
    //  else {
    //    this._toastr.error(response.message);
    //  }
    //});
  }

  acceptCpsatSolution() {
    this.loading.start();

    this.hideCpsatCofigPopup();
    this.isCpsatResultSucess$.next(false);
    this.isCpsatResultShown$.next(false);
    this.isCpsatConfigurationFormShown$.next(true);
    this.isLoadingCpsatCleaningPlan$.next(false);

    let request: AddCleaningPlanItemsCommand = new AddCleaningPlanItemsCommand({
      cleaningPlanId: this.cleaningPlan.id,
      cleanings: this.cpsatCleaningPlanResult$.value.plannedTimelineItems.map(i => new AddCleaningPlanItem({
        cleaningPlanGroupId: i.cleaningPlanGroupId,
        endString: MomentDateHelper.getIsoDateTime(moment(i.end)),
        startString: MomentDateHelper.getIsoDateTime(moment(i.start)),
        id: i.id,
      }))
    });

    this._cleaningPlanClient.addCleaningPlanItems(request).subscribe(
      (response: ProcessResponse) => {
        if (response.hasError) {
          this._toastr.error(response.message);
          return;
        }

        this.cleaningTimelineService.resetPlannedItems();

        let plannedCleanings: PlannedCleaningTimelineItemData[] = this.cpsatCleaningPlanResult$.value.plannedTimelineItems.map(pti => new PlannedCleaningTimelineItemData(pti));
        let plannableCleanings: CleaningTimelineItemData[] = this.plannableCleanings$.value;
        let remainingPlannableCleanings = [];
        
        for (let plannableCleaning of plannableCleanings) {
          if (!plannedCleanings.find(i => i.id === plannableCleaning.id)) {
            remainingPlannableCleanings.push(plannableCleaning);
          }
        }
        
        this.plannedCleanings$.next(plannedCleanings);
        this.plannableCleanings$.next(remainingPlannableCleanings);

        this.cleaningTimelineService.setPlannedCleanings(plannedCleanings);

        let timelineItems = this.cleaningTimelineService.getTimelineItems();
        this.items$.next(timelineItems);

        this._filterAvailableCleanings();

        this._recalculateCleaningGroupSummaries();
      },
      (error: Error) => {
        this._toastr.error(error.message);
      },
      () => {
        this.loading.stop();
      }
    );

  }

  rerunCpsatAlgorithm() {
    this.isCpsatResultSucess$.next(false);
    this.isCpsatResultShown$.next(false);
    this.isCpsatConfigurationFormShown$.next(true);
    this.isLoadingCpsatCleaningPlan$.next(false);
  }

  resetPlan() {
    this.loading.start();
    let request: ResetCleaningPlanCommand = new ResetCleaningPlanCommand({
      cleaningPlanId: this.cleaningPlan.id,
      isTodaysCleaningPlan: MomentDateHelper.isDateToday(this.cleaningPlan.date),
    });

    this._cleaningPlanClient.resetCleaningPlan(request).subscribe(
      (response: ProcessResponseOfIEnumerableOfCleaningTimelineItemData) => {
        if (response.hasError) {
          this._toastr.error(response.message);
          return;
        }

        let plannedCleanings: Array<PlannedCleaningTimelineItemData> = [];
        let plannableCleanings: Array<CleaningTimelineItemData> = this.cleaningTimelineService.getPlannedItems().map(i => new CleaningTimelineItemData({
          isActive: i.isActive,
          isClean: i.isClean,
          isCustom: i.isCustom,
          isDoNotDisturb: i.isDoNotDisturb,
          isOccupied: i.isOccupied,
          isOutOfOrder: i.isOutOfOrder,
          isPostponed: i.isPostponed,
          isRoomAssigned: i.isRoomAssigned,
          isTaskGuestRequest: i.isTaskGuestRequest,
          isTaskHighPriority: i.isTaskHighPriority,
          isTaskLowPriority: i.isTaskLowPriority,
          price: i.price,
          roomId: i.roomId,
          cleaningPluginId: i.cleaningPluginId,
          cleaningPluginName: i.cleaningPluginName,
          credits: i.credits,
          id: i.id,
          itemTypeKey: i.itemTypeKey,
          reservations: (i.reservations || []).map(r => new CleaningTimelineItemReservationData(r)),
          taskDescription: i.taskDescription,
          tasks: i.tasks,
          title: i.title,
          cleaningDescription: i.cleaningDescription,
          isChangeSheets: i.isChangeSheets,
          buildingId: i.buildingId,
          floorId: i.floorId,
          buildingName: i.buildingName,
          floorName: i.floorName,
          floorSectionName: i.floorSectionName,
          floorSubSectionName: i.floorSubSectionName,
          areaId: i.areaId,
          areaName: i.areaName,
          floorNumber: i.floorNumber,
          hotelId: i.hotelId,
          hotelName: i.hotelName,
          hasArrival: i.hasArrival,
          hasDeparture: i.hasDeparture,
          hasStay: i.hasStay,
          hasVipReservation: i.hasVipReservation,
          roomCategoryId: i.roomCategoryId,
          roomCategoryName: i.roomCategoryName,
          cleaningStatus: i.cleaningStatus,
          isInspected: i.isInspected,
          isInspectionRequired: i.isInspectionRequired,
          isInspectionSuccess: i.isInspectionSuccess,
          isReadyForInspection: i.isReadyForInspection,
          isSent: i.isSent,
          inspectedByFullName: i.inspectedByFullName,
          inspectedById: i.inspectedById,
          bedId: i.bedId,
          isPriority: i.isPriority,
          plannedAttendantTasks: (i.plannedAttendantTasks || []).map(t => new CleaningTimelineItemTaskData({ ...t, actions: t.actions.map(a => new CleaningTimelineItemTaskActionData(a)) })),
          isFilteredOut: false,
        }));

        this.cleaningTimelineService.setPlannedCleanings(plannedCleanings);
        this.plannedCleanings$.next(plannedCleanings);

        let sortedPlannableCleanings = [...this.plannableCleanings$.value, ...plannableCleanings].sort((a, b) => this.sortPlannableCleanings(a, b));
        this.plannableCleanings$.next(sortedPlannableCleanings);

        let timelineItems = this.cleaningTimelineService.getTimelineItems();
        this.items$.next(timelineItems);

        this._filterAvailableCleanings();

        this._resetCleaningGroupSummaries();
      },
      (error: Error) => {
        this._toastr.error(error.message);
        this.loading.stop();
      },
      () => {
        this.loading.stop();
      });
  }

  sortPlannableCleanings(first: CleaningTimelineItemData, second: CleaningTimelineItemData) {
    return first.title.localeCompare(second.title);
  }

  deleteAndRefresh() {
    this.loading.start();

    let request: DeleteAndReloadCleaningPlanCommand = new DeleteAndReloadCleaningPlanCommand({
      cleaningPlanId: this.cleaningPlan.id,
      isTodaysCleaningPlan: MomentDateHelper.isDateToday(this.cleaningPlan.date),
    });

    this._cleaningPlanClient.deleteAndReloadCleaningPlan(request).subscribe(
      (response: ProcessResponseOfDeleteAndReloadCleaningPlanResult) => {
        if (response.hasError) {
          this._toastr.error(response.message);
          return;
        }

        let plannedCleanings: Array<PlannedCleaningTimelineItemData> = response.data.plannedItems;
        let plannableCleanings: Array<CleaningTimelineItemData> = response.data.plannableItems;


        this.cleaningTimelineService.setPlannedCleanings(plannedCleanings);
        this.plannedCleanings$.next(plannedCleanings);

        let sortedPlannableCleanings = [...plannableCleanings].sort((a, b) => this.sortPlannableCleanings(a, b));
        this.plannableCleanings$.next(sortedPlannableCleanings);

        let timelineItems = this.cleaningTimelineService.getTimelineItems();
        this.items$.next(timelineItems);

        this._filterAvailableCleanings();

        this.cleaningTimelineService.resetPlannedItems();
        this.cleaningTimelineService.setPlannedCleanings(response.data.plannedItems);

        this.plannedCleanings$.next(response.data.plannedItems);

        this._recalculateCleaningGroupSummaries();

        //// refresh the timeline items array
        //let plannedTimelineItems: CleaningTimelineItem[] = [];
        //for (let pi of response.data.plannedItems) {
        //  let piGroup = this.plannedGroups$.value.find(g => g.id === pi.cleaningPlanGroupId);
        //  plannedTimelineItems.push(this._createPlannedCleaning(pi, piGroup));
        //}
        //this.items$.next([...this.items$.value.filter(i => i.type !== "range"), ...plannedTimelineItems]);

        //// recalculate summaries
        //this._recalculateCleaningGroupSummaries();
        
        //// refresh the plannable cleanings array
        //this.plannableCleanings$.next(response.data.plannableItems.sort((a, b) => this.sortPlannableCleanings(a, b)));
        //this._filterAvailableCleanings();
      },
      (error: Error) => {
        this._toastr.error(error.message);
      },
      () => {
        this.loading.stop();
      });
  }

  onKeywordsFilterChanged(selectedFilters: Array<SpecificFilterValue>) {
    console.log("FILTER KEYWORDS CHANGED");

    this.selectedFilterKeywords = selectedFilters;

    let plannedItems = this.cleaningTimelineService.getPlannedItems();
    plannedItems.map(pi => pi.isFilteredOut = true);
    this.cleaningTimelineService.setPlannedCleanings(plannedItems);

    this.plannableCleanings$.next(this.plannableCleanings$.value.map(pc => new CleaningTimelineItemData({ ...pc, isFilteredOut: true })));
    this.filteredPlannableCleanings$.next(this.filteredPlannableCleanings$.value.map(pc => new CleaningTimelineItemData({ ...pc, isFilteredOut: true })));

    //this._filterAvailableCleanings();
  }

  sendPlan() {
    this.loading.start();

    let request: SendCleaningPlanCommand = new SendCleaningPlanCommand({
      cleaningPlanId: this.cleaningPlan.id,
      overrideAlreadySentPlan: true,
    });

    this._cleaningPlanClient.sendCleaningPlan(request).subscribe(
      (response: ProcessResponseOfSendCleaningPlanResponse) => {
        if (response.hasError) {
          this._toastr.error(response.message);
          return;
        }

        this.cleaningTimelineService.onCleaningPlanSuccessfullySent();
        this.isCleaningPlanSent$.next(true);
        this.cleaningPlanSentAt$.next(response.data.sentAt.toDate());
      },
      (error: Error) => {
        this._toastr.error(error.message);
        this.loading.stop();
      },
      () => {
        this.loading.stop();
      });
  }

  unlockSentTimelineItems() {
    //this.cleaningTimelineService.unlockSentCleanings();
    //this.areSentItemsLocked$.next(false);
  }

  lockSentTimelineItems() {
    //this.cleaningTimelineService.lockSentCleanings();
    //this.areSentItemsLocked$.next(true);
  }

  onAttendantCreated(result: QuickCreateAttendantResult) {
    let cleanerData = new CleanerData({
      id: result.user.id,
      avatarUrl: result.user.avatarImageUrl,
      fullNameInitials: result.user.fullNameInitials,
      mustFillAllCredits: false,
      availabilityIntervals: [],
      affinities: [],
      groupName: result.groupName,
      maxCredits: 0,
      maxDepartures: 0,
      maxTwins: 0,
      name: result.user.firstName + ' ' + result.user.lastName,
      subGroupName: result.subGroupName,
      username: result.user.username,
      weekHours: 0
    });
    this.cleanersData.push(cleanerData);
    this.selectCleanersService.addSelectedCleaner(cleanerData);
    this.closeQuickAttendant();
    this.saveSelectedCleaners();
  }

  toggleShowCpsatConfigurationDrawer() {
    this.showCpsatConfigurationDrawer$.next(!this.showCpsatConfigurationDrawer$.value);
  }

  onCleaningTimelineFilterChanged(options: Array<CleaningTimelineFilterOption>) {
    this.selectedFilterOptions = options;
    this._filterAvailableCleanings();
  }

  private _refreshAvailableCleaningsAfterAcceptingCspatResult() {

    let plannedItems = this.cpsatCleaningPlanResult$.value.plannedTimelineItems;
    let plannableItems = this.plannableCleanings$.value;
    //let filteredPlannableItems = this.filteredAvailableCleanings$.value;

    let remainingPlannableItems = [];
    //let remainingFilteredPlannableItems = [];

    for (let plannableItem of plannableItems) {
      if (!plannedItems.find(i => i.id === plannableItem.id)) {
        remainingPlannableItems.push(plannableItem);
      }
    }
    //for (let plannableItem of filteredPlannableItems) {
    //  if (!plannedItems.find(i => i.id === plannableItem.id)) {
    //    remainingFilteredPlannableItems.push(plannableItem);
    //  }
    //}

    this.plannedCleanings$.next(plannedItems);
    this.plannableCleanings$.next(remainingPlannableItems);
    //this.filteredAvailableCleanings$.next(remainingFilteredPlannableItems);

    this._filterAvailableCleanings();
  }

  private _setFilteredWheres() {
    let hotelId = this._hotelService.getSelectedHotelId();
    this.hotelWheres$.next(this.allWheres.filter(w => !w.hotelId || w.hotelId == hotelId));
  }

  private _setCleaningActiveStatusVisuals(isActive: boolean) {
    let selectedItemsMap = {};
    for (let c of this.selectedPlannableCleanings$.value) {
      selectedItemsMap[c.id] = true;
    }

    let availableCleanings = [];
    let filteredCleanings = [];

    for (let c of this.plannableCleanings$.value) {
      if (selectedItemsMap[c.id]) {
        let ac: CleaningTimelineItemData = new CleaningTimelineItemData(c)
        ac.isActive = isActive;
        availableCleanings.push(ac);
      }
      else {
        availableCleanings.push(c);
      }
    }
    for (let c of this.filteredPlannableCleanings$.value) {
      if (selectedItemsMap[c.id]) {
        let ac: CleaningTimelineItemData = new CleaningTimelineItemData(c)
        ac.isActive = isActive;
        filteredCleanings.push(ac);
      }
      else {
        filteredCleanings.push(c);
      }
    }

    this.plannableCleanings$.next(availableCleanings);
    this.filteredPlannableCleanings$.next(filteredCleanings);
  }

  private _setCleaningPostponedStatusVisuals(isPostponed: boolean) {
    let selectedItemsMap = {};
    for (let c of this.selectedPlannableCleanings$.value) {
      selectedItemsMap[c.id] = true;
    }

    let availableCleanings = [];
    let filteredCleanings = [];

    for (let c of this.plannableCleanings$.value) {
      if (selectedItemsMap[c.id]) {
        let ac: CleaningTimelineItemData = new CleaningTimelineItemData(c)
        ac.isPostponed = isPostponed;
        availableCleanings.push(ac);
      }
      else {
        availableCleanings.push(c);
      }
    }
    for (let c of this.filteredPlannableCleanings$.value) {
      if (selectedItemsMap[c.id]) {
        let ac: CleaningTimelineItemData = new CleaningTimelineItemData(c)
        ac.isPostponed = isPostponed;
        filteredCleanings.push(ac);
      }
      else {
        filteredCleanings.push(c);
      }
    }

    this.plannableCleanings$.next(availableCleanings);
    this.filteredPlannableCleanings$.next(filteredCleanings);
  }

  private _createFilterCleaningsForm(): FormGroup {
    let form: FormGroup = this._formBuilder.group({
      keywords: [''],

      filterOnlyClean: [false],
      filterOnlyDirty: [false],
      filterOnlyInspected: [false],
      filterOnlyVacant: [false],
      filterOnlyOccupied: [false],
      filterOnlyDoNotDisturb: [false],
      filterOnlyOutOfService: [false],
      filterOnlyPostponed: [false],
      filterOnlyActive: [false],
      filterOnlyInactive: [false],
      filterOnlyStay: [false],
      filterOnlyCheckIn: [false],
      filterOnlyCheckOut: [false],
      filterOnlyVip: [false],
    });

    form.valueChanges.subscribe((formValue: any) => {
      this._filterAvailableCleanings();
    });

    return form;
  }

  private _generateCleaningCounts(plannableCleanings: Array<CleaningTimelineItemData>, plannedCleanings: Array<PlannedCleaningTimelineItemData>): Array<CleaningCount> {
    // Clean
    // Dirty
    // Inspected
    // Cleaning plugins
    let counts: CleaningCount[] = [];

    let c = {
      clean: 0,
      dirty: 0,
      inspected: 0,
      custom: 0,
    };
    let cleaningNames: string[] = [];

    for (let cleaning of plannableCleanings) {
      if (cleaning.isCustom) {
        c.custom++;
      }
      else if (!c[cleaning.cleaningDescription]) {
        c[cleaning.cleaningDescription] = 0;
        cleaningNames.push(cleaning.cleaningDescription);
      }

      c[cleaning.cleaningDescription]++;

      if (cleaning.isClean) {
        c.clean++;
      }
      else {
        c.dirty++;
      }

      if (cleaning.isInspected) {
        c.inspected++;
      }
    }
    for (let cleaning of plannedCleanings) {
      if (cleaning.isCustom) {
        c.custom++;
      }
      else if (!c[cleaning.cleaningDescription]) {
        c[cleaning.cleaningDescription] = 0;
        cleaningNames.push(cleaning.cleaningDescription);
      }

      c[cleaning.cleaningDescription]++;

      if (cleaning.isClean) {
        c.clean++;
      }
      else {
        c.dirty++;
      }

      if (cleaning.isInspected) {
        c.inspected++;
      }
    }

    counts.push({ count: c.clean, description: "Clean" });
    counts.push({ count: c.dirty, description: "Dirty" });
    counts.push({ count: c.inspected, description: "Inspected" });

    if (c.custom > 0) {
      counts.push({ count: c.custom, description: "Custom" });
    }

    for (let cleaningName of cleaningNames) {
      counts.push({ count: c[cleaningName], description: cleaningName });
    }

    return counts;
  }

  private _generateCleaningFilterValues(plannableCleanings: Array<CleaningTimelineItemData>, plannedCleanings: Array<PlannedCleaningTimelineItemData>): Array<CleaningTimelineFilterGroup> {
    let otherGroup = new CleaningTimelineFilterGroup("OTHER", "Other");
    otherGroup.options = [
      new CleaningTimelineFilterOption("OTHER", "VIP", "Guest status", "VIP"),
      new CleaningTimelineFilterOption("OTHER", "Clean", "Cleanliness", "CLEAN"),
      new CleaningTimelineFilterOption("OTHER", "Dirty", "Cleanliness", "DIRTY"),
      new CleaningTimelineFilterOption("OTHER", "Inspected", "Cleanliness", "INSPECTED"),
      new CleaningTimelineFilterOption("OTHER", "Occupied", "Occupancy", "OCCUPIED"),
      new CleaningTimelineFilterOption("OTHER", "Vacant", "Occupancy", "VACANT"),
      new CleaningTimelineFilterOption("OTHER", "Day use", "Occupancy", "DAY_USE"),
      new CleaningTimelineFilterOption("OTHER", "Custom cleaning", "Cleaning type", "CUSTOM_CLEANING"),
      new CleaningTimelineFilterOption("OTHER", "Arrival", "Guest status", "ARRIVAL"),
      new CleaningTimelineFilterOption("OTHER", "Departure", "Guest status", "DEPARTURE"),
      new CleaningTimelineFilterOption("OTHER", "Stay", "Guest status", "STAY"),
      new CleaningTimelineFilterOption("OTHER", "Do not disturb", "Room status", "DND"),
      new CleaningTimelineFilterOption("OTHER", "Out of order", "Room status", "OOO"),
      new CleaningTimelineFilterOption("OTHER", "Out of service", "Room status", "OOS"),
    ];

    let buildingsGroup = new CleaningTimelineFilterGroup("BUILDINGS", "Buildings");
    let buildingNames = this._getArrayOfUniqueValues(plannableCleanings, plannedCleanings, "buildingName", "buildingId");
    buildingsGroup.options = buildingNames.map(b => new CleaningTimelineFilterOption("BUILDINGS", b.value, "Building", b.id));

    let floorsGroup = new CleaningTimelineFilterGroup("FLOORS", "Floors");
    let floorNames = this._getArrayOfUniqueValues(plannableCleanings, plannedCleanings, "floorName", "floorId");
    floorsGroup.options = floorNames.map(f => new CleaningTimelineFilterOption("FLOORS", f.value, "Floor", f.id));

    let floorSectionsGroup = new CleaningTimelineFilterGroup("FLOOR_SECTIONS", "Floor sections");
    let floorSectionNames = this._getArrayOfUniqueValues(plannableCleanings, plannedCleanings, "floorSectionName", "floorSectionName");
    floorSectionsGroup.options = floorSectionNames.map(fs => new CleaningTimelineFilterOption("FLOOR_SECTIONS", fs.value, "Floor section", fs.id));

    let floorSubSectionsGroup = new CleaningTimelineFilterGroup("FLOOR_SUB_SECTIONS", "Floor sub sections");
    let floorSubSectionNames = this._getArrayOfUniqueValues(plannableCleanings, plannedCleanings, "floorSubSectionName", "floorSubSectionName");
    floorSubSectionsGroup.options = floorSubSectionNames.map(fss => new CleaningTimelineFilterOption("FLOOR_SUB_SECTIONS", fss.value, "Floor subsection", fss.id));

    let roomsGroup = new CleaningTimelineFilterGroup("ROOMS", "Rooms");
    let roomNames = this._getArrayOfUniqueValues(plannableCleanings, plannedCleanings, "title", "title");
    roomsGroup.options = roomNames.map(r => new CleaningTimelineFilterOption("ROOMS", r.value, "Room", r.id));

    let cleaningPluginsGroup = new CleaningTimelineFilterGroup("CLEANING_PLUGINS", "Cleaning plugins");
    let cleaningPluginNames = this._getArrayOfUniqueValues(plannableCleanings, plannedCleanings, "cleaningDescription", "cleaningDescription");
    cleaningPluginsGroup.options = cleaningPluginNames.map(cp => new CleaningTimelineFilterOption("CLEANING_PLUGINS", cp.value, "Cleaning plugin", cp.id));

    let roomCategoryGroup = new CleaningTimelineFilterGroup("ROOM_CATEGORIES", "Room categories");
    let roomCategoryNames = this._getArrayOfUniqueValues(plannableCleanings, plannedCleanings, "roomCategoryName", "roomCategoryId");
    roomCategoryGroup.options = roomCategoryNames.map(rc => new CleaningTimelineFilterOption("ROOM_CATEGORIES", rc.value, "Room category", rc.id));

    let guestGroup = new CleaningTimelineFilterGroup("GUESTS", "Guests");
    let guestNames = this._getUniqueReservations(plannableCleanings, plannedCleanings);
    //let guestNames = this._getArrayOfUniqueValues(plannableCleanings, plannedCleanings, "roomCategoryName");
    guestGroup.options = guestNames.map(g => new CleaningTimelineFilterOption("GUESTS", g.value, "Guest", g.id));

    return [
      otherGroup,
      buildingsGroup,
      floorsGroup,
      floorSectionsGroup,
      floorSubSectionsGroup,
      roomsGroup,
      cleaningPluginsGroup,
      roomCategoryGroup,
      guestGroup
    ];
  }

  private _getUniqueReservations(plannableCleanings: Array<CleaningTimelineItemData>, plannedCleanings: Array<PlannedCleaningTimelineItemData>): Array<{ id: string, value: string }> {
    var unique = {};
    var distinct: Array<{ id: string, value: string }> = [];

    for (let c of plannableCleanings) {
      for (let r of c.reservations) {
        if (!unique[r.reservationId]) {
          unique[r.reservationId] = r.guestName;
          distinct.push({ id: r.reservationId, value: r.guestName });
        }
      }
    }
    
    for (let c of plannedCleanings) {
      for (let r of c.reservations) {
        if (!unique[r.reservationId]) {
          unique[r.reservationId] = r.guestName;
          distinct.push({ id: r.reservationId, value: r.guestName });
        }
      }
    }

    return distinct;
  }

  private _getArrayOfUniqueValues(objects1: Array<any>, objects2: Array<any>, propertyName: string, propertyIdName: string): Array<{ id: string, value: string }> {
    var unique = {};
    var distinct: Array<{ id: string, value: string }> = [];
    for (let i = 0; i < objects1.length; i++) {
      let propertyId = objects1[i][propertyIdName];
      let propertyValue = objects1[i][propertyName];
      if (!propertyId) continue;

      if (!unique[propertyId]) {
        distinct.push({ id: propertyId, value: propertyValue });
        unique[propertyId] = 1;
      }
    }
    for (let i = 0; i < objects2.length; i++) {
      let propertyId = objects2[i][propertyIdName];
      let propertyValue = objects2[i][propertyName];
      if (!propertyId) continue;

      if (!unique[propertyId]) {
        distinct.push({ id: propertyId, value: propertyValue });
        unique[propertyId] = 1;
      }
    }

    return distinct;
  }

  private _filterAvailableCleanings() {
    let formValues = this.filterCleaningsForm.getRawValue();
    //let keywordsValue = formValues.keywords.toString().toLowerCase();

    let plannableCleanings: Array<CleaningTimelineItemData> = [];
    let plannedCleanings: Array<PlannedCleaningTimelineItemData> = [];

    if (this.selectedFilterOptions.length === 0) {
      plannableCleanings = this.plannableCleanings$.value.map(pc => new CleaningTimelineItemData({ ...pc, isFilteredOut: false }));
      plannedCleanings = this.cleaningTimelineService.getPlannedItems().map(pc => new PlannedCleaningTimelineItemData({ ...pc, isFilteredOut: false }));
    }
    else {
      for (let pc of this.plannableCleanings$.value) {
        let isFilteredOut = true;

        for (let option of this.selectedFilterOptions) {
            if (
              (option.id === "VIP" && pc.hasVipReservation) ||
              (option.id === "CLEAN" && pc.isClean) ||
              (option.id === "DIRTY" && !pc.isClean) ||
              (option.id === "INSPECTED" && pc.isInspected) ||
              (option.id === "OCCUPIED" && pc.isOccupied) ||
              (option.id === "VACANT" && !pc.isOccupied) ||
              (option.id === "DAY_USE" && true) ||
              (option.id === "CUSTOM_CLEANING" && pc.isCustom) ||
              (option.id === "ARRIVAL" && pc.hasArrival) ||
              (option.id === "DEPARTURE" && pc.hasDeparture) ||
              (option.id === "STAY" && pc.hasStay) ||
              (option.id === "DND" && pc.isDoNotDisturb) ||
              (option.id === "OOO" && pc.isOutOfOrder) ||
              (option.id === "OOS" && true) ||
              (option.groupKey === "BUILDINGS" && option.id === pc.buildingId) ||
              (option.groupKey === "FLOORS" && option.id === pc.floorId) ||
              (option.groupKey === "FLOOR_SECTIONS" && option.id === pc.floorSectionName) ||
              (option.groupKey === "FLOOR_SUB_SECTIONS" && option.id === pc.floorSubSectionName) ||
              (option.groupKey === "ROOMS" && option.id === pc.title) ||
              (option.groupKey === "CLEANING_PLUGINS" && option.id === pc.cleaningDescription) ||
              (option.groupKey === "ROOM_CATEGORIES" && option.id === pc.roomCategoryId) ||
              (option.groupKey === "GUESTS" && pc.reservations.filter(r => r.reservationId === option.id).length > 0)
            ) {
              isFilteredOut = false;
              break;
            }

            //pc.isFilteredOut = isFilteredOut;
        }

        plannableCleanings.push(new CleaningTimelineItemData({ ...pc, isFilteredOut: isFilteredOut }));
      }
      for (let pc of this.cleaningTimelineService.getPlannedItems()) {
        let isFilteredOut = true;

        for (let option of this.selectedFilterOptions) {
            if (
              (option.id === "VIP" && pc.hasVipReservation) ||
              (option.id === "CLEAN" && pc.isClean) ||
              (option.id === "DIRTY" && !pc.isClean) ||
              (option.id === "INSPECTED" && pc.isInspected) ||
              (option.id === "OCCUPIED" && pc.isOccupied) ||
              (option.id === "VACANT" && !pc.isOccupied) ||
              (option.id === "DAY_USE" && true) ||
              (option.id === "CUSTOM_CLEANING" && pc.isCustom) ||
              (option.id === "ARRIVAL" && pc.hasArrival) ||
              (option.id === "DEPARTURE" && pc.hasDeparture) ||
              (option.id === "STAY" && pc.hasStay) ||
              (option.id === "DND" && pc.isDoNotDisturb) ||
              (option.id === "OOO" && pc.isOutOfOrder) ||
              (option.id === "OOS" && true) ||
              (option.groupKey === "BUILDINGS" && option.id === pc.buildingId) ||
              (option.groupKey === "FLOORS" && option.id === pc.floorId) ||
              (option.groupKey === "FLOOR_SECTIONS" && option.id === pc.floorSectionName) ||
              (option.groupKey === "FLOOR_SUB_SECTIONS" && option.id === pc.floorSubSectionName) ||
              (option.groupKey === "ROOMS" && option.id === pc.title) ||
              (option.groupKey === "CLEANING_PLUGINS" && option.id === pc.cleaningDescription) ||
              (option.groupKey === "ROOM_CATEGORIES" && option.id === pc.roomCategoryId) ||
              (option.groupKey === "GUESTS" && pc.reservations.filter(r => r.reservationId === option.id).length > 0)
            ) {
              isFilteredOut = false;
              break;
            }

            //pc.isFilteredOut = isFilteredOut;
        }

        plannedCleanings.push(new PlannedCleaningTimelineItemData({ ...pc, isFilteredOut: isFilteredOut }));
      }
    }
    //else {
    //  if (this.selectedFilterKeywords.length === 1 && this.selectedFilterKeywords[0].key === "__ANYTHING__" && !this.selectedFilterKeywords[0].value) {
    //    cleanings = this.plannableCleanings$.value;
    //  }
    //  else {
    //    cleanings = this.plannableCleanings$.value;

    //    for (let filter of this.selectedFilterKeywords) {
    //      let filterValue = filter.value.trim().toLowerCase();

    //      if (filter.key === "__ANYTHING__") {
    //        cleanings = cleanings.filter(c =>
    //          (c.buildingName && c.buildingName.toLowerCase().indexOf(filterValue) > -1)
    //          || (c.floorName && c.floorName.toLowerCase().indexOf(filterValue) > -1)
    //          || (c.title.toLowerCase().indexOf(filterValue) > -1)
    //          || (c.floorSectionName && c.floorSectionName.toLowerCase().indexOf(filterValue) > -1)
    //          || (c.floorSubSectionName && c.floorSubSectionName.toLowerCase().indexOf(filterValue) > -1)
    //          || (c.cleaningDescription && c.cleaningDescription.toLowerCase().indexOf(filterValue) > -1)
    //          || (c.roomCategoryName && c.roomCategoryName.toLowerCase().indexOf(filterValue) > -1)
    //        );
    //      }
    //      else if (filter.key === "FLOOR") {
    //        cleanings = cleanings.filter(c => (c.floorName && c.floorName.toLowerCase().indexOf(filterValue) > -1));
    //      }
    //      else if (filter.key === "BUILDING") {
    //        cleanings = cleanings.filter(c => (c.buildingName && c.buildingName.toLowerCase().indexOf(filterValue) > -1));
    //      }
    //      else if (filter.key === "ROOM") {
    //        cleanings = cleanings.filter(c => (c.title.toLowerCase().indexOf(filterValue) > -1));
    //      }
    //      else if (filter.key === "FLOOR_SECTION") {
    //        cleanings = cleanings.filter(c => (c.floorSectionName && c.floorSectionName.toLowerCase().indexOf(filterValue) > -1));
    //      }
    //      else if (filter.key === "FLOOR_SUB_SECTION") {
    //        cleanings = cleanings.filter(c => (c.floorSubSectionName && c.floorSubSectionName.toLowerCase().indexOf(filterValue) > -1));
    //      }
    //      else if (filter.key === "CLEANING_NAME") {
    //        cleanings = cleanings.filter(c => (c.cleaningDescription && c.cleaningDescription.toLowerCase().indexOf(filterValue) > -1));
    //      }
    //      else if (filter.key === "ROOM_CATEGORY") {
    //        cleanings = cleanings.filter(c => (c.roomCategoryName && c.roomCategoryName.toLowerCase().indexOf(filterValue) > -1));
    //      }
    //      else if (filter.key === "VIP") {
    //        cleanings = cleanings.filter(c => (c.hasVipReservation && c.vipValues.filter(vv => vv.toLowerCase().toLowerCase().indexOf(filterValue) > -1).length > 0));
    //      }
    //    }
    //  }
    //}

    //if (formValues.filterOnlyClean) {
    //  cleanings = cleanings.filter(c => c.isClean);
    //}
    //if (formValues.filterOnlyDirty) {
    //  cleanings = cleanings.filter(c => !c.isClean);
    //}
    //if (formValues.filterOnlyInspected) {
    //}
    //if (formValues.filterOnlyVacant) {
    //  cleanings = cleanings.filter(c => !c.isOccupied);
    //}
    //if (formValues.filterOnlyOccupied) {
    //  cleanings = cleanings.filter(c => c.isOccupied);
    //}
    //if (formValues.filterOnlyDoNotDisturb) {
    //  cleanings = cleanings.filter(c => c.isDoNotDisturb);
    //}
    //if (formValues.filterOnlyOutOfService) {
    //  cleanings = cleanings.filter(c => c.isOutOfOrder);
    //}
    //if (formValues.filterOnlyPostponed) {
    //  cleanings = cleanings.filter(c => c.isPostponed);
    //}
    //if (formValues.filterOnlyActive) {
    //  cleanings = cleanings.filter(c => c.isActive);
    //}
    //if (formValues.filterOnlyInactive) {
    //  cleanings = cleanings.filter(c => !c.isActive);
    //}
    //if (formValues.filterOnlyStay) {
    //  cleanings = cleanings.filter(c => c.hasStay);
    //}
    //if (formValues.filterOnlyCheckIn) {
    //  cleanings = cleanings.filter(c => c.hasArrival);
    //}
    //if (formValues.filterOnlyCheckOut) {
    //  cleanings = cleanings.filter(c => c.hasDeparture);
    //}
    //if (formValues.filterOnlyVip) {
    //  cleanings = cleanings.filter(c => c.hasVipReservation);
    //}

    //let nrOfClean = 0;
    //let nrOfDirty = 0;
    //let nrOfInspected = 0;
    //let nrOfVacant = 0;
    //let nrOfOccupied = 0;
    //let nrOfDoNotDisturb = 0;
    //let nrOfOutOfService = 0;
    //let nrOfPostponed = 0;
    //let nrOfActive = 0;
    //let nrOfInactive = 0;
    //let nrOfStay = 0;
    //let nrOfCheckIn = 0;
    //let nrOfCheckOut = 0;
    //let nrOfVip = 0;

    //for (let c of cleanings) {
    //  if (c.isClean) { nrOfClean++; } else { nrOfDirty++; }
    //  if (c.isOccupied) { nrOfOccupied++; } else { nrOfVacant++; }
    //  if (c.isDoNotDisturb) { nrOfDoNotDisturb++; }
    //  if (c.isOutOfOrder) { nrOfOutOfService++; }
    //  if (c.isPostponed) { nrOfPostponed++; }
    //  if (c.isActive) { nrOfActive++; } else { nrOfInactive++; }
    //  if (c.hasStay) { nrOfStay++; }
    //  if (c.hasArrival) { nrOfCheckIn++; }
    //  if (c.hasDeparture) { nrOfCheckOut++; }
    //  if (c.hasVipReservation) { nrOfVip++; }
    //}

    //this.filteredNumberOfActiveCleanings$.next(nrOfActive);
    //this.filteredNumberOfCheckInCleanings$.next(nrOfCheckIn);
    //this.filteredNumberOfCheckOutCleanings$.next(nrOfCheckOut);
    //this.filteredNumberOfCleanCleanings$.next(nrOfClean);
    //this.filteredNumberOfDirtyCleanings$.next(nrOfDirty);
    //this.filteredNumberOfDoNotDisturbCleanings$.next(nrOfDoNotDisturb);
    //this.filteredNumberOfInactiveCleanings$.next(nrOfInactive);
    //this.filteredNumberOfInspectedCleanings$.next(nrOfInspected);
    //this.filteredNumberOfOccupiedCleanings$.next(nrOfOccupied);
    //this.filteredNumberOfOutOfServiceCleanings$.next(nrOfOutOfService);
    //this.filteredNumberOfPostponedCleanings$.next(nrOfPostponed);
    //this.filteredNumberOfStayCleanings$.next(nrOfStay);
    //this.filteredNumberOfVacantCleanings$.next(nrOfVacant);
    //this.filteredNumberOfVipCleanings$.next(nrOfVip);

    this.filteredPlannableCleanings$.next(plannableCleanings);
    this.plannedCleanings$.next(plannedCleanings);

    this.cleaningTimelineService.setPlannedCleanings(plannedCleanings);
  }

  private _resetFilterCleaningsForm(): void {
    this.filterCleaningsForm.controls.keywords.setValue('');
    this.filterCleaningsForm.controls.plannableStatusSelected.setValue(false);
    this.filterCleaningsForm.controls.otherStatusSelected.setValue(false);
    this.filterCleaningsForm.controls.postponedStatusSelected.setValue(false);
  }
}
