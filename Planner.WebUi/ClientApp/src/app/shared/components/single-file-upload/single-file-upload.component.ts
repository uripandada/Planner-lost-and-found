import { Component, OnInit, Input, EventEmitter, Output, ViewChild, ElementRef, Inject, Optional, OnChanges, SimpleChanges, OnDestroy } from '@angular/core';
import { AuthorizeService, IUser } from '../../../../api-authorization/authorize.service';
import { Observable, BehaviorSubject, Subscription } from 'rxjs';
import { HttpClient, HttpEvent, HttpEventType } from '@angular/common/http';
import { ToastrService } from 'ngx-toastr';
import { API_BASE_URL, ITaskFileDetailsData } from '../../../core/autogenerated-clients/api-client';
import { map } from 'rxjs/operators';
import { FileDetails, FilesChangedData, FileUploadData, FileUploadResponseProgressData } from '../file-upload/file-upload.component';

export class SingleFileChangedData {
  id: string;
  isNewlyUploaded: boolean;
  isStillUploading: boolean;
  fileName: string;
  sanitizedFileName: string;
  imageUrl: string;
}

@Component({
  selector: 'app-single-file-upload',
  templateUrl: './single-file-upload.component.html',
  styleUrls: ['./single-file-upload.component.scss']
})
export class SingleFileUploadComponent implements OnInit, OnChanges, OnDestroy {

  @ViewChild('hiddenFileUpload', { static: true }) fileUploadElement: ElementRef;

  @Input() uploadedFile: FileDetails = null;
  @Input() noImageBackgroundUrl: string = "assets/images/no_image_400x400.jpg";

  @Output() fileUploaded: EventEmitter<FileDetails> = new EventEmitter<FileDetails>();
  @Output() fileRemoved: EventEmitter<FileDetails> = new EventEmitter<FileDetails>();
  
  isFileUploaded$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(false);
  uploadedFile$: BehaviorSubject<FileDetails> = new BehaviorSubject<FileDetails>(null);

  isUploadInProgress$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(false);
  progress$: Observable<number>;

  private _progress$: BehaviorSubject<number> = new BehaviorSubject<number>(0);
  private _httpClient: HttpClient;

  constructor(@Inject(HttpClient) httpClient: HttpClient, private toastr: ToastrService, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this._httpClient = httpClient;
    this.progress$ = this._progress$.asObservable();
  }

  ngOnDestroy(): void {
  }

  ngOnInit(): void {
    this.uploadedFile$.next(this.uploadedFile);
    this.isFileUploaded$.next(this.uploadedFile !== null);
  }

  ngOnChanges(changes: SimpleChanges): void {
    if (changes.uploadedFile) {
      this.uploadedFile$.next(this.uploadedFile);
      this.isFileUploaded$.next(this.uploadedFile !== null);
    }
  }

  private _createFileUploadRequestData(file: File): FileUploadData{
    const fileExtensionData = this._getFileExtensionData(file.name);
    const fileNameWithoutExtension = this._getFileNameWithoutExtension(file.name);
    const sanitizedFileName = this._sanitizeFileName(fileNameWithoutExtension, fileExtensionData.extension);

    return {
      file: file,
      temporaryImageUrl: URL.createObjectURL(file),
      imageUrl: '',
      sanitizedFileName: sanitizedFileName,
      isUploadInProgress: false,
      isUploaded: false,
      hasError: false,
      message: '',
      displayText: "." + fileExtensionData.extension,
      isImage: fileExtensionData.isImage
    };
  }

  /// This function is called after user selects file for upload from the browser's built in select file dialog.
  uploadFilesToTemporaryStorage(files: FileList) {
    if (files.length === 0) {
      return;
    }

    this.isUploadInProgress$.next(true);
    this._updateProgress(0);

    // our uploads have only one item in the array
    const uploadRequests: Array<FileUploadData> = [
      this._createFileUploadRequestData(files.item(0))
    ]; 

    // Create the file upload observable
    let fileUpload$ = this.uploadFilesWithProgress(uploadRequests);

    // Subscribe to every emission of the upload file with progress
    fileUpload$.subscribe((progressResponse: FileUploadResponseProgressData) => {
      if (!progressResponse.uploadFinished && progressResponse.status == "upload_in_progress") {
        this._updateProgress(progressResponse.progressValue);
      }
      else if (progressResponse.uploadFinished && progressResponse.status == "upload_finished") {
        this.isUploadInProgress$.next(false);
        this._updateProgress(100);

        // We only upload 1 file so there should be only 1 item in the response array
        const fileUploadItemResponse = progressResponse.response[0];

        if (fileUploadItemResponse.hasError) {
          this.toastr.error(fileUploadItemResponse.message);
          return;
        }

        if (fileUploadItemResponse.alreadyExists) {
          this.toastr.info(fileUploadItemResponse.message);
        }
        else {
          this.toastr.success(fileUploadItemResponse.message);
        }

        var fileExtensionData = this._getFileExtensionData(fileUploadItemResponse.fileName);
        var fileDetails: FileDetails = {
          fileName: fileUploadItemResponse.fileName,
          imageUrl: fileUploadItemResponse.imageUrl,
          id: null,
          displayText: '.' + fileExtensionData.extension,
          isImage: fileExtensionData.isImage
        };
        this.uploadedFile$.next(fileDetails);
        this.isFileUploaded$.next(true);
        this.fileUploaded.next(fileDetails);

        this._clearFileUploadElement();        
      }
    });
  }

  private _onUploadProgressed(event: HttpEvent<any>): FileUploadResponseProgressData {
    switch (event.type) {
      case HttpEventType.UploadProgress:
        const progress: number = Math.round(100 * event.loaded / event.total);
        return {
          status: 'upload_in_progress',
          progressValue: progress,
          uploadFinished: false,
          response: undefined,
          eventType: "UploadProgress"
        };
      case HttpEventType.Response:
        return {
          status: 'upload_finished',
          progressValue: 100,
          uploadFinished: true,
          response: event.body,
          eventType: "Response"
        };
      case HttpEventType.ResponseHeader:
        return {
          status: 'response_header',
          progressValue: -2,
          uploadFinished: false,
          response: undefined,
          eventType: "ResponseHeader"
        };
      case HttpEventType.Sent:
        return {
          status: 'sent',
          progressValue: -3,
          uploadFinished: false,
          response: undefined,
          eventType: "Sent"
        };
      default:
        return {
          status: 'unhandled_event',
          progressValue: -1,
          uploadFinished: false,
          response: undefined,
          eventType: event.type.toString()
        };
    };
  }

  uploadFilesWithProgress(fileUploads: Array<FileUploadData>): Observable<FileUploadResponseProgressData> {
    this._updateProgress(0);

    const formData: FormData = new FormData();
    const filesData: Array<{ sanitizedFileName: string }> = [];
    for (const preparedFile of fileUploads) {
      formData.append('files', preparedFile.file, preparedFile.sanitizedFileName);
      filesData.push({ sanitizedFileName: preparedFile.sanitizedFileName });
    }

    for (let i = 0; i < filesData.length; i++) {
      formData.append(`filesData[${i}][sanitizedFileName]`, filesData[i].sanitizedFileName);
    }

    return this._httpClient.post<any>(`/api/file/uploadFiles`, formData, { reportProgress: true, observe: 'events' })
      .pipe(
        map((event: HttpEvent<any>) => { return this._onUploadProgressed(event); })
      );
  }

  removeUploadedFile() {
    this.isFileUploaded$.next(false);
    this.fileRemoved.next(this.uploadedFile$.value);
    this.uploadedFile$.next(null);
  }
 
  private _getFileNameWithoutExtension(fileName) {
    return fileName.replace(/\.[^/.]+$/, '');
  }

  private _getFileExtensionData(fileName): { extension: string, isImage: boolean } {
    const fileNameParts: Array<string> = fileName.split('.');
    if (fileNameParts.length === 1 || (fileNameParts[0] === '' && fileNameParts.length === 2)) {
      return { extension: '', isImage: false };
    }

    const extension: string = fileNameParts.pop().toLowerCase();
    const imageExtensions: Array<string> = ["jpg", "jpeg", "bmp", "tif", "tiff", "png"];
    const isImage: boolean = imageExtensions.indexOf(extension) > -1;

    return {
      extension: extension,
      isImage: isImage
    };
  }

  private _sanitizeFileName(fileNameWithoutExtension, fileExtension) {
    return fileNameWithoutExtension.replace(/[^a-z0-9]/gi, '_').replace(/_+/g, '_').toLowerCase() + (fileExtension ? '.' + fileExtension : '');
  }

  private _updateProgress(progress: number) {
    this._progress$.next(progress);
  }

  private _clearFileUploadElement() {
    this.fileUploadElement.nativeElement.value = "";
  }
}

