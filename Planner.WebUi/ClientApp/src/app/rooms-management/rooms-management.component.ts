import { Component, OnDestroy, OnInit, ViewChild } from '@angular/core';
import { FormGroup, FormBuilder, FormArray, Validators } from '@angular/forms';
import { ActivatedRoute, Router } from '@angular/router';
import { FullRoomHierarchyData,
         RoomManagementClient,
         GetFullRoomHierarchyQuery,
         FullRoomHierarchyBuildingData,
         FullRoomHierarchyFloorData,
         FullRoomHierarchyAreaData,
         DeleteBuildingCommand,
         ProcessResponse,
         HotelItemData,
         FullRoomHierarchyRoomData,
         RoomCategoryGridItemViewModel,
         RoomDetailsData,
         InsertRoomCommand,
         UpdateRoomCommand,
         ProcessResponseOfInsertRoomResponse,
         GetUnassignedRoomsQuery,
         PageOfOfUnassignedRoomData,
         UnassignedRoomData,
         AssignRoomsToFloorCommand,
         ProcessResponseOfRoomAssignmentResultOf,
         RoomAssignmentResult,
         WarehouseDetailsData,
         WarehouseData,
         ExportRoomsClient,
         FileResponse,
         RoomDetailsBed} from '../core/autogenerated-clients/api-client';
import { AreasService } from './services/areas.service';
import { LoadingService } from '../core/services/loading.service';
import { ToastrService } from 'ngx-toastr';
import { HotelService } from '../core/services/hotel.service';
import { debounceTime } from 'rxjs/operators';
import { BehaviorSubject, Subject } from 'rxjs';
import { RoomTypeService } from '../core/services/room-type.service';
import { SelectContainerComponent } from 'ngx-drag-to-select';
import { HttpClient } from '@angular/common/http';
import { FileSaverService } from 'ngx-filesaver';

@Component({
  selector: 'app-rooms-management',
  templateUrl: './rooms-management.component.html',
  styleUrls: ['./rooms-management.component.scss']
})
export class RoomsManagementComponent implements OnInit, OnDestroy {
  sorts = [
    { key: 'BUILDING_NAME_ASC', value: 'Building name A to Z' },
    { key: 'BUILDING_NAME_DESC', value: 'Building name Z to A' },
    { key: 'BUILDING_CREATED_AT_DESC', value: 'Building creation time' },
    { key: 'FLOOR_NAME_ASC', value: 'Floor name A to Z' },
    { key: 'FLOOR_NAME_DESC', value: 'Floor name Z to A' },
    { key: 'FLOOR_CREATED_AT_DESC', value: 'Floor creation time' },
    { key: 'ROOM_NAME_ASC', value: 'Room name A to Z' },
    { key: 'ROOM_NAME_DESC', value: 'Room name Z to A' },
    { key: 'ROOM_CREATED_AT_DESC', value: 'Room creation time' },
  ];
  buildingSorts = [
    { key: 'NAME_ASC', value: 'Name A to Z' },
    { key: 'NAME_DESC', value: 'Name Z to A' },
    { key: 'CREATED_AT_DESC', value: 'Creation time' },
  ];
  floorSorts = [
    { key: 'NAME_ASC', value: 'Name A to Z' },
    { key: 'NAME_DESC', value: 'Name Z to A' },
    { key: 'CREATED_AT_DESC', value: 'Creation time' },
  ];
  roomSorts = [
    { key: 'NAME_ASC', value: 'Name A to Z' },
    { key: 'NAME_DESC', value: 'Name Z to A' },
    { key: 'CREATED_AT_DESC', value: 'Creation time' },
  ];
  // floorSorts = [
  //  { key: 'BUILDING_NAME_ASC', value: 'Building name A to Z' },
  //  { key: 'BUILDING_NAME_DESC', value: 'Building name Z to A' },
  //  { key: 'BUILDING_CREATED_AT_DESC', value: 'Building creation time' },
  //  { key: 'FLOOR_NAME_ASC', value: 'Floor name A to Z' },
  //  { key: 'FLOOR_NAME_DESC', value: 'Floor name Z to A' },
  //  { key: 'FLOOR_CREATED_AT_DESC', value: 'Floor creation time' },
  //  { key: 'ROOM_NAME_ASC', value: 'Room name A to Z' },
  //  { key: 'ROOM_NAME_DESC', value: 'Room name Z to A' },
  //  { key: 'ROOM_CREATED_AT_DESC', value: 'Room creation time' },
  // ];
  // roomSorts = [
  //  { key: 'BUILDING_NAME_ASC', value: 'Building name A to Z' },
  //  { key: 'BUILDING_NAME_DESC', value: 'Building name Z to A' },
  //  { key: 'BUILDING_CREATED_AT_DESC', value: 'Building creation time' },
  //  { key: 'FLOOR_NAME_ASC', value: 'Floor name A to Z' },
  //  { key: 'FLOOR_NAME_DESC', value: 'Floor name Z to A' },
  //  { key: 'FLOOR_CREATED_AT_DESC', value: 'Floor creation time' },
  //  { key: 'ROOM_NAME_ASC', value: 'Room name A to Z' },
  //  { key: 'ROOM_NAME_DESC', value: 'Room name Z to A' },
  //  { key: 'ROOM_CREATED_AT_DESC', value: 'Room creation time' },
  // ];

  roomTypes: Array<{ key: string, value: string, group: string }> = [];

  @ViewChild(SelectContainerComponent) selectUnassignedRoomsContainer: SelectContainerComponent;

  hierarchy: FullRoomHierarchyData;
  hotels: Array<HotelItemData>;
  roomCategories: Array<RoomCategoryGridItemViewModel> = [];

  isHierarchyLoaded$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(false);
  selectedHotel$: BehaviorSubject<HotelItemData> = new BehaviorSubject<HotelItemData>(null);

  roomDetails$: BehaviorSubject<RoomDetailsData> = new BehaviorSubject<RoomDetailsData>(null);
  showCreateNewRoomPopup$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(false);

  unassignedRooms$: BehaviorSubject<UnassignedRoomData[]> = new BehaviorSubject<UnassignedRoomData[]>([]);
  hasUnassignedRooms$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(false);
  areUnassignedRoomsCollapsed$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(true);
  selectedUnassignedRooms$: BehaviorSubject<UnassignedRoomData[]> = new BehaviorSubject<UnassignedRoomData[]>([]);

  //isCreateCentralWarehouseFormShown$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(false);
  //selectedCentralWarehouse$: BehaviorSubject<WarehouseDetailsData> = new BehaviorSubject<WarehouseDetailsData>(null);
  centralWarehouses$: BehaviorSubject<WarehouseData[]> = new BehaviorSubject<WarehouseData[]>([]);
  numberOfCentralWarehouses$: BehaviorSubject<number> = new BehaviorSubject<number>(0);


  buildings$: BehaviorSubject<FullRoomHierarchyBuildingData[]> = new BehaviorSubject<FullRoomHierarchyBuildingData[]>([]);
  floors$: BehaviorSubject<FullRoomHierarchyFloorData[]> = new BehaviorSubject<FullRoomHierarchyFloorData[]>([]);

  numberOfBuildings$: BehaviorSubject<number> = new BehaviorSubject<number>(0);
  numberOfFloors$: BehaviorSubject<number> = new BehaviorSubject<number>(0);
  numberOfRooms$: BehaviorSubject<number> = new BehaviorSubject<number>(0);
  numberOfUnassignedRooms$: BehaviorSubject<number> = new BehaviorSubject<number>(0);

  filterForm: FormGroup;

  hierarchyForm: FormGroup;

  roomForm: FormGroup;
  roomsAssignmentForm: FormGroup;

  private _scrollEvent$: Subject<boolean> = new Subject<boolean>();

  get buildingsFormArray(): FormArray {
    return this.hierarchyForm.controls.buildings as FormArray;
  }

  constructor(
    public loading: LoadingService,
    private _formBuilder: FormBuilder,
    private _router: Router,
    private _route: ActivatedRoute,
    private _roomManagementClient: RoomManagementClient,
    private _areasService: AreasService,
    private _hotelService: HotelService,
    private _roomTypeService: RoomTypeService,
    private _toastr: ToastrService,
    private _exportRoomsClient: ExportRoomsClient,
    private _fileSaver: FileSaverService,
    private httpClient: HttpClient) {
  }
  ngOnDestroy(): void {
    const that = this;
    // window.removeEventListener('scroll', () => { this.updateScroll(that); }, true);
  }

  ngOnInit(): void {
    this.loading.reset();
    this.hotels = this._hotelService.getHotels();
    this.roomCategories = this._route.snapshot.data.roomCategories;

    if (this.roomCategories.length === 0) {
      this._toastr.error('Room cannot be created because there are no room categories defined.');
    }

    this.selectedHotel$.next(this._hotelService.getSelectedHotel());

    this.roomsAssignmentForm = this._formBuilder.group({
      buildingId: [null, Validators.required],
      floorId: [null, Validators.required],
      categoryId: [this.roomCategories.length > 0 ? this.roomCategories[0].id : null, Validators.required],
      typeKey: [null, Validators.required]
    });

    this.filterForm = this._formBuilder.group({
      buildingSortKey: ['CREATED_AT_DESC'],
      floorSortKey: ['CREATED_AT_DESC'],
      roomSortKey: ['CREATED_AT_DESC'],
      keywords: [''],
      hotelId: [this._hotelService.getSelectedHotelId()]
    });

    this.hierarchyForm = this._formBuilder.group({
      buildings: new FormArray([])
    });

    this.filterForm.controls.hotelId.valueChanges.subscribe((hotelId: string) => {
      this.loading.start();
      this._hotelService.selectHotelId(hotelId);
      this._loadHierarchy();

      this.selectedHotel$.next(this._hotelService.getSelectedHotel());
    });

    this.filterForm.valueChanges.pipe(debounceTime(250)).subscribe(formValue => {
      this._loadHierarchy();
    });

    this.roomsAssignmentForm.controls.buildingId.valueChanges.subscribe((buildingId: string) => {
      if (!this.hierarchy || !this.hierarchy.buildings || this.hierarchy.buildings.length === 0) {
        return;
      }

      const building: FullRoomHierarchyBuildingData = this.hierarchy.buildings.find(b => b.id === buildingId);
      const floors: FullRoomHierarchyFloorData[] = building.floors || [];
      this.floors$.next(floors);
      this.roomsAssignmentForm.controls.floorId.setValue(floors.length > 0 ? floors[0].id : null);

      const isAppartment = building.typeKey === 'APPARTMENT';
      this._loadRoomTypes(isAppartment);
      const roomTypeKey: string = this.roomsAssignmentForm.controls.typeKey.value;
      if (this.roomTypes.length > 0 && !this.roomTypes.find(rt => rt.key === roomTypeKey)) {
        this.roomsAssignmentForm.controls.typeKey.setValue(this.roomTypes[0].key);
      }
    });

    this._loadHierarchy();

    window.addEventListener('scroll', this.scroll, true);

    this._scrollEvent$.pipe(
      debounceTime(500)
    ).subscribe(() => {
      if (this.selectUnassignedRoomsContainer) {
        this.selectUnassignedRoomsContainer.update();
      }
    });
  }
  scroll = (event): void => {
    this._scrollEvent$.next(true);
  }

  addBuilding(addToTheBegginngOfArray: boolean = false) {
    const buildingsFormArrayValue = this.buildingsFormArray.value;
    let maxNumber = 0;
    for (const f of buildingsFormArrayValue) {
      if (maxNumber < +(f.ordinalNumber)) { maxNumber = +(f.ordinalNumber); }
    }

    const buildingNumber: number = maxNumber + 1;

    const buildingFormGroup: FormGroup = this._generateBuildingFormGroup(new FullRoomHierarchyBuildingData({
      areaId: null,
      id: null,
      areaName: null,
      floors: [],
      name: 'Building ' + buildingNumber,
      latitude: null,
      longitude: null,
      address: null,
      createdAt: null,
      typeKey: 'HOTEL_HOSTEL',
      ordinalNumber: buildingNumber
    }));

    if (addToTheBegginngOfArray) {
      this.buildingsFormArray.insert(0, buildingFormGroup);
    } else {
      this.buildingsFormArray.push(buildingFormGroup);
    }
  }

  onBuildingAdded(building: FullRoomHierarchyBuildingData) {

    this.numberOfBuildings$.next(this.numberOfBuildings$.value + 1);

    if (!this.hierarchy.buildings) {
      this.hierarchy.buildings = [];
    }

    this.hierarchy.buildings.push(building);

    this._refreshSelectableBuildings();
  }

  onBuildingUpdated(building: FullRoomHierarchyBuildingData) {
    let hierarchyBuilding = this.hierarchy.buildings.find(b => b.id === building.id);
    if (!hierarchyBuilding) {
      return;
    }

    hierarchyBuilding.address = building.address;
    hierarchyBuilding.areaId = building.areaId;
    hierarchyBuilding.areaName = building.areaName;
    hierarchyBuilding.createdAt = building.createdAt;
    hierarchyBuilding.latitude = building.latitude;
    hierarchyBuilding.longitude = building.longitude;
    hierarchyBuilding.name = building.name;
    hierarchyBuilding.ordinalNumber = building.ordinalNumber;
    hierarchyBuilding.typeKey = building.typeKey;

    this._refreshSelectableBuildings();
  }

  onFloorAdded(buildingId: string, floor: FullRoomHierarchyFloorData) {
    this.numberOfFloors$.next(this.numberOfFloors$.value + 1);

    if (!buildingId) {
      return;
    }

    let hierarchyBuilding = this.hierarchy.buildings.find(b => b.id === buildingId);

    if (!hierarchyBuilding) {
      return;
    }

    if (!hierarchyBuilding.floors) {
      hierarchyBuilding.floors = [];
    }
    hierarchyBuilding.floors.push(floor);

    this._refreshSelectableBuildings();
  }

  onFloorUpdated(buildingId: string, floor: FullRoomHierarchyFloorData) {
    if (!buildingId) {
      return;
    }

    let hierarchyBuilding = this.hierarchy.buildings.find(b => b.id === buildingId);

    if (!hierarchyBuilding) {
      return;
    }

    if (!hierarchyBuilding.floors) {
      return;
    }

    let hierarchyFloor = hierarchyBuilding.floors.find(f => f.id === floor.id);
    if (!hierarchyFloor) {
      return;
    }

    hierarchyFloor.createdAt = floor.createdAt;
    hierarchyFloor.name = floor.name;
    hierarchyFloor.number = floor.number;
    hierarchyFloor.ordinalNumber = floor.ordinalNumber;
  }

  removeBuildingForm(formIndex: number): void {
    this.buildingsFormArray.removeAt(formIndex);
  }

  deleteBuilding(formIndex: number): void {
    this.loading.start();

    const buildingFormData = this.buildingsFormArray.at(formIndex).value;
    const buildingId: string = buildingFormData.id;

    this._roomManagementClient.deleteBuilding(new DeleteBuildingCommand({ id: buildingId })).subscribe(
      (response: ProcessResponse) => {
        if (response.hasError) {
          this._toastr.error(response.message);
          return;
        }

        this.buildingsFormArray.removeAt(formIndex);
        this._toastr.success(response.message);

        this.numberOfBuildings$.next(this.numberOfBuildings$.value - 1);
      },
      (error: Error) => { this._toastr.error(error.message); },
      () => { this.loading.stop(); }
    );
  }

  showCreateNewRoomPopup(buildingId: string, floorId: string) {
    const roomDetails = this._createNewRoom(buildingId, floorId);
    const roomForm = this._createRoomForm(roomDetails);

    this.roomDetails$.next(roomDetails);
    this.roomForm = roomForm;
    this.showCreateNewRoomPopup$.next(true);
  }

  hideCreateNewRoomPopup() {
    this.showCreateNewRoomPopup$.next(false);
  }

  onRoomInserted(command: InsertRoomCommand, doContinue: boolean) {
    this.loading.start();

    this._roomManagementClient.insertRoom(command).subscribe(
      (response: ProcessResponseOfInsertRoomResponse) => {
        if (response.hasError) {
          this._toastr.error(response.message);
          return;
        }

        const category = this.roomCategories.find(c => c.id === command.categoryId);
        const roomDetails: RoomDetailsData = new RoomDetailsData({
          id: response.data.id,
          ordinalNumber: response.data.ordinalNumber,
          buildingId: command.buildingId,
          categoryId: command.categoryId,
          categoryName: category ? category.name : '',
          externalId: this.roomDetails$.value.externalId,
          floorId: command.floorId,
          floorSectionName: command.floorSectionName,
          floorSubSectionName: command.floorSubSectionName,
          name: command.name,
          typeKey: command.typeKey,
          beds: command.beds.map(b => new RoomDetailsBed({ id: b.id, externalId: null, name: b.name })),
        });

        const buildingFormGroup: FormGroup = <FormGroup>this.buildingsFormArray.controls.find((c: FormGroup) => c.controls.id.value === command.buildingId);
        const floorFormGroup: FormGroup = <FormGroup>(buildingFormGroup.controls.floors as FormArray).controls.find(((f: FormGroup) => f.controls.id.value === command.floorId));
        (floorFormGroup.controls.rooms as FormArray).push(this._generateRoomListItemFormGroup(roomDetails));

        if (doContinue) {
          roomDetails.id = null;
        } else {
          this.hideCreateNewRoomPopup();
        }

        this.roomDetails$.next(roomDetails);
        this.numberOfRooms$.next(this.numberOfRooms$.value + 1);

        this._toastr.success(response.message);
      },
      (error: Error) => {
        this._toastr.error(error.message);
      },
      () => {
        this.loading.stop();
      },
    );
  }

  onRoomUpdated(command: UpdateRoomCommand) {
  }

  onRoomCancelled() {
    this.hideCreateNewRoomPopup();
  }

  onRoomAdded(data: { floorId: string, buildingId: string }) {
    this.showCreateNewRoomPopup(data.buildingId, data.floorId);
  }

  toggleUnassignedRoomsCollapse() {
    this.areUnassignedRoomsCollapsed$.next(!this.areUnassignedRoomsCollapsed$.value);
  }

  unassignedRoomsSelected(unassignedRooms: UnassignedRoomData[]) {
    this.selectedUnassignedRooms$.next(unassignedRooms);
  }

  cancelRoomAssignment() {
    this.selectUnassignedRoomsContainer.clearSelection();
  }

  saveRoomAssignments() {
    if (this.roomsAssignmentForm.invalid) {
      this._toastr.error('You have to fix room assignment form errors before you can continue.');
      this.roomsAssignmentForm.markAllAsTouched();
      this.roomsAssignmentForm.markAsDirty({ onlySelf: false });
      return;
    }

    const rooms = this.selectedUnassignedRooms$.value;

    if (!rooms || rooms.length === 0) {
      this._toastr.error('No rooms selected for assignment.');
      return;
    }

    this.loading.start();

    const formValues = this.roomsAssignmentForm.getRawValue();
    const request: AssignRoomsToFloorCommand = new AssignRoomsToFloorCommand({
      buildingId: formValues.buildingId,
      categoryId: formValues.categoryId,
      floorId: formValues.floorId,
      roomIds: rooms.map(r => r.id),
      roomTypeKey: formValues.typeKey
    });

    this._roomManagementClient.assignRoomsToFloor(request).subscribe(
      (response: ProcessResponseOfRoomAssignmentResultOf) => {
        if (response.hasError) {
          this._toastr.error(response.message);
          return;
        }

        this._updateRoomAssignmentOnSuccess(request.buildingId, request.floorId, request.categoryId, request.roomTypeKey, response.data);
        this.cancelRoomAssignment();

        this._toastr.success(response.message);
      },
      (error: Error) => { this._toastr.error(error.message); },
      () => { this.loading.stop(); }
    );
  }

  goToWarehouseDetails(warehouseId: string) {
    this._router.navigate(['/warehouses', 'warehouse-details', warehouseId]);
  }

  private _updateRoomAssignmentOnSuccess(buildingId: string, floorId: string, categoryId: string, roomTypeKey: string, assignmentResults: RoomAssignmentResult[]) {
    const unassignedRooms = [...this.unassignedRooms$.value];
    // let buildingFormGroup: FormGroup = this.buildingsFormArray.controls.find((c: FormGroup) => { c.controls.id.value === buildingId }) as FormGroup;
    const buildingsFormGroupsArray = (this.buildingsFormArray.controls as FormGroup[]);
    const buildingFormGroup: FormGroup = buildingsFormGroupsArray.find(c => c.controls.id.value === buildingId);
    const floorsFormGroupsArray = ((buildingFormGroup.controls.floors as FormArray).controls as FormGroup[]);
    const floorFormGroup: FormGroup = floorsFormGroupsArray.find(c => c.controls.id.value === floorId);
    const building = this.hierarchy.buildings.find(b => b.id === buildingId);

    let numberOfSuccessfulUpdates = 0;
    for (const result of assignmentResults) {
      if (result.isSuccess) {
        const roomIndex = unassignedRooms.findIndex(r => r.id === result.roomId);
        const removedRoom = unassignedRooms.splice(roomIndex, 1)[0];

        (floorFormGroup.controls.rooms as FormArray).push(this._generateRoomListItemFormGroup(new RoomDetailsData({
          id: removedRoom.id,
          ordinalNumber: 0,
          buildingId: buildingId,
          categoryId: categoryId,
          categoryName: this.roomCategories.find(c => c.id === categoryId).name,
          externalId: removedRoom.externalId,
          floorId: floorId,
          floorSectionName: null,
          floorSubSectionName: null,
          name: removedRoom.name,
          typeKey: building.typeKey === 'HOTEL_HOSTEL' ? roomTypeKey : 'APPARTMENT',
          beds: (removedRoom.beds || []).map(b => new RoomDetailsBed({ id: b.id, externalId: b.externalId, name: b.name })),
        })));

        numberOfSuccessfulUpdates++;
      } else {
        this._toastr.warning(result.message);
      }
    }

    this.unassignedRooms$.next(unassignedRooms);
    this.numberOfUnassignedRooms$.next(unassignedRooms.length);
    this.numberOfRooms$.next(this.numberOfRooms$.value + numberOfSuccessfulUpdates);
    this.hasUnassignedRooms$.next(unassignedRooms.length > 0);
  }

  private _createNewRoom(buildingId: string, floorId: string): RoomDetailsData {
    const hierarchy = this.hierarchyForm.getRawValue();
    const building = hierarchy.buildings.find(b => b.id === buildingId);
    const roomTypes = this._roomTypeService.getRoomTypes();
    const roomTypeKey = roomTypes.filter(rt => rt.group === building.typeKey)[0].key;

    const categoryId = this.roomCategories[0].id;

    return new RoomDetailsData({
      id: null,
      ordinalNumber: 1,
      buildingId: buildingId,
      categoryId: categoryId,
      categoryName: null,
      externalId: null,
      floorId: floorId,
      floorSectionName: null,
      floorSubSectionName: null,
      name: null,
      typeKey: roomTypeKey
    });
  }

  private _createRoomForm(room: RoomDetailsData): FormGroup {
    return this._formBuilder.group({
      name: [room.name, [Validators.required]],
      categoryId: [room.categoryId, [Validators.required]],
      floorSectionName: [room.floorSectionName],
      floorSubSectionName: [room.floorSubSectionName],
      typeKey: [room.typeKey, [Validators.required]],
    });
  }

  private _generateRoomListItemFormGroup(room: RoomDetailsData): FormGroup {
    let bedsFormGroups = (room.beds || []).map(b => this._formBuilder.group({ id: b.id, name: b.name }));

    return this._formBuilder.group({
      id: room.id,
      name: room.name,
      description: "",
      label: "",
      typeKey: room.typeKey,
      categoryName: room.categoryName,
      section: room.floorSectionName,
      subSection: room.floorSubSectionName,
      bedsFormArray: this._formBuilder.array(bedsFormGroups),
    });
  }

  private _loadHierarchy() {
    this._roomManagementClient.getFullRoomHierarchy(new GetFullRoomHierarchyQuery({
      keywords: this.filterForm.controls.keywords.value,
      hotelId: this.filterForm.controls.hotelId.value,
      includeCentralWarehouses: true,
      includeHotelWarehouses: true,
    })).subscribe((hierarchy: FullRoomHierarchyData) => {
      this.hierarchy = hierarchy;
      this._areasService.setAreas(this.hierarchy.allAreas);
      this._fillHierarchyForm(hierarchy);
      this.isHierarchyLoaded$.next(true);


      const unassignedRoomsRequest: GetUnassignedRoomsQuery = new GetUnassignedRoomsQuery({
        skip: 0,
        take: 0,
        hotelId: this.filterForm.controls.hotelId.value,
        sortKey: ''
      });

      const building: FullRoomHierarchyBuildingData = this.hierarchy.buildings.length > 0 ? this.hierarchy.buildings[0] : null;
      const floor: FullRoomHierarchyFloorData = building && building.floors.length > 0 ? building.floors[0] : null;
      this._refreshSelectableBuildings();
      //this.buildings$.next(this.hierarchy.buildings || []);
      this.floors$.next(building ? building.floors : []);

      this.centralWarehouses$.next(this.hierarchy.centralWarehouses);
      this.numberOfCentralWarehouses$.next(this.hierarchy.centralWarehouses.length);

      if (building) {
        this.roomsAssignmentForm.controls.buildingId.setValue(building.id);
        this.roomsAssignmentForm.controls.buildingId.updateValueAndValidity();
      }
      if (floor) {
        this.roomsAssignmentForm.controls.floorId.setValue(floor.id);
        this.roomsAssignmentForm.controls.floorId.updateValueAndValidity();
      }

      this._roomManagementClient.getPageOfUnassignedRooms(unassignedRoomsRequest).subscribe((response: PageOfOfUnassignedRoomData) => {
        this.unassignedRooms$.next(response.items);
        this.hasUnassignedRooms$.next(response.totalNumberOfItems > 0);

        this.numberOfUnassignedRooms$.next(response.totalNumberOfItems);
      });
    },
    (error: Error) => { },
    () => { this.loading.stop(); });
  }

  private _refreshSelectableBuildings() {
    if (this.hierarchy && this.hierarchy.buildings) {
      this.buildings$.next(this.hierarchy.buildings.filter(b => b.floors && b.floors.length > 0));
    }
    else {
      this.buildings$.next([]);
    }
  }

  private _fillHierarchyForm(data: FullRoomHierarchyData): void {
    let hierarchy = data;
    if (!hierarchy) {
      hierarchy = new FullRoomHierarchyData({ buildings: [], allAreas: [] });
      this.numberOfBuildings$.next(0);
      this.numberOfFloors$.next(0);
      this.numberOfRooms$.next(0);
    } else {
      this._updateTotalNumbers();
    }

    this.hierarchyForm.controls.buildings = this._generateBuildingsFormArray(hierarchy);
  }

  private _updateTotalNumbers() {
    let numberOfBuildings = 0;
    let numberOfFloors = 0;
    let numberOfRooms = 0;

    numberOfBuildings = this.hierarchy.buildings.length;
    for (const building of this.hierarchy.buildings) {
      numberOfFloors += building.floors.length;

      for (const floor of building.floors) {
        numberOfRooms += floor.rooms.length;
      }
    }

    this.numberOfBuildings$.next(numberOfBuildings);
    this.numberOfFloors$.next(numberOfFloors);
    this.numberOfRooms$.next(numberOfRooms);
  }

  private _generateBuildingsFormArray(data: FullRoomHierarchyData): FormArray {
    const buildings: Array<FormGroup> = [];

    for (const building of data.buildings) {
      buildings.push(this._generateBuildingFormGroup(building));
    }

    return this._formBuilder.array(buildings);
  }

  private _generateFloorsFormArray(building: FullRoomHierarchyBuildingData): FormArray {
    const floors: Array<FormGroup> = [];

    for (const floor of building.floors) {
      floors.push(this._formBuilder.group({
        id: floor.id,
        name: [floor.name, Validators.required],
        number: [floor.number, Validators.required],
        ordinalNumber: [floor.ordinalNumber],
        rooms: this._generateRoomsFormArray(floor),
        warehouses: this._generateWarehousesFormArray(floor),
        buildingId: building.id
      }));
    }

    return this._formBuilder.array(floors);
  }

  private _generateRoomsFormArray(floor: FullRoomHierarchyFloorData): FormArray {
    const rooms: Array<FormGroup> = [];

    for (const room of floor.rooms) {
      rooms.push(this._generateRoomListItemFormGroup(room));
    }

    return this._formBuilder.array(rooms);
  }

  private _generateWarehousesFormArray(floor: FullRoomHierarchyFloorData): FormArray {
    const warehouses: Array<FormGroup> = [];

    for (const warehouse of floor.warehouses) {
      warehouses.push(this._formBuilder.group({
        id: warehouse.id,
        name: warehouse.name,
      }));
    }

    return this._formBuilder.array(warehouses);
  }

  private _generateBuildingFormGroup(building: FullRoomHierarchyBuildingData) {
    return this._formBuilder.group({
      id: building.id,
      name: [building.name, Validators.required],
      area: this._findArea(building.areaId),
      address: building.address,
      latitude: building.latitude,
      longitude: building.longitude,
      ordinalNumber: building.ordinalNumber,
      typeKey: building.typeKey,
      floors: this._generateFloorsFormArray(building)
    });
  }

  private _findArea(areaId: string): FullRoomHierarchyAreaData {
    if (areaId) {
      return this.hierarchy.allAreas.find(a => a.id === areaId);
    }
    return null;
  }

  private _loadRoomTypes(isApartment: boolean) {
    const roomTypes = this._roomTypeService.getRoomTypes();
    if (isApartment) {
      this.roomTypes = roomTypes.filter(rt => rt.group === 'APPARTMENT');
    } else {
      this.roomTypes = roomTypes.filter(rt => rt.group === 'HOTEL_HOSTEL');
    }
  }

  openRoomImportPreview() {
    this._router.navigate(['rooms-management','room-import-preview']);
  }

  initiateRoomExport() {
    this._exportRoomsClient.exportRoomsFromDatabase().subscribe((response: FileResponse) => {
      this._fileSaver.save(response.data, response.fileName);
    });
  }
}
