import { Component, EventEmitter, Input, OnDestroy, OnInit, Output } from '@angular/core';
import { FormArray, FormBuilder, FormControl, FormGroup, Validators } from '@angular/forms';
import { ToastrService } from 'ngx-toastr';
import { BehaviorSubject, Observable, Subscription } from 'rxjs';
import { map, startWith } from 'rxjs/operators';
import { BalancedTaskOptions, SaveMonthlyRecurringTaskItemOptions, SaveWeeklyRecurringTaskItemOptions, CancelTasksByConfigurationCommand, DailyRecurringTaskOptions, EnumData, EventTaskOptions, ExtendedTaskActionData, GetTaskConfigurationCancelPreviewQuery, GetTaskConfigurationSavePreviewQuery, InsertTaskConfigurationCommand, MonthlyRecurringTaskItemOptions, MonthlyRecurringTaskOptions, ProcessResponse, ProcessResponseOfInsertTaskConfigurationResult, ProcessResponseOfUpdateTaskConfigurationResult, SaveBalancedTaskOptions, SaveDailyRecurringTaskOptions, SaveEventTaskOptions, SaveMonthlyRecurringTaskOptions, SaveSingleTaskOptions, SaveSpecificTimesRecurringTaskOptions, SaveTaskFileData, SaveTaskWhatData, SaveWeeklyRecurringTaskOptions, SingleTaskOptions, SpecificTimesRecurringTaskOptions, TaskActionData, TaskConfigurationCancelPreview, TaskConfigurationDetailsData, TaskConfigurationSavePreview, TaskFileData, TasksManagementClient, TaskWhatData, TaskWhereData, TaskWhoData, UpdateTaskConfigurationCommand, WeeklyRecurringTaskItemOptions, WeeklyRecurringTaskOptions, RecurringEveryTaskOptions, SaveRecurringEveryTaskOptions, TaskGridItem, GetPageOfTasksForGridQuery, PageOfOfTaskGridItem, AvailableUserGroup } from '../../core/autogenerated-clients/api-client';
import { LoadingService } from '../../core/services/loading.service';
import { FileDetails, FilesChangedData } from '../../shared/components/file-upload/file-upload.component';
import { DateHelper } from '../../shared/helpers/date.helper';
import moment, { Moment } from 'moment';
import { MomentDateHelper } from '../../shared/helpers/moment-date.helper';
import { AutocompleteSingleSelectRequiredValidator, SingleSelectWhereRequiredValidator } from '../../core/validators/autocomplete-single-select-required.validator';
import { CustomDateAdapter } from 'src/app/core/custom-date-adapter';
import { DateAdapter, MAT_DATE_FORMATS, MAT_DATE_LOCALE } from '@angular/material/core';
import { MAT_MOMENT_DATE_ADAPTER_OPTIONS } from '@angular/material-moment-adapter';
import { count } from 'console';
import { TasksRefreshService } from '../tasks-refresh.service';
import { TaskSelectedEventArgs } from '../task-configurations-grid-item/task-selected-event-args';
export const MY_FORMATS = {
  parse: {
    dateInput: 'LL',
  },
  display: {
    dateInput: 'dddd[,] Do MMM YYYY',
    monthYearLabel: 'MMM YYYY',
    dateA11yLabel: 'LL',
    monthYearA11yLabel: 'MMMM YYYY',
  },
};
@Component({
  selector: 'app-tasks-grouped-grid',
  templateUrl: './tasks-grouped-grid.component.html',
  providers: [
    { provide: DateAdapter, useClass: CustomDateAdapter, deps: [MAT_DATE_LOCALE] },
    { provide: MAT_DATE_FORMATS, useValue: MY_FORMATS },
    /*{ provide: MAT_DATE_FORMATS, useValue: MAT_MOMENT_DATE_FORMATS },*/
    { provide: MAT_MOMENT_DATE_ADAPTER_OPTIONS, useValue: { useUtc: true } },
  ],
})
export class TasksGroupedGridComponent implements OnInit, OnDestroy {
  //@Input() statuses: { key: string,value: string}[] = [];
  //@Input() allWheres: TaskWhereData[] = [];
  //@Input() allActions: TaskActionData[] = [];

  @Input() availableUserSubGroups: AvailableUserGroup[] = [];

  @Input() selectedTaskId: string = null;
  @Input() onlyMyTasks: boolean = false;
  @Input() taskConfigurationId: string = null;
  @Input() userGroupId: string = null;
  @Input() userSubGroupId: string = null;

  @Output() taskSelected: EventEmitter<TaskSelectedEventArgs> = new EventEmitter<TaskSelectedEventArgs>();

  todaysTasks: TaskGridItem[] = [];
  filteredTodaysTasks$: BehaviorSubject<TaskGridItem[]> = new BehaviorSubject<TaskGridItem[]>([]);
  todaysTotalTasks$: BehaviorSubject<number> = new BehaviorSubject<number>(0);

  recurringTasks: TaskGridItem[] = [];
  filteredRecurringTasks$: BehaviorSubject<TaskGridItem[]> = new BehaviorSubject<TaskGridItem[]>([]);
  recurringTotalTasks$: BehaviorSubject<number> = new BehaviorSubject<number>(0);

  isMyTasksCalendarDisplayed$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(false);
  numberOfPendingTasks$: BehaviorSubject<number> = new BehaviorSubject<number>(0);
  numberOfWaitingTasks$: BehaviorSubject<number> = new BehaviorSubject<number>(0);
  numberOfPausedTasks$: BehaviorSubject<number> = new BehaviorSubject<number>(0);
  numberOfStartedTasks$: BehaviorSubject<number> = new BehaviorSubject<number>(0);
  numberOfFinishedTasks$: BehaviorSubject<number> = new BehaviorSubject<number>(0);
  numberOfVerifiedTasks$: BehaviorSubject<number> = new BehaviorSubject<number>(0);
  numberOfOnTimeTasks$: BehaviorSubject<number> = new BehaviorSubject<number>(0);
  numberOfLateTasks$: BehaviorSubject<number> = new BehaviorSubject<number>(0);

  numberOfTodaysTasks$: BehaviorSubject<number> = new BehaviorSubject<number>(0);
  numberOfTodaysLateTasks$: BehaviorSubject<number> = new BehaviorSubject<number>(0);

  numberOfRecurringTasks$: BehaviorSubject<number> = new BehaviorSubject<number>(0);
  numberOfRecurringLateTasks$: BehaviorSubject<number> = new BehaviorSubject<number>(0);

  filterForm: FormGroup;

  filteredTaskActions$: Observable<TaskActionData[]>;

  statuses: { key: string, value: string }[] = [
    //{ key: 'ANY', value: 'Any status' },
    { key: 'ALL_UNFINISHED', value: 'All unfinished' },
    { key: 'ALL_FINISHED', value: 'All finished' },
    { key: 'PENDING', value: 'Pending' },
    { key: 'WAITING', value: 'Waiting' },
    { key: 'STARTED', value: 'Started' },
    { key: 'FINISHED', value: 'Finished' },
    { key: 'PAUSED', value: 'Paused' },
    { key: 'VERIFIED', value: 'Verified' },
    { key: 'CANCELLED', value: 'Cancelled' },
    { key: 'CLAIMED', value: 'Claimed' },
    { key: 'CLAIMED_BY_SOMEONE_ELSE', value: 'Claimed by someone else' },
    { key: 'LATE', value: 'Late' },
    { key: 'ON_TIME', value: 'On time' },
  ];

  finishedStatuses: any = {
    FINISHED: true,
    VERIFIED: true,
    CANCELLED: true,
    CLAIMED_BY_SOMEONE_ELSE: true,
  };
  unfinishedStatuses: any = {
    PENDING: true,
    WAITING: true,
    STARTED: true,
    PAUSED: true,
    CLAIMED: true,
  };

  whereFilterValues: { key: string, value: string, description: string, typeKey: string }[] = [];
  userFilterValues: { key: string, value: string }[] = [];
  actionFilterValues: { key: string, action: string, asset: string }[] = [];

  get userSubGroupsFormArray(): FormArray {
    return this.filterForm.get("userSubGroupsFormArray") as FormArray;
  }

  private _refreshSubscription: Subscription;
  private _taskStatusChangedSubscription: Subscription;

  constructor(private _formBuilder: FormBuilder, private _toastr: ToastrService, private _taskManagementClient: TasksManagementClient, private loading: LoadingService, private _refreshTasksGridsService: TasksRefreshService) {
  }

  ngOnInit(): void {
    this.filterForm = this._formBuilder.group({
      isGuestRequest: [false],
      isHighPriority: [false],
      userId: [null],
      whereId: [null],
      statusKey: ["ANY"],
      actionKey: [null],
      userSubGroupId: [null],
      userSubGroupsFormArray: this._formBuilder.array(
        this.availableUserSubGroups.map(sg => {
          return this._formBuilder.group({
            subGroupId: [sg.id],
            subGroupName: [sg.name],
            isSelected: [false],
          });
        })
      ),
    });

    this.filterForm.valueChanges.subscribe(() => {
      this._filterTasks();
    });

    this._refreshSubscription = this._refreshTasksGridsService.refreshGrids$.subscribe(() => {
      this._loadTasks();
    });

    this._taskStatusChangedSubscription = this._refreshTasksGridsService.taskStatus$.subscribe((args: { taskId: string, taskConfigurationId: string, statusKey: string }) => {
      this._updateTaskStatus(args);
    });
  }

  ngOnDestroy() {
    if (this._refreshSubscription) {
      this._refreshSubscription.unsubscribe();
      this._refreshSubscription = null;
    }
    if (this._taskStatusChangedSubscription) {
      this._taskStatusChangedSubscription.unsubscribe();
      this._taskStatusChangedSubscription = null;
    }
  }

  toggleCalendar(): void {
    this.isMyTasksCalendarDisplayed$.next(!this.isMyTasksCalendarDisplayed$.value);
  }

  toggleSubGroup() {

  }

  selectTask(taskId: string, taskConfigurationId: string) {
    this.taskSelected.next({ taskId: taskId, taskConfigurationId: taskConfigurationId });
  }

  private _updateTaskStatus(args: { taskId: string, taskConfigurationId: string, statusKey: string }) {
    let tTasks = [...this.todaysTasks];

    let found: boolean = false;
    for (let t of tTasks) {
      if (t.id === args.taskId) {
        t.statusKey = args.statusKey;
        t.statusDescription = args.statusKey;
        found = true;
        break;
      }
    }

    if (found) {
      this.todaysTasks = tTasks;
      this._filterTasks();
      return;
    }

    let rTasks = [...this.recurringTasks];
    found = false;
    for (let t of rTasks) {
      if (t.id === args.taskId) {
        t.statusKey = args.statusKey;
        t.statusDescription = args.statusKey;
        found = true;
        break;
      }
    }

    if (found) {
      this.recurringTasks = rTasks;
      this._filterTasks();
      return;
    }
  }

  private _loadTasks() {
    this.loading.start();
    let now: Moment = moment(new Date());
    let query: GetPageOfTasksForGridQuery = new GetPageOfTasksForGridQuery({
      skip: null,
      take: null,
      sortKey: "CREATED_AT_DESC",
      taskConfigurationId: this.taskConfigurationId,
      onlyMyTasks: this.onlyMyTasks,
      userGroupId: this.userGroupId,
      userSubGroupId: this.userSubGroupId,
      loadOnlyCurrentTasks: true,
      loadMissedUnfinishedTasks: true,
      currentDateString: now.format("YYYY-MM-DD") + " 00:00",
    });

    this._taskManagementClient.getPageOfTasksForGrid(query).subscribe(
      (response: PageOfOfTaskGridItem) => {
        let recurring: TaskGridItem[] = [];
        let todays: TaskGridItem[] = [];
        let todaysImportant: TaskGridItem[] = [];

        for (let t of response.items) {
          if (t.typeKey === "RECURRING") {
            recurring.push(t);
          }
          else {
            if (t.isGuestRequest || t.priorityKey === "HIGH") {
              todaysImportant.push(t);
            }
            else {
              todays.push(t);
            }
          }
        }

        this.todaysTasks = [...todaysImportant, ...todays];
        this.todaysTotalTasks$.next(this.todaysTasks.length);

        this.recurringTasks = recurring;
        this.recurringTotalTasks$.next(this.recurringTasks.length);

        this._loadFilterValues();

        this._filterTasks();
      },
      (error: Error) => { this._toastr.error(error.message); this.loading.stop(); },
      () => { this.loading.stop(); }
    );
  }

  private _loadFilterValues(): void {
    let uniqueWheres: any = {};
    let uniqueUsers: any = {};
    let wheres: { key: string, value: string, description: string, typeKey: string }[] = [];
    let users: { key: string, value: string }[] = [];
    let actions: { key: string, asset: string, action: string }[] = [];

    let uniqueAssetActions: any = {};

    for (let t of [...this.todaysTasks, ...this.recurringTasks]) {

      if (!uniqueWheres[t.whereId]) {
        uniqueWheres[t.whereId] = true;

        wheres.push({
          key: t.whereId,
          value: t.where,
          description: t.whereDescription,
          typeKey: t.whereTypeKey,
        });
      }

      if (!uniqueUsers[t.userId]) {
        uniqueUsers[t.userId] = true;

        users.push({
          key: t.userId,
          value: t.userFullName,
        });
      }

      for (let action of t.actions) {
        let actionKey: string = action.actionName + "|" + action.assetName;
        if (!uniqueAssetActions[actionKey]) {
          uniqueAssetActions[actionKey] = true;

          actions.push({
            key: actionKey,
            action: action.actionName,
            asset: action.assetName,
          });
        }
      }
    }

    this.userFilterValues = users;
    this.whereFilterValues = wheres;
    this.actionFilterValues = actions;
  }

  private _filterTasks() {
    let filterValues = this.filterForm.getRawValue();

    let tTasks = [...this.todaysTasks];
    let rTasks = [...this.recurringTasks];

    if (filterValues.isGuestRequest) {
      tTasks = tTasks.filter(t => t.isGuestRequest);
      rTasks = rTasks.filter(t => t.isGuestRequest);
    }

    if (filterValues.isHighPriority) {
      tTasks = tTasks.filter(t => t.priorityKey === "HIGH");
      rTasks = rTasks.filter(t => t.priorityKey === "HIGH");
    }

    if (filterValues.userId) {
      tTasks = tTasks.filter(t => t.userId === filterValues.userId);
      rTasks = rTasks.filter(t => t.userId === filterValues.userId);
    }

    if (filterValues.whereId) {
      tTasks = tTasks.filter(t => t.whereId === filterValues.whereId);
      rTasks = rTasks.filter(t => t.whereId === filterValues.whereId);
    }

    if (filterValues.actionKey) {

      tTasks = tTasks.filter(t => t.actions.filter(ta => filterValues.actionKey === (ta.actionName + "|" + ta.assetName)).length > 0);
      rTasks = rTasks.filter(t => t.actions.filter(ta => filterValues.actionKey === (ta.actionName + "|" + ta.assetName)).length > 0);
    }

    if (filterValues.statusKey && filterValues.statusKey !== "ANY") {
      //let date: Date = new Date();
      //let now: Moment = moment(new Date(date.getFullYear(), date.getMonth(), date.getDay(), 0, 0, 0, 0));
      let todayKey: string = moment(new Date()).format("YYYY-MM-DD");
      //if (t.startsAt.format("YYYY-MM-DD") === todayKey) {
      //  counts.onTime++;
      //}
      //else {
      //  counts.late++;
      //}
      if (filterValues.statusKey === "LATE") {
        tTasks = tTasks.filter(t => t.startsAt.format("YYYY-MM-DD") !== todayKey);
        rTasks = rTasks.filter(t => t.startsAt.format("YYYY-MM-DD") !== todayKey);
      }
      else if (filterValues.statusKey === "ON_TIME") {
        tTasks = tTasks.filter(t => t.startsAt.format("YYYY-MM-DD") === todayKey);
        rTasks = rTasks.filter(t => t.startsAt.format("YYYY-MM-DD") === todayKey);
      }
      else if (filterValues.statusKey === "ALL_UNFINISHED") {
        tTasks = tTasks.filter(t => this.unfinishedStatuses[t.statusKey]);
        rTasks = rTasks.filter(t => this.unfinishedStatuses[t.statusKey]);
      }
      else if (filterValues.statusKey === "ALL_FINISHED") {
        tTasks = tTasks.filter(t => this.finishedStatuses[t.statusKey]);
        rTasks = rTasks.filter(t => this.finishedStatuses[t.statusKey]);
      }
      else {
        tTasks = tTasks.filter(t => t.statusKey === filterValues.statusKey);
        rTasks = rTasks.filter(t => t.statusKey === filterValues.statusKey);
      }
    }

    if (!this.onlyMyTasks) {
      if (filterValues.userSubGroupsFormArray.length > 0) {
        let userSubGroupIds: string[] = filterValues.userSubGroupsFormArray.filter(usg => usg.isSelected).map(usg => usg.subGroupId);
        if (userSubGroupIds.length > 0) {
          tTasks = tTasks.filter(t => userSubGroupIds.indexOf(t.userSubGroupId) >= 0);
          rTasks = rTasks.filter(t => userSubGroupIds.indexOf(t.userSubGroupId) >= 0)
        }
      }
    }

    this.filteredTodaysTasks$.next(tTasks);
    this.filteredRecurringTasks$.next(rTasks);

    this._setTotalCounts();
  }

  private _setTotalCounts() {
    let counts = {
      pending: 0,
      waiting: 0,
      started: 0,
      paused: 0,
      finished: 0,
      verified: 0,
      cancelled: 0,
      claimed: 0,
      rejected: 0,
      claimedBySomeoneElse: 0,
      unknown: 0,
      late: 0,
      onTime: 0,
    };

    let items = [...this.filteredTodaysTasks$.value, ...this.filteredRecurringTasks$.value];

    for (let t of items) {
      switch (t.statusKey) {
        case "PENDING":
          counts.pending++;
          break;
        case "WAITING":
          counts.waiting++;
          break;
        case "STARTED":
          counts.started++;
          break;
        case "PAUSED":
          counts.paused++;
          break;
        case "FINISHED":
          counts.finished++;
          break;
        case "VERIFIED":
          counts.verified++;
          break;
        case "CANCELLED":
          counts.cancelled++;
          break;
        case "CLAIMED":
          counts.claimed++;
          break;
        case "REJECTED":
          counts.rejected++;
          break;
        case "CLAIMED_BY_SOMEONE_ELSE":
          counts.claimedBySomeoneElse++;
          break;
        case "UNKNOWN":
        default:
          counts.unknown++;
          break;
      }
      let todayKey: string = moment(new Date()).format("YYYY-MM-DD");
      if (t.startsAt.format("YYYY-MM-DD") === todayKey) {
        counts.onTime++;
      }
      else {
        counts.late++;
      }

      this.numberOfPendingTasks$.next(counts.pending);
      this.numberOfWaitingTasks$.next(counts.waiting);
      this.numberOfStartedTasks$.next(counts.started);
      this.numberOfPausedTasks$.next(counts.paused);
      this.numberOfFinishedTasks$.next(counts.finished);
      this.numberOfVerifiedTasks$.next(counts.verified);
      this.numberOfLateTasks$.next(counts.late);
      this.numberOfOnTimeTasks$.next(counts.onTime);
    }
  }
}
