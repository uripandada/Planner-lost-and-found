import { Component, ElementRef, EventEmitter, forwardRef, Input, OnChanges, OnInit, Output, SimpleChanges, ViewChild } from '@angular/core';
import { AbstractControl, ControlValueAccessor, FormControl, NG_VALIDATORS, NG_VALUE_ACCESSOR, ValidationErrors, Validator } from '@angular/forms';
import { ToastrService } from 'ngx-toastr';
import { BehaviorSubject, Observable } from 'rxjs';
import { map, startWith } from 'rxjs/operators';
import { TaskWhoData } from '../../core/autogenerated-clients/api-client';
import { LoadingService } from '../../core/services/loading.service';

@Component({
  selector: 'app-who-multiselect',
  templateUrl: './who-multiselect.component.html',
  styleUrls: ['./who-multiselect.component.scss'],
  providers: [
    {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => WhoMultiselectComponent),
      multi: true
    },
    {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => WhoMultiselectComponent),
      multi: true
    }
  ]
})
export class WhoMultiselectComponent implements OnInit, OnChanges, ControlValueAccessor, Validator {
  @ViewChild('multiselectInputOne', { static: true }) multiselectInput: ElementRef;
  @Input() allWhos: Array<TaskWhoData> = [];
  @Input() selectedWhos: Array<TaskWhoData> = [];
  @Input() isRequired: boolean = false;
  @Input() showMiniTags: boolean = false;
  @Input() placeholderText: string = "Who...";

  selectedWhoControl: FormControl;
  filteredWhos$: Observable<TaskWhoData[]>;

  selectedWhos$: BehaviorSubject<TaskWhoData[]> = new BehaviorSubject<TaskWhoData[]>([]);
  isValid$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(true);

  constructor(private _toastr: ToastrService, public loading: LoadingService) { }

  ngOnInit(): void {
    this.selectedWhos$.next(this.selectedWhos);
    this.value = this.selectedWhos;

    this.selectedWhoControl = new FormControl("");

    this.filteredWhos$ = this.selectedWhoControl.valueChanges
      .pipe(
        startWith(''),
        map(value => {
          if (typeof (value) === "string") {
            return this._filterWhos(value);
          }
          else {
            this.addSelectedWho(value);
            return this.allWhos;
          }
        })
    );
  }

  public displayWho(who: TaskWhoData): string {
    return '';
  }

  public blurAutocomplete() {
    this.multiselectInput.nativeElement.blur();
  }

  private _filterWhos(value: string): TaskWhoData[] {
    let valueParam: string = value.toLowerCase();
    return this.allWhos.filter(a => a.referenceName.toLowerCase().indexOf(valueParam) > -1);
  }

  ngOnChanges(changes: SimpleChanges): void {
  }

  private _whos: TaskWhoData[] = [];
  isDisabled: boolean = false;
  onChange = (_: any) => { }; // Called on a value change
  onTouched = () => { }; // Called if you care if the form was touched
  onValidatorChange = () => { }; // Called on a validator change or re-validation;

  get value(): TaskWhoData[] {
    return this._whos;
  }

  set value(newValue: TaskWhoData[]) {
    this._whos = newValue;
    this.onChange(this._whos);
    this.onValidatorChange();
    this.selectedWhos$.next(newValue);
  }

  addSelectedWho(who: TaskWhoData): void {
    let whoIndex: number = this._whos.findIndex(w => w.typeKey === who.typeKey && w.referenceId === who.referenceId);

    if (whoIndex > -1) {
      this._whos.splice(whoIndex, 1, who);
    }
    else {
      this._whos.push(who);
    }

    this.value = this._whos;
  }

  removeSelectedWho(who: TaskWhoData): void {
    let whoIndex: number = this._whos.findIndex(w => w.typeKey === who.typeKey && w.referenceId === who.referenceId);
    this._whos.splice(whoIndex, 1);
    this.value = this._whos;
  }

  // Writes a new value to the element -> from FormControl to the DOM
  // When FormControl is instantiated, setValue or patchValue
  writeValue(obj: any): void {
    this._whos = obj;
  }

  registerOnChange(fn: any): void {
    this.onChange = fn;
  }

  registerOnTouched(fn: any): void {
    this.onTouched = fn;
  }

  registerOnValidatorChange?(fn: () => void): void {
    this.onValidatorChange = fn;
  }

  setDisabledState?(isDisabled: boolean): void {
    this.isDisabled = isDisabled;
  }

  validate(control: AbstractControl): ValidationErrors | null {
    let valid = true;

    if (!!this._whos && this._whos.length > 0) {
      this._whos.forEach(yourEntry => valid = valid && !!yourEntry); // Perform here your single item validation
    }
    else {
      valid = !this.isRequired;
    }

    this.isValid$.next(valid);
    return valid ? null : { invalid: true };
  }
}
