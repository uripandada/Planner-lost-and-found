import { ChangeDetectionStrategy, Component, OnDestroy, OnInit } from '@angular/core';
import { FormBuilder, FormGroup, Validators } from '@angular/forms';
import { MAT_MOMENT_DATE_ADAPTER_OPTIONS, MAT_MOMENT_DATE_FORMATS } from '@angular/material-moment-adapter';
import { DateAdapter, MAT_DATE_FORMATS, MAT_DATE_LOCALE } from '@angular/material/core';
import { ActivatedRoute, Router } from '@angular/router';
import moment, { Moment } from 'moment';
import { ToastrService } from 'ngx-toastr';
import { BehaviorSubject, Observable, Subscription } from 'rxjs';
import { map, startWith } from 'rxjs/operators';
import { BalancedTaskOptions, CancelTaskCommand, ChangeTaskStatusCommand, ClaimTaskCommand, DailyRecurringTaskOptions, EventTaskOptions, GetMonthlyTasksGraphsDataQuery, GetMonthlyTasksQuery, GetPageOfTasksQuery, GetPageOfWeeklyTasksQuery, GetTaskConfigurationDetailsQuery, GetTaskDetailsQuery, MonthlyRecurringTaskOptions, MonthlyTasksGraphsViewModel, PageOfOfTaskGridItemData, ProcessResponse, RealTimeTasksChangedMessage, RecurringEveryTaskOptions, RejectTaskCommand, SingleTaskOptions, SpecificTimesRecurringTaskOptions, TaskActionData, TaskConfigurationDetailsData, TaskDetailsData, TaskGridItemData, TasksData, TasksManagementClient, TaskWhoData, WeekDayViewModel, WeeklyRecurringTaskOptions, WeeklyTasksViewModel, WeeklyUserDayTaskGroupViewModel, WeeklyUserTaskGroupViewModel } from '../core/autogenerated-clients/api-client';
import { CustomDateAdapter } from '../core/custom-date-adapter';
import { LoadingService } from '../core/services/loading.service';
import { RealTimeTasksService } from '../core/services/signalr.service';
import { DateHelper } from '../shared/helpers/date.helper';
import { MomentDateHelper } from '../shared/helpers/moment-date.helper';


export enum TaskDetailsModes {
  DETAILS,
  CHAT,
  EDIT_FORM,
  HISTORY
}

@Component({
  selector: 'app-tasks-management',
  templateUrl: './tasks-management.component.html',
  styleUrls: ['./tasks-management.component.scss'],
  changeDetection: ChangeDetectionStrategy.OnPush,
  providers: [
    // `MomentDateAdapter` and `MAT_MOMENT_DATE_FORMATS` can be automatically provided by importing
    // `MatMomentDateModule` in your applications root module. We provide it at the component level
    // here, due to limitations of our example generation script.
    { provide: DateAdapter, useClass: CustomDateAdapter, deps: [MAT_DATE_LOCALE] },
    { provide: MAT_DATE_FORMATS, useValue: MAT_MOMENT_DATE_FORMATS },
    { provide: MAT_MOMENT_DATE_ADAPTER_OPTIONS, useValue: { useUtc: true } },
  ],
})
export class TasksManagementComponent implements OnInit, OnDestroy {
  sorts = [
    { key: 'USER_ASC', value: 'User A to Z' },
    { key: 'USER_DESC', value: 'User Z to A' },
    { key: 'ASSET_ASC', value: 'Asset A to Z' },
    { key: 'ASSET_DESC', value: 'Asset Z to A' },
    { key: 'ACTION_ASC', value: 'Action A to Z' },
    { key: 'ACTION_DESC', value: 'Action Z to A' },
    { key: 'ROOM_ASC', value: 'Room A to Z' },
    { key: 'ROOM_DESC', value: 'Room Z to A' },
    { key: 'FLOOR_ASC', value: 'Floor A to Z' },
    { key: 'FLOOR_DESC', value: 'Floor Z to A' },
    { key: 'BUILDING_ASC', value: 'Building A to Z' },
    { key: 'BUILDING_DESC', value: 'Building Z to A' },
    { key: 'HOTEL_ASC', value: 'Hotel A to Z' },
    { key: 'HOTEL_DESC', value: 'Hotel Z to A' },
    { key: 'CREATED_AT_ASC', value: 'Oldest first' },
    { key: 'CREATED_AT_DESC', value: 'Newest first' },
    { key: 'STARTS_AT_ASC', value: 'Soon first' },
    { key: 'STARTS_AT_DESC', value: 'Late first' },
  ];

  statuses = [
    { key: 'ANY', value: 'Any status' },
    { key: 'PENDING', value: 'Pending' },
    { key: 'WAITING', value: 'Waiting' },
    { key: 'STARTED', value: 'Started' },
    { key: 'FINISHED', value: 'Finished' },
    { key: 'PAUSED', value: 'Paused' },
    { key: 'VERIFIED', value: 'Verified' },
    { key: 'CANCELLED', value: 'Cancelled' },
  ];

  taskDetailsModes = TaskDetailsModes;

  isListViewActive$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(true);
  isWeeklyViewActive$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(false);
  isMonthlyViewActive$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(false);

  isTaskConfigurationPopupShown$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(false);
  selectedTaskConfiguration$: BehaviorSubject<TaskConfigurationDetailsData> = new BehaviorSubject<TaskConfigurationDetailsData>(null);
  filteredTaskActions$: Observable<TaskActionData[]>;

  tasksData: TasksData;
  onlyUsersWhos: Array<TaskWhoData>;

  filterForm: FormGroup;

  pageOfTasks$: BehaviorSubject<PageOfOfTaskGridItemData> = new BehaviorSubject<PageOfOfTaskGridItemData>(new PageOfOfTaskGridItemData({ totalNumberOfItems: 0, items: [] }));
  tasks$: BehaviorSubject<TaskGridItemData[]> = new BehaviorSubject<TaskGridItemData[]>([]);
  totalNumberOfTasks$: BehaviorSubject<number> = new BehaviorSubject<number>(0);
  loadedNumberOfTasks$: BehaviorSubject<number> = new BehaviorSubject<number>(0);
  showLoadMore$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(false);

  weekDays$: BehaviorSubject<WeekDayViewModel[]> = new BehaviorSubject<WeekDayViewModel[]>([]);
  weeklyTasks$: BehaviorSubject<WeeklyUserTaskGroupViewModel[]> = new BehaviorSubject<WeeklyUserTaskGroupViewModel[]>([]);
  totalNumberOfWeeklyTasks$: BehaviorSubject<number> = new BehaviorSubject<number>(0);
  loadedNumberOfWeeklyTasks$: BehaviorSubject<number> = new BehaviorSubject<number>(0);
  showLoadMoreWeekly$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(false);

  selectedTaskItemId$: BehaviorSubject<string> = new BehaviorSubject<string>("");
  isLoadingTaskDetails$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(false);
  taskDetails$: BehaviorSubject<TaskDetailsData> = new BehaviorSubject<TaskDetailsData>(null);

  dayInMonthTasks$: BehaviorSubject<TaskGridItemData[]> = new BehaviorSubject<TaskGridItemData[]>([]);
  dayOfMonthDate$: BehaviorSubject<Moment> = new BehaviorSubject<Moment>(null);
  isLoadingDayInMonthTasks$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(false);
  areDayInMonthTasksLoaded$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(false);

  areDetailsDisplayed$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(false);

  monthlyTasksGraphs$: BehaviorSubject<MonthlyTasksGraphsViewModel> = new BehaviorSubject<MonthlyTasksGraphsViewModel>(new MonthlyTasksGraphsViewModel({ averageTasksPerWorker: [], labels: [], numberOfTasks: [], numberOfWorkers: [], maxAverageTasksPerWorker: 0, maxNumberOfTasks: 0, maxNumberOfWorkers: 0 }));
  
  isCreateNew$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(false);

  taskDetailsMode$: BehaviorSubject<TaskDetailsModes> = new BehaviorSubject<TaskDetailsModes>(TaskDetailsModes.DETAILS);

  isTaskClaimed$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(false);
  isTaskRejected$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(false);
  isTaskClaimable$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(false);

  private _realTimeTasksService: RealTimeTasksService;
  private _tasksSubscription: Subscription;

  constructor(private _route: ActivatedRoute, private _router: Router, private _formBuilder: FormBuilder, public loading: LoadingService, private _toastr: ToastrService, private _tasksManagementClient: TasksManagementClient) {
    this._realTimeTasksService = new RealTimeTasksService();
  }

  ngOnInit(): void {
    this.loading.reset();
    this.tasksData = this._route.snapshot.data.tasksData;
    this.onlyUsersWhos = this.tasksData.allWhos.filter(w => w.typeKey === "USER" || w.typeKey === "PLANNED_ATTENDANT");
    let weekDates = DateHelper.getWeekMomentDates(moment(new Date()));

    this.filterForm = this._formBuilder.group({
      keywords: [''],
      sortKey: ['CREATED_AT_DESC'],
      fromDate: [DateHelper.getUtcTodayDateMoment()],
      toDate: [DateHelper.getUtcTodayDateMoment()],
      monthDate: [DateHelper.getUtcTodayDateMoment()],
      statusKey: ["ANY"],
      action: [""],
      wheres: [[]],
      whos: [[]],
      weekStartDate: [weekDates.startOfTheWeek],
      weekEndDate: [weekDates.endOfTheWeek],
      onlyMyTasks: [true, Validators.required],
    });

    this.filteredTaskActions$ = this.filterForm.controls.action.valueChanges
      .pipe(
        startWith(''),
        map(value => {
          if (typeof (value) === "string") {
            return this._filterTaskActions(value);
          }
          else {
            this._selectTaskAction(value);
            return this.tasksData.allTaskActions;
          }
        })
    );

    this.filterForm.controls.keywords.valueChanges.subscribe(() => {
      this._filterTasks(0, 20);
    });
    this.filterForm.controls.sortKey.valueChanges.subscribe(() => {
      this._filterTasks(0, 20);
    });
    this.filterForm.controls.fromDate.valueChanges.subscribe(() => {
      this._filterTasks(0, 20);
    });
    this.filterForm.controls.toDate.valueChanges.subscribe(() => {
      this._filterTasks(0, 20);
    });
    this.filterForm.controls.statusKey.valueChanges.subscribe(() => {
      this._filterTasks(0, 20);
    });
    this.filterForm.controls.action.valueChanges.subscribe(() => {
      this._filterTasks(0, 20);
    });
    this.filterForm.controls.wheres.valueChanges.subscribe(() => {
      this._filterTasks(0, 20);
    });
    this.filterForm.controls.whos.valueChanges.subscribe(() => {
      this._filterTasks(0, 20);
    });

    this._filterDailyTasks(0, 20);

    this._connectToSignalREndpoints();
  }

  ngOnDestroy(): void {
    this._disposeSignalRConnections();
  }

  onMonthFilterValueChanged(monthDate: Moment) {
    this.filterForm.controls.monthDate.setValue(monthDate);
    this._loadMonthlyTasksGraphsData();
  }

  onWeekFilterValueChanged(weekDates) {
    this._filterWeeklyTasks(0);
  }

  changeView(viewKey: string) {
    switch (viewKey) {
      case "LIST":
        this.isListViewActive$.next(true);
        this.isWeeklyViewActive$.next(false);
        this.isMonthlyViewActive$.next(false);

        this._filterDailyTasks(0, 20);
        break;
      case "WEEKLY":
        this.isListViewActive$.next(false);
        this.isWeeklyViewActive$.next(true);
        this.isMonthlyViewActive$.next(false);

        this._filterWeeklyTasks(0);
        break;
      case "MONTHLY":
        this.isListViewActive$.next(false);
        this.isWeeklyViewActive$.next(false);
        this.isMonthlyViewActive$.next(true);

        this._loadMonthlyTasksGraphsData();
        break;
    }
  }

  loadMoreDailyTasks() {
    this._filterDailyTasks(this.loadedNumberOfTasks$.value, 20);
  }

  displayTaskAction(action: TaskActionData): string {
    if (action) {
      return action.actionName + " " + action.assetName
    }

    return '';
  }

  createNewTaskConfiguration() {
    this.selectedTaskConfiguration$.next(this._createNewTaskConfigurationData());
    this.isCreateNew$.next(true);
    this.showTaskConfigurationPopup();
  }

  showTaskConfigurationPopup() {
    this.isTaskConfigurationPopupShown$.next(true);
  }

  hideTaskConfigurationPopup() {
    this.isTaskConfigurationPopupShown$.next(false);
  }

  tasksSaved(closePopup: boolean) {
    if (closePopup) {
      this.hideTaskConfigurationPopup();
    }
    this._filterTasks(0, 20);
  }

  selectTask(task: TaskGridItemData) {
    this._selectTask(task.id);
    this.areDetailsDisplayed$.next(true);
  }

  selectWeeklyTask(taskId: string) {
    this._selectTask(taskId);
    this.areDetailsDisplayed$.next(true);
  }

  openEditTaskConfigurationPopup() {
    this._openEditTaskConfigurationPopup(false);
  }
  
  showTaskChat() {
    if (this.taskDetailsMode$.value !== TaskDetailsModes.CHAT) {
      //this.loading.start();
      this.taskDetailsMode$.next(TaskDetailsModes.CHAT);
    }
  }

  showTaskHistory() {
    if (this.taskDetailsMode$.value !== TaskDetailsModes.HISTORY) {
      this.loading.start();
      this.taskDetailsMode$.next(TaskDetailsModes.HISTORY);
    }
  }

  showEditTaskForm() {
    this.taskDetailsMode$.next(TaskDetailsModes.EDIT_FORM);
  }

  showTaskDetails() {
    this.taskDetailsMode$.next(TaskDetailsModes.DETAILS);
  }

  updateTask(taskId: string) {

    this._selectTask(taskId);
    this._filterTasks(0, this.tasks$.value.length + 1);
    this.areDetailsDisplayed$.next(true);

    //this.taskDetails$.next(data);
    //this.showTaskDetails();
  }

  setTaskPendingStatus() {
    this._changeTaskStatus("PENDING");
  }

  setTaskWaitingStatus() {
    this._changeTaskStatus("WAITING");
  }

  setTaskStartedStatus() {
    this._changeTaskStatus("STARTED");
  }

  setTaskFinishedStatus() {
    this._changeTaskStatus("FINISHED");
  }

  setTaskVerifiedStatus() {
    this._changeTaskStatus("VERIFIED");
  }

  cancelTask() {
    this.loading.start();

    let request: CancelTaskCommand = new CancelTaskCommand({ taskId: this.taskDetails$.value.id });

    this._tasksManagementClient.cancelTask(request).subscribe(
      (response: ProcessResponse) => {
        if (response.hasError) {
          this._toastr.error(response.message);
          return;
        }

        this._toastr.success(response.message);
        this.taskDetails$.next(new TaskDetailsData({ ...this.taskDetails$.value, statusKey: "CANCELLED" }));
        this._applyTaskDetailsStatusChangeOnTheList();
      },
      (error: Error) => {
        this._toastr.error(error.message);
      },
      () => {
        this.loading.stop();
      }
    );
  }

  duplicateTask() {
    this._openEditTaskConfigurationPopup(true);
  }

  onDayOfMonthSelected(day: number) {
    this._loadDayOfMonthTasks(day);
  }

  pauseTask() {
    this._changeTaskStatus("PAUSED");
  }

  claimTask() {
    this.loading.start();

    this._tasksManagementClient
      .claimTask(new ClaimTaskCommand({ taskId: this.taskDetails$.value.id }))
      .subscribe(
        (response: ProcessResponse) => {
          if (response.hasError) {
            this._toastr.error(response.message);
            return;
          }

          this._toastr.success(response.message);
          this.taskDetails$.next(new TaskDetailsData({ ...this.taskDetails$.value, statusKey: "WAITING" }));
          this._applyTaskDetailsStatusChangeOnTheList();
          this._setTaskClaimableStatus();
        },
        (error: Error) => { this._toastr.error(error.message); },
        () => { this.loading.stop(); });
  }

  rejectTask() {
    this.loading.start();

    this._tasksManagementClient
      .rejectTask(new RejectTaskCommand({ taskId: this.taskDetails$.value.id }))
      .subscribe(
        (response: ProcessResponse) => {
          if (response.hasError) {
            this._toastr.error(response.message);
            return;
          }

          this._toastr.success(response.message);
          this.taskDetails$.next(new TaskDetailsData({ ...this.taskDetails$.value, statusKey: "REJECTED" }));
          this._applyTaskDetailsStatusChangeOnTheList();
          this._setTaskClaimableStatus();
        },
        (error: Error) => { this._toastr.error(error.message); },
        () => { this.loading.stop(); });
  }

  private _loadDayOfMonthTasks(day: number) {
    this.loading.start();
    this.isLoadingDayInMonthTasks$.next(true);
    this.dayOfMonthDate$.next(null);

    let monthDate: Moment = this.filterForm.controls.monthDate.value;
    let date = moment.utc(monthDate.clone().startOf('month').add(day - 1, 'days').format('LL'));

    let request: GetMonthlyTasksQuery = new GetMonthlyTasksQuery({
      monthDate: date,
      actionName: null,
      assetId: null,
      assetGroupId: null,
      keywords: null,
      statusKey: null,
      wheres: [],
      whos: []
    });

    this._tasksManagementClient.getMonthlyTasks(request).subscribe(
      (tasks: TaskGridItemData[]) => {
        this.dayOfMonthDate$.next(monthDate);
        this.dayInMonthTasks$.next(tasks);
        this.areDayInMonthTasksLoaded$.next(true);
      },
      (error: Error) => { this._toastr.error(error.message); },
      () => {
        this.loading.stop();
        this.isLoadingDayInMonthTasks$.next(false);
      }
    );
  }

  private _filterTasks(skip: number, pageSize: number) {
    if (this.isListViewActive$.value) {
      this._filterDailyTasks(skip, pageSize);
    }
    else if (this.isWeeklyViewActive$.value) {
      this._filterWeeklyTasks(skip);
    }
  }

  private _loadMonthlyTasksGraphsData() {
    this.loading.start();

    let query: GetMonthlyTasksGraphsDataQuery = new GetMonthlyTasksGraphsDataQuery({
      monthDate: this.filterForm.controls.monthDate.value.startOf('day').toDate(),
    });

    this._tasksManagementClient.getMonthlyTasksGraphData(query).subscribe(
      (response: MonthlyTasksGraphsViewModel) => {
        this.monthlyTasksGraphs$.next(response);

      },
      (error: Error) => { this._toastr.error(error.message); },
      () => { this.loading.stop(); }
    );
  }

  private _selectTask(taskId: string) {
    this.selectedTaskItemId$.next(taskId);
    this.isLoadingTaskDetails$.next(true);
    this.loading.start();

    let request = new GetTaskDetailsQuery({ id: taskId });

    this._tasksManagementClient.getTaskDetails(request).subscribe(
      (taskDetails: TaskDetailsData) => {
        this.taskDetails$.next(taskDetails);
        this.taskDetailsMode$.next(TaskDetailsModes.DETAILS);

        this._setTaskClaimableStatus();
      },
      (error: Error) => {
        this._toastr.error(error.message);
      },
      () => {
        this.isLoadingTaskDetails$.next(false);
        this.loading.stop();
      }
    );
  }

  private _setTaskClaimableStatus() {
    let taskDetails = this.taskDetails$.value;
    this.isTaskClaimed$.next(taskDetails.statusKey !== "PENDING");
    this.isTaskRejected$.next(taskDetails.statusKey === "REJECTED");
    this.isTaskClaimable$.next(!taskDetails.mustBeFinishedByAllWhos && !this.isTaskClaimed$.value && !this.isTaskRejected$.value);
  }

  private _openEditTaskConfigurationPopup(isCreateNew: boolean) {
    this.loading.start();

    let request: GetTaskConfigurationDetailsQuery = new GetTaskConfigurationDetailsQuery({
      id: this.taskDetails$.value.systemTaskConfigurationId,
      loadSummary: true,
    });

    this._tasksManagementClient.getTaskConfigurationDetails(request).subscribe(
      (response: TaskConfigurationDetailsData) => {
        if (!response.dailyRecurringTaskOptions) response.dailyRecurringTaskOptions = this._createNewDailyRecurringTaskOptions();
        if (!response.weeklyRecurringTaskOptions) response.weeklyRecurringTaskOptions = this._createNewWeeklyRecurringTaskOptions();
        if (!response.monthlyRecurringTaskOptions) response.monthlyRecurringTaskOptions = this._createNewMonthlyRecurringTaskOptions();
        if (!response.specificTimesRecurringTaskOptions) response.specificTimesRecurringTaskOptions = this._createNewSpecificTimesRecurringTaskOptions();
        if (!response.eventTaskOptions) response.eventTaskOptions = this._createNewEventTaskOptions();
        if (!response.singleTaskOptions) response.singleTaskOptions = this._createNewSingleTaskOptions();
        if (!response.balancedTaskOptions) response.balancedTaskOptions = this._createNewBalancedTaskOptions();
        if (!response.recurringEveryTaskOptions) response.recurringEveryTaskOptions = this._createNewRecurringEveryTaskOptions();

        if (isCreateNew) {
          response.id = null;
        }

        this.selectedTaskConfiguration$.next(response);
        this.isCreateNew$.next(isCreateNew);
        this.showTaskConfigurationPopup();
      },
      (error: Error) => {
        this._toastr.error(error.message);
      },
      () => {
        this.loading.stop();
      }
    );
  }

  private _changeTaskStatus(statusKey: string) {
    this.loading.start();

    this._tasksManagementClient
      .changeTaskStatus(new ChangeTaskStatusCommand({ taskId: this.taskDetails$.value.id, statusKey: statusKey }))
      .subscribe(
        (response: ProcessResponse) => {
          if (response.hasError) {
            this._toastr.error(response.message);
            return;
          }

          this._toastr.success(response.message);
          this.taskDetails$.next(new TaskDetailsData({ ...this.taskDetails$.value, statusKey: statusKey }));
          this._applyTaskDetailsStatusChangeOnTheList();
          this._setTaskClaimableStatus();
        },
        (error: Error) => { this._toastr.error(error.message); },
        () => { this.loading.stop(); });
  }

  private _applyTaskDetailsStatusChangeOnTheList() {
    let taskId: string = this.taskDetails$.value.id;
    let statusKey: string = this.taskDetails$.value.statusKey;

    if (this.isListViewActive$.value) {
      let tasks: TaskGridItemData[] = [...this.tasks$.value];
      let selectedTask: TaskGridItemData = tasks.find(t => t.id === taskId);
      if (selectedTask) {
        selectedTask.statusKey = statusKey;
        selectedTask.statusDescription = statusKey;

        this.tasks$.next(tasks);
      }
    }
    else if (this.isMonthlyViewActive$.value) {
      let tasks: TaskGridItemData[] = [...this.dayInMonthTasks$.value];
      let selectedTask: TaskGridItemData = tasks.find(t => t.id === taskId);
      if (selectedTask) {
        selectedTask.statusKey = statusKey;
        selectedTask.statusDescription = statusKey;

        this.tasks$.next(tasks);
      }
    }
    else if (this.isWeeklyViewActive$.value) {
      let userTasks: WeeklyUserTaskGroupViewModel[] = [...this.weeklyTasks$.value];
      let taskFound: boolean = false;
      for (let userTask of userTasks) {
        for (let dayGroup of userTask.dayGroups) {
          let task = dayGroup.tasks.find(t => t.id === taskId);
          if (task) {
            task.statusKey = statusKey;
            task.statusDescription = statusKey;
            taskFound = true;

            this.weeklyTasks$.next(userTasks);
            break;
          }
        }

        if (taskFound) break;
      }
    }
  }

  private _selectTaskAction(action: TaskActionData): void {
  }

  private _filterTaskActions(value: string): TaskActionData[] {
    let valueParam: string = value.toLowerCase();
    return this.tasksData.allTaskActions.filter(a => a.actionName.toLowerCase().indexOf(valueParam) > -1 || a.assetName.toLowerCase().indexOf(valueParam) > -1);
  }

  private _filterDailyTasks(skip: number, pageSize: number) {
    this.loading.start();

    let filterFormValues = this.filterForm.getRawValue();

    let fromDateString: string = MomentDateHelper.getIsoDate(filterFormValues.fromDate);
    let toDateString: string = MomentDateHelper.getIsoDate(filterFormValues.toDate);

    let query: GetPageOfTasksQuery = new GetPageOfTasksQuery({
      skip: skip,
      take: pageSize,
      keywords: filterFormValues.keywords,
      sortKey: filterFormValues.sortKey,
      statusKey: filterFormValues.statusKey,
      fromDateString: fromDateString,
      toDateString: toDateString,
      assetId: null,
      actionName: null,
      assetGroupId: null,
      wheres: filterFormValues.wheres || [],
      whos: filterFormValues.whos || [],
      onlyMyTasks: filterFormValues.onlyMyTasks,
      taskConfigurationId: null,
    });

    if (typeof filterFormValues.action === "object") {
      query.assetId = filterFormValues.action.assetId;
      query.actionName = filterFormValues.action.actionName;
      //query.assetModelId = filterFormValues.action.assetModelId;
    }

    this._tasksManagementClient.getPage(query).subscribe(
      (response: PageOfOfTaskGridItemData) => {
        if (skip === 0) {
          this.tasks$.next(response.items);
        }
        else {
          this.tasks$.next([...this.tasks$.value, ...response.items]);
        }
        this.totalNumberOfTasks$.next(response.totalNumberOfItems);
        this.loadedNumberOfTasks$.next(this.tasks$.value.length);
        this.showLoadMore$.next(this.loadedNumberOfTasks$.value < this.totalNumberOfTasks$.value);
      },
      (error: Error) => { this._toastr.error(error.message); },
      () => { this.loading.stop(); }
    );
  }

  private _filterWeeklyTasks(skip: number) {
    this.loading.start();

    let filterFormValues = this.filterForm.getRawValue();
    let fromDateString: string = MomentDateHelper.getIsoDate(filterFormValues.weekStartDate);
    let toDateString: string = MomentDateHelper.getIsoDate(filterFormValues.weekEndDate);

    let query: GetPageOfWeeklyTasksQuery = new GetPageOfWeeklyTasksQuery({
      skip: skip,
      take: 20,
      keywords: filterFormValues.keywords,
      sortKey: filterFormValues.sortKey,
      statusKey: filterFormValues.statusKey,
      fromDateString: fromDateString,
      toDateString: toDateString,
      assetId: null,
      actionName: null,
      assetGroupId: null,
      wheres: filterFormValues.wheres || [],
      whos: filterFormValues.whos || [],
      onlyMyTasks: filterFormValues.onlyMyTasks,
    });

    if (typeof filterFormValues.action === "object") {
      query.assetId = filterFormValues.action.assetId;
      query.actionName = filterFormValues.action.actionName;
      //query.assetModelId = filterFormValues.action.assetModelId;
    }

    this._tasksManagementClient.getWeeklyPage(query).subscribe(
      (response: WeeklyTasksViewModel) => {

        //// HORRIBLE HACK TO SAVE ON BANDWIDTH: prefilter tasks visible on the weekly calendar
        //for (let g of response.userGroups) {
        //  for (let d of g.dayGroups) {
        //    d["visibleTasks"] = [];
        //    for (let t of d.tasks) {

        //    }
        //  }
        //}

        if (skip === 0) {
          this.weeklyTasks$.next(response.userGroups);
        }
        else {
          this.weeklyTasks$.next([...this.weeklyTasks$.value, ...response.userGroups]);
        }
        this.weekDays$.next(response.weekDays);
        this.totalNumberOfWeeklyTasks$.next(response.totalNumberOfUserGroups);
        this.loadedNumberOfWeeklyTasks$.next(this.weeklyTasks$.value.length);
        this.showLoadMoreWeekly$.next(this.loadedNumberOfWeeklyTasks$.value < this.totalNumberOfWeeklyTasks$.value);
      },
      (error: Error) => { this._toastr.error(error.message); },
      () => { this.loading.stop(); }
    );
  }

  private _createNewSingleTaskOptions(): SingleTaskOptions {
    return new SingleTaskOptions({
      id: null,
      startsAt: moment(new Date())
    });
  }

  private _createNewDailyRecurringTaskOptions(): DailyRecurringTaskOptions {
    return new DailyRecurringTaskOptions({
      id: null,
      startsAt: moment(new Date()),
      repeatsForKey: "NUMBER_OF_DAYS",
      repeatsForNrDays: 0,
      repeatsForNrOccurences: 0,
      repeatsUntilTime: moment(new Date()),
      repeatTimes: ["08:00"]
    });
  }

  private _createNewWeeklyRecurringTaskOptions(): WeeklyRecurringTaskOptions {
    return new WeeklyRecurringTaskOptions({
      id: null,
      startsAt: moment(new Date()),
      repeatsForKey: "NUMBER_OF_DAYS",
      repeatsForNrDays: 0,
      repeatsForNrOccurences: 0,
      repeatsUntilTime: moment(new Date()),
      weeklyRecurrences: []
    });
  }

  private _createNewMonthlyRecurringTaskOptions(): MonthlyRecurringTaskOptions {
    return new MonthlyRecurringTaskOptions({
      id: null,
      startsAt: moment(new Date()),
      repeatsForKey: "NUMBER_OF_DAYS",
      repeatsForNrDays: 0,
      repeatsForNrOccurences: 0,
      repeatsUntilTime: moment(new Date()),
      monthlyRecurrences: []
    });
  }

  private _createNewSpecificTimesRecurringTaskOptions(): SpecificTimesRecurringTaskOptions {
    return new SpecificTimesRecurringTaskOptions({
      id: null,
      startsAt: [moment(new Date())]
    });
  }

  private _createNewEventTaskOptions(): EventTaskOptions {
    return new EventTaskOptions({
      id: null,
      startsAt: moment(new Date()),
      eventKey: "CHECK_IN",
      eventModifierKey: "BEFORE",
      eventTimeKey: "ON_NEXT",
      repeatsForKey: "NUMBER_OF_DAYS",
      repeatsForNrDays: 0,
      repeatsForNrOccurences: 0,
      repeatsUntilTime: moment(new Date()),
    });
  }

  private _createNewTaskConfigurationData(): TaskConfigurationDetailsData {
    return new TaskConfigurationDetailsData({
      id: null,
      mustBeFinishedByAllWhos: false,
      credits: 0,
      price: 0,
      priorityKey: 'NORMAL',
      isBlockingCleaningUntilFinished: false,
      isGuestRequest: false,
      isMajorNotificationRaisedWhenFinished: false,
      isRescheduledEveryDayUntilFinished: false,
      isShownInNewsFeed: false,
      comment: '',
      files: [],
      filestackImageUrls: [],
      recurringTaskTypeKey: "DAILY",
      taskTypeKey: "SINGLE",
      wheres: [],
      whos: [],
      whats: [],
      whatsTypeKey: "LIST",
      fromReferenceId: null,
      fromReferenceName: null,
      fromReferenceTypeKey: null,
      toReferenceId: null,
      toReferenceName: null,
      toReferenceTypeKey: null,
      singleTaskOptions: this._createNewSingleTaskOptions(),
      dailyRecurringTaskOptions: this._createNewDailyRecurringTaskOptions(),
      weeklyRecurringTaskOptions: this._createNewWeeklyRecurringTaskOptions(),
      monthlyRecurringTaskOptions: this._createNewMonthlyRecurringTaskOptions(),
      specificTimesRecurringTaskOptions: this._createNewSpecificTimesRecurringTaskOptions(),
      eventTaskOptions: this._createNewEventTaskOptions(),
      balancedTaskOptions: this._createNewBalancedTaskOptions(),
      recurringEveryTaskOptions: this._createNewRecurringEveryTaskOptions()
    });
  }

  private _createNewBalancedTaskOptions(): BalancedTaskOptions {
    return new BalancedTaskOptions({
      id: null,
      startsAt: moment(new Date()),
      endsAt: moment(new Date()),
      excludeHolidays: false,
      excludeWeekends: false,
      postponeWhenRoomIsOccupied: false
    });
  }

  private _createNewRecurringEveryTaskOptions(): RecurringEveryTaskOptions {
    return new RecurringEveryTaskOptions({
      id: null,
      startsAt: moment(new Date()),
      repeatsForKey: "NUMBER_OF_DAYS",
      repeatsForNrDays: 0,
      repeatsForNrOccurences: 0,
      repeatsUntilTime: moment(new Date()),
      everyNumberOfDays: 1,
    });
  }


  private _connectToSignalREndpoints() {

    this._realTimeTasksService.connect()
      .catch(() => { this._toastr.error("Error happened while connecting to the Tasks SignalR endpoint."); })
      .finally(() => { /*this._toastr.success("Successfully connected to the Cleaning Plan SignalR endpoint.");*/ });

    this._tasksSubscription = this._realTimeTasksService.cleaningsChanged.subscribe((data: RealTimeTasksChangedMessage) => {
      if (this.isListViewActive$.value) {
        let ts = this.tasks$.value;
        for (let t of ts) {
          if (data.taskIds.indexOf(t.id) >= 0) {
            this._filterDailyTasks(0, this.tasks$.value.length);
            break;
          }
        }

      }
      else if (this.isWeeklyViewActive$.value) {
        let tgs = this.weeklyTasks$.value;
        let taskFound = false;
        for (let tg of tgs) {
          for (let td of tg.dayGroups) {
            for (let t of td.tasks) {
              if (data.taskIds.indexOf(t.id) >= 0) {
                taskFound = true;
                break;
              }
            }

            if (taskFound) break;
          }
          
          if (taskFound) break;
        }

        if (taskFound) {
          this._filterWeeklyTasks(0);
        }
      }
    });
  }

  private _disposeSignalRConnections() {
    this._tasksSubscription.unsubscribe();
    this._realTimeTasksService.disconnect();
  }

}
