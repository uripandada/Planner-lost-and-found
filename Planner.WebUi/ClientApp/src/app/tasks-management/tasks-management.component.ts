import { ChangeDetectionStrategy, Component, OnDestroy, OnInit } from '@angular/core';
import { FormBuilder, FormGroup, Validators } from '@angular/forms';
import { MAT_MOMENT_DATE_ADAPTER_OPTIONS, MAT_MOMENT_DATE_FORMATS } from '@angular/material-moment-adapter';
import { DateAdapter, MAT_DATE_FORMATS, MAT_DATE_LOCALE } from '@angular/material/core';
import { ActivatedRoute, Router } from '@angular/router';
import moment, { Moment } from 'moment';
import { ToastrService } from 'ngx-toastr';
import { title } from 'process';
import { BehaviorSubject, Observable, Subscription } from 'rxjs';
import { map, startWith } from 'rxjs/operators';
import { AvailableUserGroup, BalancedTaskOptions, CancelTaskCommand, ChangeTaskStatusCommand, ClaimTaskCommand, DailyRecurringTaskOptions, EventTaskOptions, GetMonthlyTasksGraphsDataQuery, GetMonthlyTasksQuery, GetPageOfTasksQuery, GetPageOfWeeklyTasksQuery, GetTaskConfigurationDetailsQuery, GetTaskDetailsQuery, MonthlyRecurringTaskOptions, MonthlyTasksGraphsViewModel, PageOfOfTaskGridItemData, ProcessResponse, RealTimeTasksChangedMessage, RecurringEveryTaskOptions, RejectTaskCommand, SingleTaskOptions, SpecificTimesRecurringTaskOptions, TaskActionData, TaskConfigurationDetailsData, TaskDetailsData, TaskGridItemData, TasksData, TasksManagementClient, TaskWhoData, WeekDayViewModel, WeeklyRecurringTaskOptions, WeeklyTasksViewModel, WeeklyUserDayTaskGroupViewModel, WeeklyUserTaskGroupViewModel } from '../core/autogenerated-clients/api-client';
import { CustomDateAdapter } from '../core/custom-date-adapter';
import { LoadingService } from '../core/services/loading.service';
import { RealTimeTasksService } from '../core/services/signalr.service';
import { DateHelper } from '../shared/helpers/date.helper';
import { MomentDateHelper } from '../shared/helpers/moment-date.helper';
import { TaskSelectedEventArgs } from './task-configurations-grid-item/task-selected-event-args';
import { TasksRefreshService } from './tasks-refresh.service';


export enum TaskDetailsModes {
  DETAILS,
  CHAT,
  EDIT_FORM,
  HISTORY
}

export class TabHeader {
  public title: string = "";
  public isActive: boolean = false;
  public id: string = null; 
  public key: string = "PREDEFINED";
}

@Component({
  selector: 'app-tasks-management',
  templateUrl: './tasks-management.component.html',
  styleUrls: ['./tasks-management.component.scss'],
  changeDetection: ChangeDetectionStrategy.OnPush,
  providers: [
    // `MomentDateAdapter` and `MAT_MOMENT_DATE_FORMATS` can be automatically provided by importing
    // `MatMomentDateModule` in your applications root module. We provide it at the component level
    // here, due to limitations of our example generation script.
    { provide: DateAdapter, useClass: CustomDateAdapter, deps: [MAT_DATE_LOCALE] },
    { provide: MAT_DATE_FORMATS, useValue: MAT_MOMENT_DATE_FORMATS },
    { provide: MAT_MOMENT_DATE_ADAPTER_OPTIONS, useValue: { useUtc: true } },
  ],
})
export class TasksManagementComponent implements OnInit, OnDestroy {
  sorts = [
    { key: 'USER_ASC', value: 'User A to Z' },
    { key: 'USER_DESC', value: 'User Z to A' },
    { key: 'ASSET_ASC', value: 'Asset A to Z' },
    { key: 'ASSET_DESC', value: 'Asset Z to A' },
    { key: 'ACTION_ASC', value: 'Action A to Z' },
    { key: 'ACTION_DESC', value: 'Action Z to A' },
    { key: 'ROOM_ASC', value: 'Room A to Z' },
    { key: 'ROOM_DESC', value: 'Room Z to A' },
    { key: 'FLOOR_ASC', value: 'Floor A to Z' },
    { key: 'FLOOR_DESC', value: 'Floor Z to A' },
    { key: 'BUILDING_ASC', value: 'Building A to Z' },
    { key: 'BUILDING_DESC', value: 'Building Z to A' },
    { key: 'HOTEL_ASC', value: 'Hotel A to Z' },
    { key: 'HOTEL_DESC', value: 'Hotel Z to A' },
    { key: 'CREATED_AT_ASC', value: 'Oldest first' },
    { key: 'CREATED_AT_DESC', value: 'Newest first' },
    { key: 'STARTS_AT_ASC', value: 'Soon first' },
    { key: 'STARTS_AT_DESC', value: 'Late first' },
  ];

  statuses = [
    { key: 'ANY', value: 'Any status' },
    { key: 'PENDING', value: 'Pending' },
    { key: 'WAITING', value: 'Waiting' },
    { key: 'STARTED', value: 'Started' },
    { key: 'FINISHED', value: 'Finished' },
    { key: 'PAUSED', value: 'Paused' },
    { key: 'VERIFIED', value: 'Verified' },
    { key: 'CANCELLED', value: 'Cancelled' },
  ];

  tabHeaders: Array<TabHeader> = [
    {
      title: "Tasks",
      isActive: true,
      id: null,
      key: "_#TASKS#_",
    },
     {
      title: "Calendar",
      isActive: false,
      id: null,
      key: "_#CALENDAR#_",
    },
     {
      title: "My tasks",
      isActive: false,
      id: null,
      key: "_#MY_TASKS#_",
    },
    
  ];
  selectedTaskId$: BehaviorSubject<string> = new BehaviorSubject<string>("");
  selectedTaskConfigurationId$: BehaviorSubject<string> = new BehaviorSubject<string>("");

  taskDetailsModes = TaskDetailsModes;

  //listViewSettings: any = {
  //  isMyTasksCalendarDisplayed: BehaviorSubject < boolean > = new BehaviorSubject < boolean >(), // = new BehaviorSubject<boolean>(false),
  //};


  isListViewActive$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(true);
  isMyTasksViewActive$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(false);

  isTaskConfigurationPopupShown$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(false);
  selectedTaskConfiguration$: BehaviorSubject<TaskConfigurationDetailsData> = new BehaviorSubject<TaskConfigurationDetailsData>(null);
  filteredTaskActions$: Observable<TaskActionData[]>;

  tasksData: TasksData;
  onlyUsersWhos: Array<TaskWhoData>;

  filterForm: FormGroup;

  taskConfigurationsFilterForm: FormGroup;

  pageOfTasks$: BehaviorSubject<PageOfOfTaskGridItemData> = new BehaviorSubject<PageOfOfTaskGridItemData>(new PageOfOfTaskGridItemData({ totalNumberOfItems: 0, items: [] }));
  tasks$: BehaviorSubject<TaskGridItemData[]> = new BehaviorSubject<TaskGridItemData[]>([]);
  totalNumberOfTasks$: BehaviorSubject<number> = new BehaviorSubject<number>(0);
  loadedNumberOfTasks$: BehaviorSubject<number> = new BehaviorSubject<number>(0);
  showLoadMore$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(false);

  isLoadingTaskDetails$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(false);
  taskDetails$: BehaviorSubject<TaskDetailsData> = new BehaviorSubject<TaskDetailsData>(null);

  areDetailsDisplayed$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(false);

  isCreateNew$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(false);

  taskDetailsMode$: BehaviorSubject<TaskDetailsModes> = new BehaviorSubject<TaskDetailsModes>(TaskDetailsModes.DETAILS);

  isTaskClaimed$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(false);
  isTaskRejected$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(false);
  isTaskClaimable$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(false);

  private _realTimeTasksService: RealTimeTasksService;
  private _tasksSubscription: Subscription;

  constructor(private _route: ActivatedRoute, private _router: Router, private _formBuilder: FormBuilder, public loading: LoadingService, private _toastr: ToastrService, private _tasksManagementClient: TasksManagementClient, private _refreshTasksGridsService: TasksRefreshService) {
    this._realTimeTasksService = new RealTimeTasksService();
  }

  ngOnInit(): void {
    this.loading.reset();
    this.tasksData = this._route.snapshot.data.tasksData;
    this.onlyUsersWhos = this.tasksData.allWhos.filter(w => w.typeKey === "USER" || w.typeKey === "PLANNED_ATTENDANT");
    let weekDates = DateHelper.getWeekMomentDates(moment(new Date()));

    this.tabHeaders = this._createTabHeaders(this.tasksData.availableUserGroups);

    //for(let availableUserGroup of this.tasksData.availableUserGroups){
    //    this.tabHeaders.push({
    //    title: availableUserGroup.name,
    //    isActive: false,
    //    id: availableUserGroup.id,
    //    key: availableUserGroup.isSubGroup ? "_#USERSUBGROUP#_" : "_#USERGROUP#_",
    //  });
    //}

    this.filterForm = this._formBuilder.group({
      keywords: [''],
      sortKey: ['CREATED_AT_DESC'],
      fromDate: [DateHelper.getUtcTodayDateMoment()],
      toDate: [DateHelper.getUtcTodayDateMoment()],
      monthDate: [DateHelper.getUtcTodayDateMoment()],
      statusKey: ["ANY"],
      action: [""],
      wheres: [[]],
      whos: [[]],
      weekStartDate: [weekDates.startOfTheWeek],
      weekEndDate: [weekDates.endOfTheWeek],
      onlyMyTasks: [true, Validators.required],
    });

    this.filteredTaskActions$ = this.filterForm.controls.action.valueChanges
      .pipe(
        startWith(''),
        map(value => {
          if (typeof (value) === "string") {
            return this._filterTaskActions(value);
          }
          else {
            this._selectTaskAction(value);
            return this.tasksData.allTaskActions;
          }
        })
    );

    this.filterForm.controls.keywords.valueChanges.subscribe(() => {
      this._filterTasks(0, 20);
    });
    this.filterForm.controls.sortKey.valueChanges.subscribe(() => {
      this._filterTasks(0, 20);
    });
    this.filterForm.controls.fromDate.valueChanges.subscribe(() => {
      this._filterTasks(0, 20);
    });
    this.filterForm.controls.toDate.valueChanges.subscribe(() => {
      this._filterTasks(0, 20);
    });
    this.filterForm.controls.statusKey.valueChanges.subscribe(() => {
      this._filterTasks(0, 20);
    });
    this.filterForm.controls.action.valueChanges.subscribe(() => {
      this._filterTasks(0, 20);
    });
    this.filterForm.controls.wheres.valueChanges.subscribe(() => {
      this._filterTasks(0, 20);
    });
    this.filterForm.controls.whos.valueChanges.subscribe(() => {
      this._filterTasks(0, 20);
    });

    this._filterDailyTasks(0, 20);

    this._connectToSignalREndpoints();
  }

  ngOnDestroy(): void {
    this._disposeSignalRConnections();
  }

  changeView(viewKey: string, viewId: string, tabHeader: TabHeader) {
    for(let h of this.tabHeaders){
      h.isActive = h === tabHeader;
    }

    switch (viewKey) {
      case "_#TASKS#_":
        this.isListViewActive$.next(true);
        this.isMyTasksViewActive$.next(false);
        break;
      case "_#CALENDAR#_":
        this.isListViewActive$.next(false);
        this.isMyTasksViewActive$.next(false);

        break;
      case "_#MY_TASKS#_":
        this.isListViewActive$.next(false);
        this.isMyTasksViewActive$.next(true);
        break;
      case "_#DYNAMIC#_":
        this.isListViewActive$.next(false);
        this.isMyTasksViewActive$.next(true);
        break;
    }
  }

  loadMoreDailyTasks() {
    this._filterDailyTasks(this.loadedNumberOfTasks$.value, 20);
  }

  displayTaskAction(action: TaskActionData): string {
    if (action) {
      return action.actionName + " " + action.assetName
    }

    return '';
  }

  createNewTaskConfiguration() {
    this.selectedTaskConfiguration$.next(this._createNewTaskConfigurationData());
    this.isCreateNew$.next(true);
    this.showTaskConfigurationPopup();
  }

  showTaskConfigurationPopup() {
    this.isTaskConfigurationPopupShown$.next(true);
  }

  hideTaskConfigurationPopup() {
    this.isTaskConfigurationPopupShown$.next(false);
  }

  tasksSaved(closePopup: boolean) {
    if (closePopup) {
      this.hideTaskConfigurationPopup();
    }
    this._refreshTasksGridsService.refreshGrids();
    //this._filterTasks(0, 20);
  }

  onTaskSelected(args: TaskSelectedEventArgs) {
    this._showTaskDetails(args.taskId);
    this.areDetailsDisplayed$.next(true);
    this.selectedTaskId$.next(args.taskId);
    this.selectedTaskConfigurationId$.next(args.taskConfigurationId);
  }

  closeDetails() {
    this.areDetailsDisplayed$.next(false);
    this.selectedTaskId$.next("");
  }

  openEditTaskConfigurationPopup() {
    this._openEditTaskConfigurationPopup(false);
  }
  
  showTaskChat() {
    if (this.taskDetailsMode$.value !== TaskDetailsModes.CHAT) {
      //this.loading.start();
      this.taskDetailsMode$.next(TaskDetailsModes.CHAT);
    }
  }

  showTaskHistory() {
    if (this.taskDetailsMode$.value !== TaskDetailsModes.HISTORY) {
      this.loading.start();
      this.taskDetailsMode$.next(TaskDetailsModes.HISTORY);
    }
  }

  showEditTaskForm() {
    this.taskDetailsMode$.next(TaskDetailsModes.EDIT_FORM);
  }

  showTaskDetails() {
    this.taskDetailsMode$.next(TaskDetailsModes.DETAILS);
  }

  updateTask(taskId: string) {
    // UPDATE TASK IS REALLY REASSIGN TASK

    this.areDetailsDisplayed$.next(false);
    this.taskDetails$.next(new TaskDetailsData({ ...this.taskDetails$.value, statusKey: "CANCELLED" }));
    this._applyTaskDetailsStatusChangeOnTheList();

  }

  setTaskPendingStatus() {
    this._changeTaskStatus("PENDING");
  }

  setTaskWaitingStatus() {
    this._changeTaskStatus("WAITING");
  }

  setTaskStartedStatus() {
    this._changeTaskStatus("STARTED");
  }

  setTaskFinishedStatus() {
    this._changeTaskStatus("FINISHED");
  }

  setTaskVerifiedStatus() {
    this._changeTaskStatus("VERIFIED");
  }

  cancelTask() {
    this.loading.start();

    let request: CancelTaskCommand = new CancelTaskCommand({ taskId: this.taskDetails$.value.id });

    this._tasksManagementClient.cancelTask(request).subscribe(
      (response: ProcessResponse) => {
        if (response.hasError) {
          this._toastr.error(response.message);
          return;
        }

        this._toastr.success(response.message);
        this.taskDetails$.next(new TaskDetailsData({ ...this.taskDetails$.value, statusKey: "CANCELLED" }));
        this._applyTaskDetailsStatusChangeOnTheList();
      },
      (error: Error) => {
        this._toastr.error(error.message);
      },
      () => {
        this.loading.stop();
      }
    );
  }

  duplicateTask() {
    this._openEditTaskConfigurationPopup(true);
  }

  pauseTask() {
    this._changeTaskStatus("PAUSED");
  }

  claimTask() {
    this.loading.start();

    this._tasksManagementClient
      .claimTask(new ClaimTaskCommand({ taskId: this.taskDetails$.value.id }))
      .subscribe(
        (response: ProcessResponse) => {
          if (response.hasError) {
            this._toastr.error(response.message);
            return;
          }

          this._toastr.success(response.message);
          this.taskDetails$.next(new TaskDetailsData({ ...this.taskDetails$.value, statusKey: "WAITING" }));
          this._applyTaskDetailsStatusChangeOnTheList();
          this._setTaskClaimableStatus();
        },
        (error: Error) => { this._toastr.error(error.message); },
        () => { this.loading.stop(); });
  }

  rejectTask() {
    this.loading.start();

    this._tasksManagementClient
      .rejectTask(new RejectTaskCommand({ taskId: this.taskDetails$.value.id }))
      .subscribe(
        (response: ProcessResponse) => {
          if (response.hasError) {
            this._toastr.error(response.message);
            return;
          }

          this._toastr.success(response.message);
          this.taskDetails$.next(new TaskDetailsData({ ...this.taskDetails$.value, statusKey: "REJECTED" }));
          this._applyTaskDetailsStatusChangeOnTheList();
          this._setTaskClaimableStatus();
        },
        (error: Error) => { this._toastr.error(error.message); },
        () => { this.loading.stop(); });
  }

  private _filterTasks(skip: number, pageSize: number) {
    if (this.isListViewActive$.value) {
      this._filterDailyTasks(skip, pageSize);
    }
  }

  private _showTaskDetails(taskId: string) {
    this.isLoadingTaskDetails$.next(true);
    this.loading.start();

    let request = new GetTaskDetailsQuery({ id: taskId });

    this._tasksManagementClient.getTaskDetails(request).subscribe(
      (taskDetails: TaskDetailsData) => {
        this.taskDetails$.next(taskDetails);
        this.taskDetailsMode$.next(TaskDetailsModes.DETAILS);

        this._setTaskClaimableStatus();
        this._applyTaskDetailsStatusChangeOnTheList();
        this.areDetailsDisplayed$.next(true);
      },
      (error: Error) => {
        this._toastr.error(error.message);
        this.loading.stop();
      },
      () => {
        this.isLoadingTaskDetails$.next(false);
        this.loading.stop();
      }
    );
  }

  private _setTaskClaimableStatus() {
    let taskDetails = this.taskDetails$.value;
    this.isTaskClaimed$.next(taskDetails.statusKey !== "PENDING");
    this.isTaskRejected$.next(taskDetails.statusKey === "REJECTED");
    this.isTaskClaimable$.next(!taskDetails.mustBeFinishedByAllWhos && !this.isTaskClaimed$.value && !this.isTaskRejected$.value);
  }

  private _openEditTaskConfigurationPopup(isCreateNew: boolean) {
    this.loading.start();

    let request: GetTaskConfigurationDetailsQuery = new GetTaskConfigurationDetailsQuery({
      id: this.taskDetails$.value.systemTaskConfigurationId,
      loadSummary: true,
    });

    this._tasksManagementClient.getTaskConfigurationDetails(request).subscribe(
      (response: TaskConfigurationDetailsData) => {
        if (!response.dailyRecurringTaskOptions) response.dailyRecurringTaskOptions = this._createNewDailyRecurringTaskOptions();
        if (!response.weeklyRecurringTaskOptions) response.weeklyRecurringTaskOptions = this._createNewWeeklyRecurringTaskOptions();
        if (!response.monthlyRecurringTaskOptions) response.monthlyRecurringTaskOptions = this._createNewMonthlyRecurringTaskOptions();
        if (!response.specificTimesRecurringTaskOptions) response.specificTimesRecurringTaskOptions = this._createNewSpecificTimesRecurringTaskOptions();
        if (!response.eventTaskOptions) response.eventTaskOptions = this._createNewEventTaskOptions();
        if (!response.singleTaskOptions) response.singleTaskOptions = this._createNewSingleTaskOptions();
        if (!response.balancedTaskOptions) response.balancedTaskOptions = this._createNewBalancedTaskOptions();
        if (!response.recurringEveryTaskOptions) response.recurringEveryTaskOptions = this._createNewRecurringEveryTaskOptions();

        if (isCreateNew) {
          response.id = null;
        }

        this.selectedTaskConfiguration$.next(response);
        this.isCreateNew$.next(isCreateNew);
        this.showTaskConfigurationPopup();
      },
      (error: Error) => {
        this._toastr.error(error.message);
      },
      () => {
        this.loading.stop();
      }
    );
  }

  private _changeTaskStatus(statusKey: string) {
    this.loading.start();

    this._tasksManagementClient
      .changeTaskStatus(new ChangeTaskStatusCommand({ taskId: this.taskDetails$.value.id, statusKey: statusKey }))
      .subscribe(
        (response: ProcessResponse) => {
          if (response.hasError) {
            this._toastr.error(response.message);
            return;
          }

          this._toastr.success(response.message);
          this.taskDetails$.next(new TaskDetailsData({ ...this.taskDetails$.value, statusKey: statusKey }));
          this._applyTaskDetailsStatusChangeOnTheList();
          this._setTaskClaimableStatus();
        },
        (error: Error) => { this._toastr.error(error.message); },
        () => { this.loading.stop(); });
  }

  private _applyTaskDetailsStatusChangeOnTheList() {
    let taskConfigurationId: string = this.taskDetails$.value.systemTaskConfigurationId;
    let taskId: string = this.taskDetails$.value.id;
    let statusKey: string = this.taskDetails$.value.statusKey;

    this._refreshTasksGridsService.taskStatusChanged({ taskId: taskId, taskConfigurationId: taskConfigurationId, statusKey: statusKey });

    //if (this.isListViewActive$.value) {
    //  let tasks: TaskGridItemData[] = [...this.tasks$.value];
    //  let selectedTask: TaskGridItemData = tasks.find(t => t.id === taskId);
    //  if (selectedTask) {
    //    selectedTask.statusKey = statusKey;
    //    selectedTask.statusDescription = statusKey;

    //    this.tasks$.next(tasks);
    //  }
    //}
  }

  private _selectTaskAction(action: TaskActionData): void {
  }

  private _filterTaskActions(value: string): TaskActionData[] {
    let valueParam: string = value.toLowerCase();
    return this.tasksData.allTaskActions.filter(a => a.actionName.toLowerCase().indexOf(valueParam) > -1 || a.assetName.toLowerCase().indexOf(valueParam) > -1);
  }

  private _filterDailyTasks(skip: number, pageSize: number) {
    this.loading.start();

    let filterFormValues = this.filterForm.getRawValue();

    let fromDateString: string = MomentDateHelper.getIsoDate(filterFormValues.fromDate);
    let toDateString: string = MomentDateHelper.getIsoDate(filterFormValues.toDate);

    let query: GetPageOfTasksQuery = new GetPageOfTasksQuery({
      skip: skip,
      take: pageSize,
      keywords: filterFormValues.keywords,
      sortKey: filterFormValues.sortKey,
      statusKey: filterFormValues.statusKey,
      fromDateString: fromDateString,
      toDateString: toDateString,
      assetId: null,
      actionName: null,
      assetGroupId: null,
      wheres: filterFormValues.wheres || [],
      whos: filterFormValues.whos || [],
      onlyMyTasks: filterFormValues.onlyMyTasks,
      taskConfigurationId: null,
    });

    if (typeof filterFormValues.action === "object") {
      query.assetId = filterFormValues.action.assetId;
      query.actionName = filterFormValues.action.actionName;
      //query.assetModelId = filterFormValues.action.assetModelId;
    }

    this._tasksManagementClient.getPage(query).subscribe(
      (response: PageOfOfTaskGridItemData) => {
        if (skip === 0) {
          this.tasks$.next(response.items);
        }
        else {
          this.tasks$.next([...this.tasks$.value, ...response.items]);
        }
        this.totalNumberOfTasks$.next(response.totalNumberOfItems);
        this.loadedNumberOfTasks$.next(this.tasks$.value.length);
        this.showLoadMore$.next(this.loadedNumberOfTasks$.value < this.totalNumberOfTasks$.value);
      },
      (error: Error) => { this._toastr.error(error.message); },
      () => { this.loading.stop(); }
    );
  }

  private _createNewSingleTaskOptions(): SingleTaskOptions {
    return new SingleTaskOptions({
      id: null,
      startsAt: moment(new Date())
    });
  }

  private _createNewDailyRecurringTaskOptions(): DailyRecurringTaskOptions {
    return new DailyRecurringTaskOptions({
      id: null,
      startsAt: moment(new Date()),
      repeatsForKey: "NUMBER_OF_DAYS",
      repeatsForNrDays: 0,
      repeatsForNrOccurences: 0,
      repeatsUntilTime: moment(new Date()),
      repeatTimes: ["08:00"]
    });
  }

  private _createNewWeeklyRecurringTaskOptions(): WeeklyRecurringTaskOptions {
    return new WeeklyRecurringTaskOptions({
      id: null,
      startsAt: moment(new Date()),
      repeatsForKey: "NUMBER_OF_DAYS",
      repeatsForNrDays: 0,
      repeatsForNrOccurences: 0,
      repeatsUntilTime: moment(new Date()),
      weeklyRecurrences: []
    });
  }

  private _createNewMonthlyRecurringTaskOptions(): MonthlyRecurringTaskOptions {
    return new MonthlyRecurringTaskOptions({
      id: null,
      startsAt: moment(new Date()),
      repeatsForKey: "NUMBER_OF_DAYS",
      repeatsForNrDays: 0,
      repeatsForNrOccurences: 0,
      repeatsUntilTime: moment(new Date()),
      monthlyRecurrences: []
    });
  }

  private _createNewSpecificTimesRecurringTaskOptions(): SpecificTimesRecurringTaskOptions {
    return new SpecificTimesRecurringTaskOptions({
      id: null,
      startsAt: [moment(new Date())]
    });
  }

  private _createNewEventTaskOptions(): EventTaskOptions {
    return new EventTaskOptions({
      id: null,
      startsAt: moment(new Date()),
      eventKey: "CHECK_IN",
      eventModifierKey: "BEFORE",
      eventTimeKey: "ON_NEXT",
      repeatsForKey: "NUMBER_OF_DAYS",
      repeatsForNrDays: 0,
      repeatsForNrOccurences: 0,
      repeatsUntilTime: moment(new Date()),
    });
  }

  private _createNewTaskConfigurationData(): TaskConfigurationDetailsData {
    return new TaskConfigurationDetailsData({
      id: null,
      mustBeFinishedByAllWhos: false,
      credits: 0,
      price: 0,
      priorityKey: 'NORMAL',
      isBlockingCleaningUntilFinished: false,
      isGuestRequest: false,
      isMajorNotificationRaisedWhenFinished: false,
      isRescheduledEveryDayUntilFinished: false,
      isShownInNewsFeed: false,
      comment: '',
      files: [],
      filestackImageUrls: [],
      recurringTaskTypeKey: "DAILY",
      taskTypeKey: "SINGLE",
      wheres: [],
      whos: [],
      whats: [],
      whatsTypeKey: "LIST",
      fromReferenceId: null,
      fromReferenceName: null,
      fromReferenceTypeKey: null,
      toReferenceId: null,
      toReferenceName: null,
      toReferenceTypeKey: null,
      singleTaskOptions: this._createNewSingleTaskOptions(),
      dailyRecurringTaskOptions: this._createNewDailyRecurringTaskOptions(),
      weeklyRecurringTaskOptions: this._createNewWeeklyRecurringTaskOptions(),
      monthlyRecurringTaskOptions: this._createNewMonthlyRecurringTaskOptions(),
      specificTimesRecurringTaskOptions: this._createNewSpecificTimesRecurringTaskOptions(),
      eventTaskOptions: this._createNewEventTaskOptions(),
      balancedTaskOptions: this._createNewBalancedTaskOptions(),
      recurringEveryTaskOptions: this._createNewRecurringEveryTaskOptions()
    });
  }

  private _createNewBalancedTaskOptions(): BalancedTaskOptions {
    return new BalancedTaskOptions({
      id: null,
      startsAt: moment(new Date()),
      endsAt: moment(new Date()),
      excludeHolidays: false,
      excludeWeekends: false,
      postponeWhenRoomIsOccupied: false
    });
  }

  private _createNewRecurringEveryTaskOptions(): RecurringEveryTaskOptions {
    return new RecurringEveryTaskOptions({
      id: null,
      startsAt: moment(new Date()),
      repeatsForKey: "NUMBER_OF_DAYS",
      repeatsForNrDays: 0,
      repeatsForNrOccurences: 0,
      repeatsUntilTime: moment(new Date()),
      everyNumberOfDays: 1,
    });
  }

  private _createTabHeaders(groups: AvailableUserGroup[]): TabHeader[] {
    return [
      {
        title: "My tasks",
        isActive: true,
        id: null,
        key: "_#MY_TASKS#_",
      },
      ...groups.map(g => {
        return {
          title: g.name,
          isActive: false,
          id: g.id,
          key: g.isSubGroup ? "_#USERSUBGROUP#_" : "_#USERGROUP#_",
        };
      }),
      {
        title: "All tasks",
        isActive: false,
        id: null,
        key: "_#TASKS#_",
      },
    ];
  }

  private _connectToSignalREndpoints() {

    this._realTimeTasksService.connect()
      .catch(() => { this._toastr.error("Error happened while connecting to the Tasks SignalR endpoint."); })
      .finally(() => { /*this._toastr.success("Successfully connected to the Cleaning Plan SignalR endpoint.");*/ });

    this._tasksSubscription = this._realTimeTasksService.cleaningsChanged.subscribe((data: RealTimeTasksChangedMessage) => {
      if (this.isListViewActive$.value) {
        let ts = this.tasks$.value;
        for (let t of ts) {
          if (data.taskIds.indexOf(t.id) >= 0) {
            this._filterDailyTasks(0, this.tasks$.value.length);
            break;
          }
        }

      }
    });
  }

  private _disposeSignalRConnections() {
    this._tasksSubscription.unsubscribe();
    this._realTimeTasksService.disconnect();
  }

}
