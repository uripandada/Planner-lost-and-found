import { Component, ElementRef, EventEmitter, Input, OnChanges, OnInit, Output, SimpleChanges, ViewChild } from '@angular/core';
import { FormArray, FormBuilder, FormControl, FormGroup } from '@angular/forms';
import { ToastrService } from 'ngx-toastr';
import { Observable } from 'rxjs';
import { map, startWith } from 'rxjs/operators';
import { ExtendedTaskActionData, TaskWhoData } from '../../core/autogenerated-clients/api-client';
import { LoadingService } from '../../core/services/loading.service';

@Component({
  selector: 'app-what-multiselect',
  templateUrl: './what-multiselect.component.html',
  styleUrls: ['./what-multiselect.component.scss']
})
export class WhatMultiselectComponent implements OnInit, OnChanges {
  @ViewChild('multiselectInputOne', { static: true }) multiselectInput: ElementRef;

  @Input() whatsFormArray: FormArray;
  @Input() allWhats: Array<ExtendedTaskActionData> = [];

  @Output() whatSelected: EventEmitter<ExtendedTaskActionData> = new EventEmitter<ExtendedTaskActionData>();

  selectWhatForm: FormGroup;
  selectedWhatControl: FormControl;
  filteredWhats$: Observable<ExtendedTaskActionData[]>;



  constructor(private _toastr: ToastrService, public loading: LoadingService, private _formBuilder: FormBuilder) { }

  ngOnInit(): void {
    this.selectedWhatControl = new FormControl("");
    this.selectWhatForm = this._formBuilder.group({
      what: [""],
      quantity: [1]
    });

    this.filteredWhats$ = this.selectWhatForm.controls.what.valueChanges
      .pipe(
        startWith(''),
        map(whatValue => {
          if (typeof (whatValue) === "string") {
            return this._filterWhats(whatValue);
          }
          else {
            this.selectWhat(+this.selectWhatForm.controls.quantity.value, whatValue);
            this.selectWhatForm.controls.quantity.setValue(1);
            return this.allWhats;
          }
        })
    );
  }

  ngOnChanges(changes: SimpleChanges): void {
    // This condition makes sure to force update the what form value to ''.
    // 1. This will force the observable filteredWhats$ to emit new value
    // 2. !changes.whatsFormArray condition is here to make sure this part is fired only and only when the this.allWhats have changed.
    if (changes.allWhats && !changes.allWhats.firstChange && !changes.whatsFormArray) {
      if (this.selectWhatForm) {
        this.selectWhatForm.controls.what.setValue('');
        this.selectWhatForm.controls.what.updateValueAndValidity({ onlySelf: true, emitEvent: true });
      }
    }
  }

  public displayWhat(who: TaskWhoData): string {
    return '';
  }

  public blurAutocomplete() {
    this.multiselectInput.nativeElement.blur();
  }

  private _filterWhats(value: string): ExtendedTaskActionData[] {
    let valueParam: string = value.toLowerCase();
    return this.allWhats.filter(a => a.actionName.toLowerCase().indexOf(valueParam) > -1 || a.assetName.toLowerCase().indexOf(valueParam) > -1 || a.altAssetName.toLowerCase().indexOf(valueParam) > -1);
  }

  selectWhat(quantity: number, what: ExtendedTaskActionData): void {
    this.whatsFormArray.push(this._formBuilder.group({
      assetId: [what.assetId],
      assetName: [what.assetName],
      actionName: [what.actionName],
      assetQuantity: [quantity],
      assetGroupId: [what.assetGroupId],
      assetGroupName: [what.assetGroupName],
      isActionSystemDefined: [what.isActionSystemDefined],
      systemDefinedActionIdentifierKey: [what.systemDefinedActionIdentifierKey],
      systemDefinedActionTypeKey: [what.systemDefinedActionTypeKey],
    }));

    this.whatSelected.next(what);
  }

  removeWhat(formArrayIndex: number): void {
    this.whatsFormArray.removeAt(formArrayIndex);
  }
}
