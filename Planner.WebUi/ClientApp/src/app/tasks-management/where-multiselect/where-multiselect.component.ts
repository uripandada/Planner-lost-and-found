import { Component, ElementRef, EventEmitter, forwardRef, Input, OnChanges, OnInit, Output, SimpleChanges, ViewChild } from '@angular/core';
import { AbstractControl, ControlValueAccessor, FormControl, NG_VALIDATORS, NG_VALUE_ACCESSOR, ValidationErrors, Validator } from '@angular/forms';
import { ToastrService } from 'ngx-toastr';
import { BehaviorSubject, Observable } from 'rxjs';
import { map, startWith } from 'rxjs/operators';
import { TaskWhereData } from '../../core/autogenerated-clients/api-client';
import { LoadingService } from '../../core/services/loading.service';

@Component({
  selector: 'app-where-multiselect',
  templateUrl: './where-multiselect.component.html',
  styleUrls: ['./where-multiselect.component.scss'],
  providers: [
    {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => WhereMultiselectComponent),
      multi: true
    },
    {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => WhereMultiselectComponent),
      multi: true
    }
  ]
})
export class WhereMultiselectComponent implements OnInit, OnChanges, ControlValueAccessor, Validator {
  @ViewChild('multiselectInput', { static: true }) multiselectInput: ElementRef;
  @Input() allWheres: Array<TaskWhereData> = [];
  @Input() selectedWheres: Array<TaskWhereData> = [];
  @Input() isRequired: boolean = false;
  @Input() showMiniTags: boolean = false;
  @Input() placeholderText: string = "Where...";

  selectedWhereControl: FormControl;
  filteredWheres$: Observable<TaskWhereData[]>;

  selectedWheres$: BehaviorSubject<TaskWhereData[]> = new BehaviorSubject<TaskWhereData[]>([]);
  isValid$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(true);
   

  constructor(private _toastr: ToastrService, public loading: LoadingService) { }


  ngOnInit(): void {
    this.selectedWheres$.next(this.selectedWheres);
    this.value = this.selectedWheres;

    this.selectedWhereControl = new FormControl("");

    this.filteredWheres$ = this.selectedWhereControl.valueChanges
      .pipe(
        startWith(''),
        map(value => {
          if (typeof (value) === "string") {
            return this._filterWheres(value);
          }
          else {
            this.addSelectedWhere(value);
            return this.allWheres;
          }
        })
    );
  }

  public displayWhere(where: TaskWhereData): string {
    return '';
  }

  public blurAutocomplete() {
    this.multiselectInput.nativeElement.blur();
  }

  private _filterWheres(value: string): TaskWhereData[] {
    let valueParam: string = value.toLowerCase();
    return this.allWheres.filter(a => a.referenceName.toLowerCase().indexOf(valueParam) > -1 || a.typeDescription.toLowerCase().indexOf(valueParam) > -1 );
  }

  ngOnChanges(changes: SimpleChanges): void {
  }

  private _wheres: TaskWhereData[] = [];
  isDisabled: boolean = false;
  onChange = (_: any) => { }; // Called on a value change
  onTouched = () => { }; // Called if you care if the form was touched
  onValidatorChange = () => { }; // Called on a validator change or re-validation;

  get value(): TaskWhereData[] {
    return this._wheres;
  }

  set value(newValue: TaskWhereData[]) {
    this._wheres = newValue;
    this.onChange(this._wheres);
    this.onValidatorChange();
    this.selectedWheres$.next(newValue);
  }

  addSelectedWhere(where: TaskWhereData): void {
    let existingWhereIndex: number = this._wheres.findIndex(w => w.typeKey === where.typeKey && w.referenceId === where.referenceId);

    if (existingWhereIndex > -1) {
      this._wheres.splice(existingWhereIndex, 1, where);
    }
    else {
      this._wheres.push(where);
    }

    this.value = this._wheres;
  }

  removeSelectedWhere(where: TaskWhereData): void {
    let whereIndex: number = this._wheres.findIndex(w => w.typeKey === where.typeKey && w.referenceId === where.referenceId);
    this._wheres.splice(whereIndex, 1);
    this.value = this._wheres;
  }

  // Writes a new value to the element -> from FormControl to the DOM
  // When FormControl is instantiated, setValue or patchValue
  writeValue(obj: any): void {
    this._wheres = obj;
  }

  registerOnChange(fn: any): void {
    this.onChange = fn;
  }

  registerOnTouched(fn: any): void {
    this.onTouched = fn;
  }

  registerOnValidatorChange?(fn: () => void): void {
    this.onValidatorChange = fn;
  }

  setDisabledState?(isDisabled: boolean): void {
    this.isDisabled = isDisabled;
  }

  validate(control: AbstractControl): ValidationErrors | null {
    let valid = true;

    if (this.isRequired) {
      if (!!this._wheres && this._wheres.length > 0) {
        this._wheres.forEach(yourEntry => valid = valid && !!yourEntry); // Perform here your single item validation
      }
    }
    //else {
    //  valid = !this.isRequired;
    //}

    this.isValid$.next(valid);
    return valid ? null : { invalid: true };
  }
}
