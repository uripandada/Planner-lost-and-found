import { ChangeDetectionStrategy, Component, EventEmitter, Input, OnInit, Output, SimpleChanges } from '@angular/core';
import { FormBuilder, FormControl, FormGroup, Validators } from '@angular/forms';
import { ActivatedRoute } from '@angular/router';
import { ToastrService } from 'ngx-toastr';
import { BehaviorSubject, Subscription } from 'rxjs';
import {
  ExperienceCategoryGridItemViewModel,
  ExperienceDetailsViewModel,
  ExperienceManagementClient,
  ExperienceCategoryManagementClient,
  ExperienceCompensationManagementClient,
  ExtendedWhereData,
  HotelItemData,
  InsertExperienceCommand,
  TaskWhereData,
  GetListOfExperienceCategoriesQuery,
  GetPageOfExperienceCategoriesQuery,
  GetListExperienceCompensationsQuery,
  UpdateExperienceCommand,
} from 'src/app/core/autogenerated-clients/api-client';
import { HotelService } from '../../core/services/hotel.service';
import {Observable} from 'rxjs';
import {map, startWith} from 'rxjs/operators';
import { Select2OptionData } from 'ng-select2';
import { CurrencyPipe } from '@angular/common';
import moment from 'moment';
@Component({
  selector: 'app-add-edit-experience',
  templateUrl: './add-edit-experience.component.html',
  styleUrls: ['./add-edit-experience.component.scss'],
  changeDetection: ChangeDetectionStrategy.OnPush
})
export class AddEditExperienceComponent implements OnInit {

  @Input() item: ExperienceDetailsViewModel;
  @Input() allWheres: Array<TaskWhereData> = [];
  @Input() allCategories: Array<ExperienceCategoryGridItemViewModel> = [];
  @Output() reloadList: EventEmitter<boolean> = new EventEmitter<boolean>();
  @Output() cancelled: EventEmitter<boolean> = new EventEmitter<boolean>();

  myControl = new FormControl();
  options: string[] = ['NAME1', 'NAME2', 'NAME3', 'NAME4', 'NAME5'];
  filteredOptions: Observable<string[]>;

  public experienceCategory: Array<Select2OptionData>;
  public compensation: Array<Select2OptionData>;

  foundForm: FormGroup;

  categoriesList: BehaviorSubject<any[]> = new BehaviorSubject<any[]>(null);
  compensationList: BehaviorSubject<any[]> = new BehaviorSubject<any[]>(null);

  solveStatuses: Array<{ key: number, value: string }> = [];
  clientStatuses: Array<{ key: number, value: string }> = [];
  solveStatuses1: Array<{ key: number, value: string }> = [];

  solveStatusMappings: { [index: number]: string } = {};
  clientStatusMappings: { [index: number]: string } = {};
  solveStatusMappings1: { [index: number]: string } = {};

  statusChange$: Subscription;
  statusFlag: number;

  selectedSolveStatus: string;
  selectedClientStatus: string;

  isSolveStatus: boolean;
  isClientStatus: boolean;
  isSolveStatus1: boolean;

  hotels: HotelItemData[] = [];

  public isCreateNew = true;
  constructor(
    private formBuilder: FormBuilder,
    private toastr: ToastrService,
    private _route: ActivatedRoute,
    private experienceClient: ExperienceManagementClient,
    private experienceCategoryClient: ExperienceCategoryManagementClient,
    private experienceCompensationClient: ExperienceCompensationManagementClient,
    public hotelService: HotelService,
    private currencyPipe: CurrencyPipe
  ) {

    this.solveStatuses.push({ key: 1, value: "Pending" });

    this.clientStatuses.push({ key: 1, value: "No client action" });
    this.clientStatuses.push({ key: 2, value: "Meet with client" });
    this.clientStatuses.push({ key: 3, value: "Meet with Client at C/O(avecArchiveiuto)" });

    this.solveStatuses1.push({ key: 1, value: "Resolved" });
    this.solveStatuses1.push({ key: 2, value: "Closed" });

    this.hotels = hotelService.getHotels();
  }


  ngOnInit(): void {
    this.experienceCategoryClient.getPageOfExperienceCategories(new GetPageOfExperienceCategoriesQuery({ skip: 0, take: 2000 })).subscribe(response => {
      this.experienceCategoryClient.getList(new GetListOfExperienceCategoriesQuery({name : ""})).subscribe(data => {
        this.experienceCategory = [];
        data?.map(parent => {
          var children = [];
          response.items?.map(category => {
            if (category.name == parent.name) {
              children.push({id: category.id, text: parent.name + " - " + category.experienceName})
            }
          })
          this.experienceCategory.push({
            id: "0",
            text: parent.name,
            children: children
          })
        })

        this.categoriesList.next(this.experienceCategory);
      })
    })

    this.experienceCompensationClient.getList(new GetListExperienceCompensationsQuery({take:0, skip: 0})).subscribe(response => {
      this.compensation = [];
      response.items?.map(compensation => {
        this.compensation.push({
          id: compensation.id,
          text: compensation.name + " - " + this.currencyPipe.transform(compensation.price, compensation.currency)
        })
      })
      this.compensationList.next(this.compensation)
    })

    this.filteredOptions = this.myControl.valueChanges.pipe(
      startWith(''),
      map(value => this._filter(value)),
    );

    this.allWheres = this._route.snapshot.data.allWheres;
    this.allCategories = this._route.snapshot.data.allCategories;
    this.initForm();

  }

  private _filter(value: string): string[] {
    const filterValue = value.toLowerCase();

    return this.options.filter(option => option.toLowerCase().includes(filterValue));
  }

  ngOnChanges(changes: SimpleChanges): void {
    if (this.item.id) {
      this.isCreateNew = false;

    } else {
      this.isCreateNew = true;
    }

    if (!changes.item.firstChange) {
      this.setFormData();
    }
  }

  solveStatusSelectChanged() {
    this.isSolveStatus = true;
    this.isClientStatus = false;
    this.isSolveStatus1 = false;
  }

  clientStatusSelectChanged() {
    this.isSolveStatus = true;
    this.isClientStatus = true;
    this.isSolveStatus1 = false;
  }

  solveStatusSelectChanged1(value:any) {
    if ( value == this.solveStatuses1[0].key) {
      this.isSolveStatus = true;
      this.isClientStatus = true;
      this.isSolveStatus1 = false;
    }else {
      this.isSolveStatus = true;
      this.isClientStatus = true;
      this.isSolveStatus1 = true;
    }
  }

  initForm() {
    this.foundForm = this.formBuilder.group({
      hotelId: [this.item.id],
      guestName: [this.item.guestName],
      roomName: [this.item.roomName],
      checkIn: [this.item.checkIn?.format('yyyy-MM-DD')] ,
      checkOut: [this.item.checkOut?.format('yyyy-MM-DD')],
      reservationId: [this.item.reservationId],
      vip: [this.item.vip],
      experienceEmail: [this.item.email],
      experiencePhoneNumber: [this.item.phoneNumber],
      experienceType: [this.item.type],
      experienceCategory: [this.item.experienceCategoryId],
      actions: [this.item.actions],
      internalFollowUp: [this.item.internalFollowUp],
      compensationName: [this.item.experienceCompensationId],
      description: [this.item.description],
      solveStatus: [1],
      clientStatus: [1],
      solveStatus1: [1],
      group: [""]
    });

  }

  setFormData() {
    this.isSolveStatus = true;
    this.isClientStatus = true;

    this.foundForm.controls.guestName.setValue(this.item.guestName);
    this.foundForm.controls.roomName.setValue(this.item.roomName);
    this.foundForm.controls.checkIn.setValue(this.item.checkIn?.format('yyyy-MM-DD'));
    this.foundForm.controls.checkOut.setValue(this.item.checkOut?.format('yyyy-MM-DD'));
    this.foundForm.controls.reservationId.setValue(this.item.reservationId);
    this.foundForm.controls.vip.setValue(this.item.vip);
    this.foundForm.controls.experienceEmail.setValue(this.item.email);
    this.foundForm.controls.experiencePhoneNumber.setValue(this.item.phoneNumber);
    this.foundForm.controls.description.setValue(this.item.description);
    this.foundForm.controls.actions.setValue(this.item.actions);
    this.foundForm.controls.internalFollowUp.setValue(this.item.internalFollowUp);
    this.foundForm.controls.compensationName.setValue(this.item.experienceCompensationId);
    this.foundForm.controls.experienceCategory.setValue(this.item.experienceCategoryId);
    this.foundForm.controls.experienceType.setValue(this.item.type);
  }

  get f() {
    return this.foundForm.controls;
  }

  save() {
    this.foundForm.markAsTouched({ onlySelf: false });
    if (this.foundForm?.invalid) {
      this.toastr.error("You have to fix invalid form fields before you can continue.");
      return;
    }

    let formValues = this.foundForm.getRawValue();

    let insertRequest = new InsertExperienceCommand({
      guestName: formValues.guestName,
      roomName: formValues.roomName,
      checkIn: moment.utc(formValues.checkIn),
      checkOut: moment.utc(formValues.checkOut),
      reservationId: formValues.reservationId,
      vip: formValues.vip,
      email: formValues.experienceEmail,
      phoneNumber: formValues.experiencePhoneNumber,
      type: formValues.experienceType,
      experienceCategoryId: formValues.experienceCategory,
      actions: formValues.actions,
      internalFollowUp: formValues.internalFollowUp,
      experienceCompensationId: formValues.compensationName,
      description: formValues.description,
    });

    if (this.item.id === null) {

      this.experienceClient.insertExperience(insertRequest).subscribe(
        response => {
          if (response.isSuccess) {
            this.toastr.success(response.message);
            this.reloadList.next(true);
          } else {
            this.toastr.error(response.message);
          }
        },
        error => {
          this.toastr.error(error);
        }
      );
    } else {
      let updateRequest = null;
      updateRequest = new UpdateExperienceCommand({
        id: this.item.id,
        ...insertRequest
      });
      this.experienceClient.updateExperience(updateRequest).subscribe(
        response => {
          if (response.isSuccess) {
            this.toastr.success(response.message);
            this.reloadList.next(true);
          } else {
            this.toastr.error(response.message);
          }
        },
        error => {
          this.toastr.error(error);
        }
      );
    }

  }


  cancel() {
    this.cancelled.next(true);
  }

  public canShowErrorMessage(control: string,): boolean {
    const foundForm = this.foundForm as FormGroup;
    if (foundForm.controls[control]) {
      return !!(
        (foundForm.controls[control].touched || foundForm.touched) &&
        foundForm.controls[control].errors
      );
    } else {
      return false;
    }
  }

  getSelection(data: ExtendedWhereData) {
  }

  ngOnDestroy(): void {
    if (this.statusChange$) this.statusChange$.unsubscribe();
  }

}
