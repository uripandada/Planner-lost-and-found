import { ApplicationRef, ComponentFactoryResolver, EmbeddedViewRef, EventEmitter, Injectable, Injector } from "@angular/core";
import moment, { Moment } from 'moment';
import { ToastrService } from 'ngx-toastr';
import { DataItemCollectionType,  TimelineOptions, VisTimelineService } from 'ngx-vis';
import { BehaviorSubject } from 'rxjs';
import { DateType, IdType, TimelineAlignType, TimelineGroup, TimelineItemEditableType, TimelineItemType } from 'vis';
import { TimelineItem, TimelineTimeAxisScaleType } from 'vis-timeline';
import { CleaningTimelineGroupComponent } from '../../cleaning-plan/cleaning-timeline-group/cleaning-timeline-group.component';
import { CleaningTimelineItemComponent } from '../../cleaning-plan/cleaning-timeline-item/cleaning-timeline-item.component';
import { DateHelper } from '../../shared/helpers/date.helper';
import { MomentDateHelper } from "../../shared/helpers/moment-date.helper";
import { AddCleaningPlanItem, AddCleaningPlanItemsCommand, Cleaning, CleaningPlanClient, CleaningProcessStatus, CleaningTimelineItemData, ICleaningTimelineGroupData, IPlannedCleaningTimelineItemData, PlannedCleaningTimelineItemData, ProcessResponse, ProcessResponseOfUpdateCleaningPlanItemsResult, RealTimeCleaningPlannerCleaningChangedMessage, RemoveCleaningPlanItemsCommand, UpdateCleaningPlanItem, UpdateCleaningPlanItemsCommand } from '../autogenerated-clients/api-client';
import { CleaningTimelineTooltipService } from './cleaning-timeline-tooltip.service';
import { LoadingService } from './loading.service';

export class CleaningTimelineItem implements TimelineItem {
  className?: string;
  align?: TimelineAlignType;
  //content: string | any;
  content: string | PlannedCleaningTimelineItemData | any;
  end?: DateType;
  group?: IdType;
  id: IdType;
  start: DateType;
  style?: string;
  subgroup?: IdType;
  title?: string;
  type?: TimelineItemType;
  editable?: TimelineItemEditableType;
  selectable?: boolean;
}
export interface CleaningTimelineGroup extends TimelineGroup {
  groupData: ICleaningTimelineGroupData;
  treeLevel: number;

  numberOfArrivals$: BehaviorSubject<number>;
  numberOfDepartures$: BehaviorSubject<number>;
  numberOfStays$: BehaviorSubject<number>;
  numberOfTasks$: BehaviorSubject<number>;
  totalCredits$: BehaviorSubject<number>;
}

export class ItemsAddedEventData {
  
  itemIdsToRemove: Array<string> = [];
  cleaningsToAdd: Array<PlannedCleaningTimelineItemData> = [];

}

export class DragDropTimelineItem {
  //cleaning: PlannedCleaningTimelineItemData,
  clientX: number;
  content: PlannedCleaningTimelineItemData;
  doInsertItem: boolean;
  start: Date;
  end: Date;
  group: string;
  id: string;
  type: "range";
}

@Injectable({ providedIn: 'root' })
export class CleaningTimelineService {

  timelineId: string = "cleaning-planner-timeline-1";
  timelineOptions: TimelineOptions;

  public pixelsPerMinute$: BehaviorSubject<number> = new BehaviorSubject<number>(0);

  public itemsAddedSuccess: EventEmitter<ItemsAddedEventData> = new EventEmitter<ItemsAddedEventData>();
  public itemsMovedSuccess: EventEmitter<PlannedCleaningTimelineItemData[]> = new EventEmitter<PlannedCleaningTimelineItemData[]>();
  public itemsRemovedSuccess: EventEmitter<PlannedCleaningTimelineItemData[]> = new EventEmitter<PlannedCleaningTimelineItemData[]>();

  private _isInitialized: boolean = false;
  private _isDestroying: boolean = false;
  private _timelineNativeElement: any = null;
  private _planId: string = "";
  private _plannedItems: Array<CleaningTimelineItem> = [];
  private _minutesPerCredit: number;

  constructor(
    private _visTimelineService: VisTimelineService,
    private _componentFactoryResolver: ComponentFactoryResolver,
    private _injector: Injector,
    private _applicationRef: ApplicationRef,
    private _tooltipService: CleaningTimelineTooltipService,
    private _cleaningPlanClient: CleaningPlanClient,
    private _loading: LoadingService,
    private _toastr: ToastrService) {
  }

  initialize(timelineNativeElement: any, groups: Array<any>, items: Array<any>, minutesPerCredit: number) {
    if (this._isInitialized) return;

    this._isInitialized = true;
    this._timelineNativeElement = timelineNativeElement;
    this._minutesPerCredit = minutesPerCredit === 0 ? 1 : minutesPerCredit;

    const minDate = DateHelper.today;
    const maxDate = DateHelper.addDays(minDate, 1);
    const displayedFromDate = DateHelper.addHours(minDate, 8);
    const displayedToDate = DateHelper.addHours(displayedFromDate, 8);


    this.timelineOptions = {
      min: minDate,
      max: maxDate,
      start: displayedFromDate,
      end: displayedToDate,
      zoomMin: 1 * 3600 * 1000,
      timeAxis: { scale: <TimelineTimeAxisScaleType>'minute', step: 60 },
      showMajorLabels: false,
      showMinorLabels: true,
      stack: false,
      orientation: {
        axis: 'both',
        item: 'top'
      },
      itemsAlwaysDraggable: {
        item: true,
        range: true
      },
      selectable: true,
      editable: true,
      verticalScroll: true,
      zoomKey: 'ctrlKey',
      maxHeight: '100%',
      groupHeightMode: 'auto',
      snap: CleaningTimelineService._snap,
      format: { minorLabels: { hour: 'HH:mm' } },
      multiselect: true,
      multiselectPerGroup: true,
      margin: {
        axis: 1,
        item: {
          horizontal: 4,
          vertical: 2
        }
      },
      onAdd: (item: CleaningTimelineItem, callback: (item: CleaningTimelineItem | null) => void) => this.onAdd(item, callback),
      onMove: (item: CleaningTimelineItem, callback: (item: CleaningTimelineItem | null) => void) => this.onMove(item, callback),
      onRemove: (item: CleaningTimelineItem, callback: (item: CleaningTimelineItem | null) => void) => this.onRemove(item, callback),
      template: (item: CleaningTimelineItem, element, data) => item.content ? this.createItemComponent(item) : item.content,
      groupTemplate: (group: CleaningTimelineGroup, element, data) => this.createGroupComponent(group),
    };
    
    this._visTimelineService.createWithItemsAndGroups(this.timelineId, this._timelineNativeElement, <TimelineItem[]>items, <TimelineGroup[]>groups, this.timelineOptions);
    this._plannedItems = items;

    this._visTimelineService.on(this.timelineId, 'rangechanged');
    this._visTimelineService.rangechanged.subscribe((properties) => this.onRangeChanged(properties[1].start, properties[1].end));

    this._visTimelineService.on(this.timelineId, 'itemover');
    this._visTimelineService.itemover.subscribe((properties) => this.onItemOver(properties));

    this._visTimelineService.on(this.timelineId, 'itemout');
    this._visTimelineService.itemout.subscribe((properties) => this.onItemOut(properties));

    //this._visTimelineService.on(this.timelineId, 'dragover');
    //this._visTimelineService.dragover.subscribe((properties) => this.onItemOut(properties));
  }

  destroy() {
    this._visTimelineService.off(this.timelineId, 'rangechanged');
    this._visTimelineService.off(this.timelineId, 'itemover');
    this._visTimelineService.off(this.timelineId, 'itemout');
    this._visTimelineService.destroy(this.timelineId);
    this._isInitialized = false;
  }

  setPlanId(id: string) {
    this._planId = id;
  }

  setPlannedItems(plannedCleanings: Array<any>) {
    let existingPlannedItems = this._plannedItems;
    let itemsToAdd = [];

    this._plannedItems = plannedCleanings.map(c => {
      let timelineItem = <CleaningTimelineItem>{
        content: c,
        id: c.id,
        start: new Date(c.start),
        align: "auto",
        editable: true,
        end: new Date(c.end),
        group: c.cleaningPlanGroupId,
        selectable: true,
        title: c.title,
        type: "range",
      };

      c.start = moment(c.start);
      c.end = moment(c.end);

      itemsToAdd.push(timelineItem);

      return timelineItem;
    });

    itemsToAdd = [...existingPlannedItems.filter(i => i.type !== "range"), ...itemsToAdd];

    this._visTimelineService.setItems(this.timelineId, []);
    this._visTimelineService.setItems(this.timelineId, itemsToAdd);
    this._visTimelineService.redraw(this.timelineId);
  }


  addPlannedCleanings(plannedCleanings: Array<PlannedCleaningTimelineItemData>) {
    let existingTimelineItems: CleaningTimelineItem[] = [...this._plannedItems];
    this._setPlannedItems(existingTimelineItems, plannedCleanings);
  }

  setPlannedCleanings(plannedCleanings: Array<PlannedCleaningTimelineItemData>) {
    let rangeType: TimelineItemType = "range";
    let nonCleaningTimelineItems = this._plannedItems.filter(i => i.type !== rangeType);

    this._setPlannedItems(nonCleaningTimelineItems, plannedCleanings);
  }

  private _setPlannedItems(existingTimelineItems: CleaningTimelineItem[], plannedCleanings: PlannedCleaningTimelineItemData[]) {
    let align: TimelineAlignType = "auto";
    let type: TimelineItemType = "range";

    let plannedCleaningTimelineItems = plannedCleanings.map(plannedCleaning => {
      plannedCleaning.start = moment(plannedCleaning.start);
      plannedCleaning.end = moment(plannedCleaning.end);

      let cleaningTimelineItem: CleaningTimelineItem = {
        id: plannedCleaning.id,
        title: plannedCleaning.title,
        group: plannedCleaning.cleaningPlanGroupId,
        start: plannedCleaning.start.toDate(),
        end: plannedCleaning.end.toDate(),
        content: plannedCleaning,
        editable: true,
        selectable: true,
        align: align,
        type: type,
      };
      return cleaningTimelineItem;
    });

    let allTimelineItems = [...existingTimelineItems, ...plannedCleaningTimelineItems];
    this._plannedItems = [...allTimelineItems];

    this._visTimelineService.setItems(this.timelineId, []);
    this._visTimelineService.setItems(this.timelineId, allTimelineItems);
    this._visTimelineService.redraw(this.timelineId);
  }

  // Returns only planned cleanings
  getPlannedItems(): Array<PlannedCleaningTimelineItemData> {
    let items = this._plannedItems.map(i => i.content).filter(ti => ti instanceof PlannedCleaningTimelineItemData).filter(ti => (<PlannedCleaningTimelineItemData>ti).itemTypeKey === "CLEANING");
    return items;
  }

  // Returns all timeline items including backgrounds, tasks, etc...
  getTimelineItems(): Array<CleaningTimelineItem> {
    return this._plannedItems;
  }

  resetPlannedItems() {
    let itemsToAdd = [...this._plannedItems.filter(i => i.type !== "range")];

    this._plannedItems = itemsToAdd;
    this._visTimelineService.setItems(this.timelineId, []);
    this._visTimelineService.setItems(this.timelineId, itemsToAdd);
    this._visTimelineService.redraw(this.timelineId);
  }

  onDeleteAndReloadCleaningPlan(plannedItems: PlannedCleaningTimelineItemData[]) {
    this.setPlannedItems(plannedItems);
  }

  onRealTimeCleaningsChanged(messages: Array<RealTimeCleaningPlannerCleaningChangedMessage>) {
    console.log("REAL TIME CLEANINGS CHANGED");

    let itemUpdated = false;
    let items = [...this._plannedItems];

    for (let message of messages) {
      if (message.cleaningPlanId !== this._planId) continue; // incorrect cleaning plan

      let plannedItem = items.find(pi => pi.id === message.cleaningPlanItemId);

      if (!plannedItem)
        continue;

      plannedItem.content.cleaningStatus = message.cleaningProcessStatus;
      (<PlannedCleaningTimelineItemData>plannedItem.content).isDoNotDisturb = message.cleaningProcessStatus === CleaningProcessStatus.DO_NOT_DISTURB;
      (<PlannedCleaningTimelineItemData>plannedItem.content).isInspected = message.cleaningProcessStatus === CleaningProcessStatus.INSPECTION_FINISHED;
      itemUpdated = true;
      if (message.cleaningProcessStatus === CleaningProcessStatus.FINISHED) {
        plannedItem.content.isClean = true;
      }
    }

    if (itemUpdated) {
      this._visTimelineService.setItems(this.timelineId, []);
      this._visTimelineService.setItems(this.timelineId, items);
      this._visTimelineService.redraw(this.timelineId);
    }
  }

  setPlannedGroups(plannedGroups: Array<CleaningTimelineGroup>) {
    this._visTimelineService.setGroups(this.timelineId, [...plannedGroups]);
  }

  setData(date: Moment, plannedGroups: Array<CleaningTimelineGroup>, plannedCleanings: Array<CleaningTimelineItem>) {
    const minDate = date.clone();
    const maxDate = date.clone().add(1, 'days');
    const displayedFromDate = minDate.clone().add(8, 'hours');
    const displayedToDate = minDate.clone().add(16, 'hours');

    this._plannedItems = plannedCleanings;
    this._visTimelineService.setOptions(this.timelineId, {
      min: minDate.toDate(),
      max: maxDate.toDate(),
      start: displayedFromDate.toDate(),
      end: displayedToDate.toDate(),
    });
    this._visTimelineService.setData(this.timelineId, { groups: plannedGroups, items: plannedCleanings });
  }

  onCleaningPlanSuccessfullySent() {
    let items = [];
    for (let item of this._plannedItems) {
      if (item.type === "range") { // || item.type === "point") {
        //item.editable = false;
        item.content.isSent = true;
      }
      items.push(item);
    }
    this._visTimelineService.setItems(this.timelineId, []);
    this._visTimelineService.setItems(this.timelineId, items);
    this._visTimelineService.redraw(this.timelineId);
  }

  lockSentCleanings() {
    //this._toggleSentCleaningsLockedStatus(true);
  }

  unlockSentCleanings() {
    //this._toggleSentCleaningsLockedStatus(false);
  }

  private _toggleSentCleaningsLockedStatus(isLocked: boolean) {
    let items = [];
    for (let item of this._plannedItems) {
      if (item.type === "range" && item.content.isSent) { // || item.type === "point") {
        item.editable = !isLocked;
      }
      items.push(item);
    }
    this._visTimelineService.setItems(this.timelineId, []);
    this._visTimelineService.setItems(this.timelineId, items);
    this._visTimelineService.redraw(this.timelineId);
  }

  private onAdd(itemData: any, callback: (item: CleaningTimelineItem | null) => void) {
    this._loading.start();

    let minutes = (<Date>itemData.start).getMinutes() - (<any>itemData).clientX / this.pixelsPerMinute$.value;
    //minutes += 8;
    minutes -= minutes % 15;
    (<Date>itemData.start).setMinutes(minutes);
    itemData.end = new Date(<Date>itemData.start);

    let plannableCleanings: CleaningTimelineItemData[] = itemData.content;
    let plannedTimelineItems: DragDropTimelineItem[] = [];

    let nextCleaningStart = new Date(itemData.start);

    for (let c of plannableCleanings) {
      let start = new Date(nextCleaningStart);
      let end = new Date(start);

      let durationMinutes: number = (c.credits ?? 0) * this._minutesPerCredit;
      end.setMinutes(end.getMinutes() + durationMinutes);

      // This line is just preparation for the next loop iteration
      let timeBetweenCleanings = 5;
      nextCleaningStart = new Date(end);
      nextCleaningStart.setMinutes(nextCleaningStart.getMinutes() + timeBetweenCleanings);
      
      let plannedTimelineItem: DragDropTimelineItem = {
        clientX: itemData.clientX,
        doInsertItem: itemData.doInsertItem,
        end: end,
        start: start,
        group: itemData.group,
        id: c.id,
        type: itemData.type,
        content: new PlannedCleaningTimelineItemData({
          id: c.id,
          roomId: c.roomId,
          title: c.title,

          isActive: c.isActive,
          isCustom: c.isCustom,
          cleaningPluginId: c.cleaningPluginId,
          cleaningPluginName: c.cleaningPluginName,

          cleaningPlanGroupId: itemData.group,
          end: moment(end),
          start: moment(start),
          
          isPostponed: c.isPostponed,
          isClean: c.isClean,
          isDoNotDisturb: c.isDoNotDisturb,
          isOccupied: c.isOccupied,
          isOutOfOrder: c.isOutOfOrder,
          isRoomAssigned: c.isRoomAssigned,
          reservations: c.reservations || [],
          tasks: c.tasks || [],
          itemTypeKey: c.itemTypeKey,
          taskDescription: c.taskDescription,
          credits: c.credits,
          isTaskGuestRequest: c.isTaskGuestRequest,
          isTaskHighPriority: c.isTaskHighPriority,
          isTaskLowPriority: c.isTaskLowPriority,
          price: c.price,

          isChangeSheets: c.isChangeSheets,
          cleaningDescription: c.cleaningDescription,
          //reservationStatuses: c.reservationStatuses,

          buildingId: c.buildingId,
          floorId: c.floorId,
          buildingName: c.buildingName,
          floorName: c.floorName,
          floorSectionName: c.floorSectionName,
          floorSubSectionName: c.floorSubSectionName,

          areaId: c.areaId,
          areaName: c.areaName,
          floorNumber: c.floorNumber,
          hotelId: c.hotelId,
          hotelName: c.hotelName,

          hasArrival: c.hasArrival,
          hasDeparture: c.hasDeparture,
          hasStay: c.hasStay,
          hasVipReservation: c.hasVipReservation,
          roomCategoryId: c.roomCategoryId,
          roomCategoryName: c.roomCategoryName,

          cleaningStatus: c.cleaningStatus,
          isInspected: c.isInspected,
          isInspectionRequired: c.isInspectionRequired,
          isInspectionSuccess: c.isInspectionSuccess,
          isReadyForInspection: c.isReadyForInspection,
          isSent: c.isSent,
          inspectedByFullName: c.inspectedByFullName,
          inspectedById: c.inspectedById,
          isPriority: c.isPriority,
          vipValues: c.vipValues,
          bedId: c.bedId,
          plannedAttendantTasks: c.plannedAttendantTasks,

          isFilteredOut: false
        }),
      };

      plannedTimelineItems.push(plannedTimelineItem);
    }

    let itemIdsToRemove = []; // plannedTimelineItems.map(i => i.content.id);
    let cleaningsToAdd = []; // plannedTimelineItems.map(i => i.content);
    var itemsToInsert = plannedTimelineItems.filter(pti => pti.doInsertItem);

    if (itemsToInsert.length) {
      let request: AddCleaningPlanItemsCommand = new AddCleaningPlanItemsCommand({
        cleaningPlanId: this._planId,
        cleanings: itemsToInsert.map(i => {
          return new AddCleaningPlanItem({
            cleaningPlanGroupId: i.content.cleaningPlanGroupId,
            endString: MomentDateHelper.getIsoDateTime(moment(i.content.end)),
            startString: MomentDateHelper.getIsoDateTime(moment(i.content.start)),
            id: i.content.id,
          });
        })
      });

      this._cleaningPlanClient.addCleaningPlanItems(request).subscribe(
        (response: ProcessResponse) => {
          if (response.hasError) {
            this._toastr.error(response.message);
            return;
          }

          for (let pti of plannedTimelineItems) {
            callback(pti);
            itemIdsToRemove.push(pti.content.id);
            cleaningsToAdd.push(pti.content);
          }

          this._plannedItems = [...this._plannedItems, ...plannedTimelineItems];
          this.itemsAddedSuccess.next({ cleaningsToAdd: cleaningsToAdd, itemIdsToRemove: itemIdsToRemove });
        },
        (error: Error) => {
          this._toastr.error(error.message);
        },
        () => {
          this._loading.stop();
        }
      );
    }
    else {
      for (let pti of plannedTimelineItems) {
        callback(itemData);
        itemIdsToRemove.push(pti.content.id);
        cleaningsToAdd.push(pti.content);
      }

      this._plannedItems = [...this._plannedItems, ...plannedTimelineItems];
      this._loading.stop();
      this.itemsAddedSuccess.next({ cleaningsToAdd: cleaningsToAdd, itemIdsToRemove: itemIdsToRemove });
    }
  }

  private onMove(item: any, callback: (item: TimelineItem | null) => void) {
    this._loading.start();

    let cleaning: IPlannedCleaningTimelineItemData = item.content;
    let updateRequest: UpdateCleaningPlanItemsCommand = new UpdateCleaningPlanItemsCommand({
      cleaningPlanId: this._planId,
      items: [
        new UpdateCleaningPlanItem({
          cleaningPlanGroupId: item.group,
          endString: MomentDateHelper.getIsoDateTime(moment(item.end)),
          id: cleaning.id,
          roomId: cleaning.roomId,
          startString: MomentDateHelper.getIsoDateTime(moment(item.start)),
        })
      ]
    });

    this._cleaningPlanClient.updateCleaningPlanItems(updateRequest).subscribe(
      (response: ProcessResponseOfUpdateCleaningPlanItemsResult) => {
        if (response.hasError) {
          this._toastr.error(response.message);
          return;
        }

        callback(item);

        let movedItems: Array<PlannedCleaningTimelineItemData> = updateRequest.items.map(i => new PlannedCleaningTimelineItemData({
          end: moment(i.endString),
          isPostponed: cleaning.isPostponed,
          start: moment(i.startString),
          cleaningPlanGroupId: i.cleaningPlanGroupId,
          
          id: i.id,
          roomId: cleaning.roomId,
          title: cleaning.title,
          isClean: cleaning.isClean,
          isDoNotDisturb: cleaning.isDoNotDisturb,
          isOccupied: cleaning.isOccupied,
          isOutOfOrder: cleaning.isOutOfOrder,
          isRoomAssigned: cleaning.isRoomAssigned,
          reservations: cleaning.reservations || [],
          tasks: cleaning.tasks || [],
          credits: cleaning.credits,
          isTaskGuestRequest: cleaning.isTaskGuestRequest,
          isTaskHighPriority: cleaning.isTaskHighPriority,
          isTaskLowPriority: cleaning.isTaskLowPriority,
          price: cleaning.price,
          isActive: cleaning.isActive,
          isCustom: cleaning.isCustom,
          cleaningPluginId: cleaning.cleaningPluginId,
          cleaningPluginName: cleaning.cleaningPluginName,
          itemTypeKey: cleaning.itemTypeKey,
          taskDescription: cleaning.taskDescription,
          isChangeSheets: cleaning.isChangeSheets,
          cleaningDescription: cleaning.cleaningDescription,

          buildingId: cleaning.buildingId,
          floorId: cleaning.floorId,
          buildingName: cleaning.buildingName,
          floorName: cleaning.floorName,
          floorSectionName: cleaning.floorSectionName,
          floorSubSectionName: cleaning.floorSubSectionName,

          areaId: cleaning.areaId,
          areaName: cleaning.areaName,
          floorNumber: cleaning.floorNumber,
          hotelId: cleaning.hotelId,
          hotelName: cleaning.hotelName,

          hasArrival: cleaning.hasArrival,
          hasDeparture: cleaning.hasDeparture,
          hasStay: cleaning.hasStay,
          hasVipReservation: cleaning.hasVipReservation,
          roomCategoryId: cleaning.roomCategoryId,
          roomCategoryName: cleaning.roomCategoryName,

          cleaningStatus: cleaning.cleaningStatus,
          isInspected: cleaning.isInspected,
          isInspectionRequired: cleaning.isInspectionRequired,
          isInspectionSuccess: cleaning.isInspectionSuccess,
          isReadyForInspection: cleaning.isReadyForInspection,
          isSent: cleaning.isSent,
          inspectedByFullName: cleaning.inspectedByFullName,
          inspectedById: cleaning.inspectedById,
          isPriority: cleaning.isPriority,
          bedId: cleaning.bedId,
          vipValues: cleaning.vipValues,
          plannedAttendantTasks: cleaning.plannedAttendantTasks || [],

          isFilteredOut: cleaning.isFilteredOut,
        }));

        // Find the item and update start/end times
        for (let item of movedItems) {
          let plannedItem = this._plannedItems.find(pi => pi.id === item.id);
          plannedItem.start = item.start.toDate();
          plannedItem.end = item.end.toDate();
          plannedItem.group = item.cleaningPlanGroupId;
        }

        this.itemsMovedSuccess.next(movedItems);
      },
      (error: Error) => { this._toastr.error(error.message); },
      () => { this._loading.stop(); }

    );

  }

  private onRemove(item: any, callback: (item: TimelineItem | null) => void) {
    this._loading.start();

    let cleaning: IPlannedCleaningTimelineItemData = item.content;
    let removeRequest: RemoveCleaningPlanItemsCommand = new RemoveCleaningPlanItemsCommand({
      ids: [cleaning.id],
    });
    this._cleaningPlanClient.removeCleaningPlanItems(removeRequest).subscribe(
      (response: ProcessResponse) => {
        if (response.hasError) {
          this._toastr.error(response.message);
          return;
        }

        callback(item);

        let removed: Array<PlannedCleaningTimelineItemData> = [new PlannedCleaningTimelineItemData(item.content)];

        this._tooltipService.hideTooltip();

        let items = [...this._plannedItems];
        for (let item of removed) {
          items.splice(items.findIndex(i => i.id === item.id), 1);
        }
        this._plannedItems = items;

        this.itemsRemovedSuccess.next(removed);
      },
      (error: Error) => { this._toastr.error(error.message); },
      () => { this._loading.stop(); }

    );
  }

  private createItemComponent(cleaning: CleaningTimelineItem): string {

    if (cleaning === null) {
      return "N/A";
    }

    if (this._isDestroying) {
      return;
    }

    let component = this._componentFactoryResolver.resolveComponentFactory(CleaningTimelineItemComponent).create(this._injector);
    component.instance.data = cleaning.content;

    this._applicationRef.attachView(component.hostView);

    const htmlElement = (component.hostView as EmbeddedViewRef<any>).rootNodes[0] as HTMLElement;
    return <string><any>htmlElement;
  }

  private createGroupComponent(group: CleaningTimelineGroup): string {

    if (group === null) {
      return "N/A";
    }

    if (this._isDestroying) {
      return;
    }

    let component = this._componentFactoryResolver.resolveComponentFactory(CleaningTimelineGroupComponent).create(this._injector);
    component.instance.data = group;

    this._applicationRef.attachView(component.hostView);

    const htmlElement = (component.hostView as EmbeddedViewRef<any>).rootNodes[0] as HTMLElement;
    return <string><any>htmlElement;
  }

  private onRangeChanged(start: Date, end: Date) {
    const displayedTimelineDuration = end.getTime() - start.getTime();
    const timelineWidth = document.getElementsByClassName('vis-content')[0].getClientRects()[0].width;
    this.pixelsPerMinute$.next(timelineWidth * 60 /* seconds */ * 1000 /* miliseconds */ / displayedTimelineDuration)
  }

  private onItemOver(properties) {
    const itemId: string = properties[1].item;
    const item = this._plannedItems.find(i => i.id === itemId);
    if (item) {
      let element = properties[1].event.srcElement;
      if (!properties[1].event.srcElement.classList.contains("vis-item")) {
        element = this._findAncestor(properties[1].event.srcElement, ".vis-item");
      }

      this._tooltipService.showTooltip(item.content, element);
    }
  }

  private onItemOut(properties) {
    this._tooltipService.hideTooltip();
  }

  private _findAncestor(el, sel) {
    while ((el = el.parentElement) && !((el.matches || el.matchesSelector).call(el, sel)));
    return el;
  }

  private static _snap(date: Date, scale: string, step: number): Date {
    return new Date(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), Math.round(date.getMinutes() / 10) * 10);
  }


  moveTimelineLeftRight(percentage: number) {
    let range = this._visTimelineService.getWindow(this.timelineId);
    //let start: Date = range.start;
    //let end: Date = range.end;
    //let interval = end - start;

    let diffMilliseconds = this.dateDiffMilliseconds(range.start, range.end);
    let start = range.start.valueOf() - (diffMilliseconds * percentage);
    let end = range.end.valueOf() - (diffMilliseconds * percentage);

    this._visTimelineService.setWindow(this.timelineId, start, end);
  }

  dateDiffMilliseconds(start:Date, end:Date) {
    // Discard the time and time-zone information.
    const msPerDay = 1000 * 60 * 60 * 24;
    const utc1 = Date.UTC(start.getFullYear(), start.getMonth(), start.getDate(), start.getHours(), start.getMinutes(), start.getSeconds());
    const utc2 = Date.UTC(end.getFullYear(), end.getMonth(), end.getDate(), end.getHours(), end.getMinutes(), end.getSeconds());

    return (utc2 - utc1);
  }

  
  //// attach events to the navigation buttons
  //document.getElementById("zoomIn").onclick = function () {
  //  timeline.zoomIn(0.2);
  //};
  //document.getElementById("zoomOut").onclick = function () {
  //  timeline.zoomOut(0.2);
  //};
  //document.getElementById("moveLeft").onclick = function () {
  //  move(0.2);
  //};
  //document.getElementById("moveRight").onclick = function () {
  //  move(-0.2);
  //};
  //document.getElementById("toggleRollingMode").onclick = function () {
  //  timeline.toggleRollingMode();
  //};
}
