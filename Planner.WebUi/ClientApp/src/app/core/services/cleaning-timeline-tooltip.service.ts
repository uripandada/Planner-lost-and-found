import { ComponentFactoryResolver, ComponentRef, Inject, Injectable, ViewContainerRef } from "@angular/core";
import { CleaningTimelineItemTooltipComponent } from '../../cleaning-plan/cleaning-timeline-item-tooltip/cleaning-timeline-item-tooltip.component';
import { PlannableCleaningTooltipComponent } from "../../cleaning-plan/plannable-cleaning-tooltip/plannable-cleaning-tooltip.component";
import { ICleaningTimelineItemData, IPlannedCleaningTimelineItemData } from '../autogenerated-clients/api-client';

@Injectable({ providedIn: 'root' })
export class CleaningTimelineTooltipService {
  private _rootViewContainerRef: ViewContainerRef;
  private _component: ComponentRef<CleaningTimelineItemTooltipComponent>;
  private _plannableComponent: ComponentRef<PlannableCleaningTooltipComponent>;

  constructor(@Inject(ComponentFactoryResolver) private _componentFactoryResolver: ComponentFactoryResolver) {
  }

  setRootViewContainerRef(viewContainerRef: ViewContainerRef) {
    this._rootViewContainerRef = viewContainerRef;
  }
  showTooltip(data: IPlannedCleaningTimelineItemData, siblingElement) {

    //this._showTooltipOverPlannableItems(data, siblingElement);
    this._showTooltipBelowTheHoveredItem(data, siblingElement);

  }

  showPlannableTooltip(data: ICleaningTimelineItemData, siblingElement) {
    this._showTooltipBelowTheHoveredPlannableItem(data, siblingElement);
  }

  private _showTooltipOverPlannableItems(data: IPlannedCleaningTimelineItemData, siblingElement) {
    // WARNING: THIS IMPLEMENTATION HAS PROBLEMS WITH MIN HEIGHT - WHEN THE USER DOESN'T HAVE MANY PLANNABLE ITEMS!
    // WARNING: THIS IMPLEMENTATION HAS PROBLEMS WITH MIN HEIGHT - WHEN THE USER DOESN'T HAVE MANY PLANNABLE ITEMS!
    // WARNING: THIS IMPLEMENTATION HAS PROBLEMS WITH MIN HEIGHT - WHEN THE USER DOESN'T HAVE MANY PLANNABLE ITEMS!
    this.hideTooltip();

    const factory = this._componentFactoryResolver.resolveComponentFactory(CleaningTimelineItemTooltipComponent);
    this._component = factory.create(this._rootViewContainerRef.parentInjector);
    this._component.instance.data = data;
    this._component.instance.ngOnInit();
    const boundingRectangle = siblingElement.getBoundingClientRect();

    const outerWrapper = document.querySelector(".selectable-timeline-items-wrapper");
    const outerWrapperBoundingRectangle = outerWrapper.getBoundingClientRect();

    const timelineWrapper = document.querySelector(".selectable-timeline-items-wrapper > .component-box");
    const timelineWrapperBoundingRectangle = timelineWrapper.getBoundingClientRect();

    let top = timelineWrapperBoundingRectangle.y;
    let height = timelineWrapperBoundingRectangle.height;
    let left = timelineWrapperBoundingRectangle.x;
    let width = timelineWrapperBoundingRectangle.width;

    const altHeight = outerWrapperBoundingRectangle.height - 10;
    if (altHeight < height) {
      height = altHeight;
    }

    //this._component.location.nativeElement.style = `position: fixed;top: ${top}px;bottom: ${bottom}px;right: ${right}px;width: ${width};`;
    this._component.location.nativeElement.style = `position: fixed;top: ${top}px;width: ${width}px;left: ${left}px;height: ${height}px; overflow-y: hidden;`;

    this._rootViewContainerRef.insert(this._component.hostView);
  }

  private _showTooltipBelowTheHoveredItem(data: IPlannedCleaningTimelineItemData, cleaningTimelineItemElement) {
    this.hideTooltip();

    const factory = this._componentFactoryResolver.resolveComponentFactory(CleaningTimelineItemTooltipComponent);
    this._component = factory.create(this._rootViewContainerRef.parentInjector);
    this._component.instance.data = data;
    this._component.changeDetectorRef.detectChanges();

    const timelineItemBoundingRectangle = cleaningTimelineItemElement.getBoundingClientRect();

    const tooltipBottomPaddingPx = 10;
    const tooltipWidthPx = 250;
    const tooltipWidthHalfPx = tooltipWidthPx / 2;

    const tooltipX = timelineItemBoundingRectangle.x + (timelineItemBoundingRectangle.width / 2) - tooltipWidthHalfPx;
    const tooltipY = timelineItemBoundingRectangle.y + timelineItemBoundingRectangle.height + tooltipBottomPaddingPx;

    this._component.location.nativeElement.style = "position: fixed; top: " + tooltipY + "px; left: " + tooltipX + "px; width: " + tooltipWidthPx + "px;";

    this._rootViewContainerRef.insert(this._component.hostView);
  }

  private _showTooltipBelowTheHoveredPlannableItem(data: ICleaningTimelineItemData, cleaningTimelineItemElement) {
    this.hideTooltip();

    const factory = this._componentFactoryResolver.resolveComponentFactory(PlannableCleaningTooltipComponent);
    this._plannableComponent = factory.create(this._rootViewContainerRef.parentInjector);
    this._plannableComponent.instance.data = data;
    this._plannableComponent.changeDetectorRef.detectChanges();

    const timelineItemBoundingRectangle = cleaningTimelineItemElement.getBoundingClientRect();

    const tooltipBottomPaddingPx = 10;
    const tooltipWidthPx = 250;
    const tooltipWidthHalfPx = tooltipWidthPx / 2;

    const tooltipX = timelineItemBoundingRectangle.x + (timelineItemBoundingRectangle.width / 2) - tooltipWidthHalfPx;
    const tooltipY = timelineItemBoundingRectangle.y + timelineItemBoundingRectangle.height + tooltipBottomPaddingPx;

    this._plannableComponent.location.nativeElement.style = "position: fixed; top: -8000px; left: -8000px; width: " + tooltipWidthPx + "px;z-index:100;";

    this._rootViewContainerRef.insert(this._plannableComponent.hostView);

    let that = this;

    setTimeout(() => {
      let tooltipRect = that._plannableComponent.location.nativeElement.getBoundingClientRect();

      let tooltipOnTopY = timelineItemBoundingRectangle.y - tooltipRect.height - tooltipBottomPaddingPx;
      that._plannableComponent.location.nativeElement.style = "position: fixed; top: " + tooltipOnTopY + "px; left: " + tooltipX + "px; width: " + tooltipWidthPx + "px;z-index:100;";
    }, 1);
  }

  hideTooltip() {
    if (this._component) {
      this._component.destroy();
    }
    if (this._plannableComponent) {
      this._plannableComponent.destroy();
    }
  }
}
